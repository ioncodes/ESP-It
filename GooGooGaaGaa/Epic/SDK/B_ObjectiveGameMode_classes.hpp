#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: B_ObjectiveGameMode

#include "Basic.hpp"

#include "E_ObjectiveTeam_structs.hpp"
#include "Engine_structs.hpp"
#include "B_SeekGameMode_classes.hpp"
#include "ETeamID_structs.hpp"


namespace SDK
{

// BlueprintGeneratedClass B_ObjectiveGameMode.B_ObjectiveGameMode_C
// 0x0060 (0x0618 - 0x05B8)
class AB_ObjectiveGameMode_C final : public AB_SeekGameMode_C
{
public:
	struct FPointerToUberGraphFrame               UberGraphFrame_B_ObjectiveGameMode_C;              // 0x05B8(0x0008)(ZeroConstructor, Transient, DuplicateTransient)
	TArray<class AB_ObjectiveWitchRespawnPoint_C*> AllWitchRespawnPoints;                             // 0x05C0(0x0010)(Edit, BlueprintVisible, DisableEditOnTemplate, DisableEditOnInstance)
	int32                                         OverTime;                                          // 0x05D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_5D4[0x4];                                      // 0x05D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AB_ObjectiveGameState_C*                ObjectiveGameState;                                // 0x05D8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash)
	double                                        StartSeekTime;                                     // 0x05E0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	int32                                         CurrentPlaytime;                                   // 0x05E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_5EC[0x4];                                      // 0x05EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AB_ObjectivePlayerController_C*         TempJoiningPlayer;                                 // 0x05F0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash)
	double                                        NoPlayersOnDynamicInstanceTime;                    // 0x05F8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	double                                        MaxTimeForDynamicInstanceToShutdown;               // 0x0600(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class UB_MatchOptions_C*                      NextRoundMatchOptions;                             // 0x0608(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash)
	double                                        ShudownTimer;                                      // 0x0610(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

public:
	void AreAllPlayersReadyWithTeamSelection(bool* AreReady);
	void CheckEndMatchWitchesDead();
	void CheckForOverTime(bool* OverTime_0);
	void CheckTimerForMatchStart();
	void CheckWitchesAlive(bool* WitchAlive);
	void EnsureInitialize();
	void EqualizeTeamSizes();
	void ExecuteUbergraph_B_ObjectiveGameMode(int32 EntryPoint);
	void GetBaseXPNumerator(double* Numerator);
	void GetPlayerPlayTime(class AB_PlayerState_C* PlayerState, int32* Playtime);
	void GetPlayerScoreStatManager(class AB_PlayerState_C* PlayerState, class UB_ScoreStatManager_C** ScoreStatManager);
	void GetRoundEndTimerUntilRestart(int32* Seconds);
	void GetTeamFromObjectiveTeamForThisRound(E_ObjectiveTeam ObjectiveTeam, ETeamID* Team);
	void GetTotalWitchesLives(int32* TotalWitchLives);
	void GetWinningObjectiveTeam(ETeamID WinnerTeam, E_ObjectiveTeam* WinnerObjectiveTeam);
	void HandleEndMatch(ETeamID WinnerTeam, bool ForceRegardlessOfEnd);
	void HandleEndMatchByTime();
	void HandleEndMatchOverride(ETeamID WinnerTeam, bool ForceRegardlessOfEnd);
	void HandleGrantExp(class AB_PlayerState_C* CurrentPlayerState, int32* TotalGrantedXp);
	void HandleStartFirstRound(bool ForceStartFirstRound);
	void HandleStartMatch();
	void HandleStartMatchOverride();
	void HandleStartSeek();
	void HandleStartSeekOverride();
	void Initialize();
	void InitializeOverride();
	void IsPlayerInWinnerTeam(class AB_PlayerState_C* PlayerState, bool* InWinnerTeam);
	void IsPlayerTeamSelectionBalanced(int32 RequiredPlayersPerTeam, bool* Balanced);
	void K2_OnLogout(class AController* ExitingController);
	void K2_PostLogin(class APlayerController* NewPlayer);
	void ReceiveBeginPlay();
	void ReceiveTick(float DeltaSeconds);
	void RespawnWitch(class AController* AffectedController, bool InitializeHealthFromPlayerState, bool* Success);
	void SpawnReviveTotem(class APlayerState* PlayerState);
	void StartFirstRound();
	void StartGame();
	void StartNewGame(bool RestartByPlayerJoin);
	void StartNewGameOverride(bool RestartByPlayerJoin, bool* StartNewGame_0);
	void SurrenderTeam(E_ObjectiveTeam SurrenderObjectiveTeam, ETeamID SurrenderTeam_0);
	void TimerFinished();
	void TimerSecondElapsed(double RemainingSeconds);
	void UnregisterPlayer(class AController* PlayerController);
	void UnregisterPlayerOverride(class AController* LeavingPlayerController);
	void UpdateCustomGameMatchOptions();

	void GetPlayObjectiveId(int64* ObjectiveId) const;
	void GetWinObjectiveId(int64* ObjectiveId) const;

public:
	static class UClass* StaticClass()
	{
		return StaticBPGeneratedClassImpl<"B_ObjectiveGameMode_C">();
	}
	static class AB_ObjectiveGameMode_C* GetDefaultObj()
	{
		return GetDefaultObjImpl<AB_ObjectiveGameMode_C>();
	}
};
static_assert(alignof(AB_ObjectiveGameMode_C) == 0x000008, "Wrong alignment on AB_ObjectiveGameMode_C");
static_assert(sizeof(AB_ObjectiveGameMode_C) == 0x000618, "Wrong size on AB_ObjectiveGameMode_C");
static_assert(offsetof(AB_ObjectiveGameMode_C, UberGraphFrame_B_ObjectiveGameMode_C) == 0x0005B8, "Member 'AB_ObjectiveGameMode_C::UberGraphFrame_B_ObjectiveGameMode_C' has a wrong offset!");
static_assert(offsetof(AB_ObjectiveGameMode_C, AllWitchRespawnPoints) == 0x0005C0, "Member 'AB_ObjectiveGameMode_C::AllWitchRespawnPoints' has a wrong offset!");
static_assert(offsetof(AB_ObjectiveGameMode_C, OverTime) == 0x0005D0, "Member 'AB_ObjectiveGameMode_C::OverTime' has a wrong offset!");
static_assert(offsetof(AB_ObjectiveGameMode_C, ObjectiveGameState) == 0x0005D8, "Member 'AB_ObjectiveGameMode_C::ObjectiveGameState' has a wrong offset!");
static_assert(offsetof(AB_ObjectiveGameMode_C, StartSeekTime) == 0x0005E0, "Member 'AB_ObjectiveGameMode_C::StartSeekTime' has a wrong offset!");
static_assert(offsetof(AB_ObjectiveGameMode_C, CurrentPlaytime) == 0x0005E8, "Member 'AB_ObjectiveGameMode_C::CurrentPlaytime' has a wrong offset!");
static_assert(offsetof(AB_ObjectiveGameMode_C, TempJoiningPlayer) == 0x0005F0, "Member 'AB_ObjectiveGameMode_C::TempJoiningPlayer' has a wrong offset!");
static_assert(offsetof(AB_ObjectiveGameMode_C, NoPlayersOnDynamicInstanceTime) == 0x0005F8, "Member 'AB_ObjectiveGameMode_C::NoPlayersOnDynamicInstanceTime' has a wrong offset!");
static_assert(offsetof(AB_ObjectiveGameMode_C, MaxTimeForDynamicInstanceToShutdown) == 0x000600, "Member 'AB_ObjectiveGameMode_C::MaxTimeForDynamicInstanceToShutdown' has a wrong offset!");
static_assert(offsetof(AB_ObjectiveGameMode_C, NextRoundMatchOptions) == 0x000608, "Member 'AB_ObjectiveGameMode_C::NextRoundMatchOptions' has a wrong offset!");
static_assert(offsetof(AB_ObjectiveGameMode_C, ShudownTimer) == 0x000610, "Member 'AB_ObjectiveGameMode_C::ShudownTimer' has a wrong offset!");

}

