#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: TypedElementFramework

#include "Basic.hpp"

#include "CoreUObject_classes.hpp"


namespace SDK
{

// Class TypedElementFramework.TypedElementDataStorageCompatibilityInterface
// 0x0000 (0x0028 - 0x0028)
class ITypedElementDataStorageCompatibilityInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TypedElementDataStorageCompatibilityInterface">();
	}
	static class ITypedElementDataStorageCompatibilityInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ITypedElementDataStorageCompatibilityInterface>();
	}
};
static_assert(alignof(ITypedElementDataStorageCompatibilityInterface) == 0x000008, "Wrong alignment on ITypedElementDataStorageCompatibilityInterface");
static_assert(sizeof(ITypedElementDataStorageCompatibilityInterface) == 0x000028, "Wrong size on ITypedElementDataStorageCompatibilityInterface");

// Class TypedElementFramework.TypedElementDataStorageFactory
// 0x0000 (0x0028 - 0x0028)
class UTypedElementDataStorageFactory final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TypedElementDataStorageFactory">();
	}
	static class UTypedElementDataStorageFactory* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTypedElementDataStorageFactory>();
	}
};
static_assert(alignof(UTypedElementDataStorageFactory) == 0x000008, "Wrong alignment on UTypedElementDataStorageFactory");
static_assert(sizeof(UTypedElementDataStorageFactory) == 0x000028, "Wrong size on UTypedElementDataStorageFactory");

// Class TypedElementFramework.TypedElementDataStorageInterface
// 0x0000 (0x0028 - 0x0028)
class ITypedElementDataStorageInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TypedElementDataStorageInterface">();
	}
	static class ITypedElementDataStorageInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ITypedElementDataStorageInterface>();
	}
};
static_assert(alignof(ITypedElementDataStorageInterface) == 0x000008, "Wrong alignment on ITypedElementDataStorageInterface");
static_assert(sizeof(ITypedElementDataStorageInterface) == 0x000028, "Wrong size on ITypedElementDataStorageInterface");

// Class TypedElementFramework.TypedElementDataStorageUiInterface
// 0x0000 (0x0028 - 0x0028)
class ITypedElementDataStorageUiInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TypedElementDataStorageUiInterface">();
	}
	static class ITypedElementDataStorageUiInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ITypedElementDataStorageUiInterface>();
	}
};
static_assert(alignof(ITypedElementDataStorageUiInterface) == 0x000008, "Wrong alignment on ITypedElementDataStorageUiInterface");
static_assert(sizeof(ITypedElementDataStorageUiInterface) == 0x000028, "Wrong size on ITypedElementDataStorageUiInterface");

// Class TypedElementFramework.TypedElementHandleLibrary
// 0x0000 (0x0028 - 0x0028)
class UTypedElementHandleLibrary final : public UObject
{
public:
	static bool Equal(const struct FScriptTypedElementHandle& LHS, const struct FScriptTypedElementHandle& RHS);
	static bool IsSet(const struct FScriptTypedElementHandle& ElementHandle);
	static bool NotEqual(const struct FScriptTypedElementHandle& LHS, const struct FScriptTypedElementHandle& RHS);
	static void Release(struct FScriptTypedElementHandle& ElementHandle);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TypedElementHandleLibrary">();
	}
	static class UTypedElementHandleLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTypedElementHandleLibrary>();
	}
};
static_assert(alignof(UTypedElementHandleLibrary) == 0x000008, "Wrong alignment on UTypedElementHandleLibrary");
static_assert(sizeof(UTypedElementHandleLibrary) == 0x000028, "Wrong size on UTypedElementHandleLibrary");

// Class TypedElementFramework.TypedElementListLibrary
// 0x0000 (0x0028 - 0x0028)
class UTypedElementListLibrary final : public UObject
{
public:
	static bool Add(const struct FScriptTypedElementListProxy& ElementList, const struct FScriptTypedElementHandle& ElementHandle);
	static void Append(const struct FScriptTypedElementListProxy& ElementList, const TArray<struct FScriptTypedElementHandle>& ElementHandles);
	static void AppendList(const struct FScriptTypedElementListProxy& ElementList, const struct FScriptTypedElementListProxy& OtherElementList);
	static struct FScriptTypedElementListProxy Clone(const struct FScriptTypedElementListProxy& ElementList);
	static bool Contains(const struct FScriptTypedElementListProxy& ElementList, const struct FScriptTypedElementHandle& ElementHandle);
	static int32 CountElements(const struct FScriptTypedElementListProxy& ElementList, const TSubclassOf<class IInterface> BaseInterfaceType);
	static int32 CountElementsOfType(const struct FScriptTypedElementListProxy& ElementList, const class FName ElementTypeName);
	static struct FScriptTypedElementListProxy CreateScriptElementList(class UTypedElementRegistry* Registry);
	static void Empty(const struct FScriptTypedElementListProxy& ElementList, const int32 Slack);
	static struct FScriptTypedElementHandle GetElementHandleAt(const struct FScriptTypedElementListProxy& ElementList, const int32 Index_0);
	static TArray<struct FScriptTypedElementHandle> GetElementHandles(const struct FScriptTypedElementListProxy& ElementList, const TSubclassOf<class IInterface> BaseInterfaceType);
	static class UObject* GetElementInterface(const struct FScriptTypedElementListProxy& ElementList, const struct FScriptTypedElementHandle& ElementHandle, const TSubclassOf<class IInterface> BaseInterfaceType);
	static bool HasElements(const struct FScriptTypedElementListProxy& ElementList, const TSubclassOf<class IInterface> BaseInterfaceType);
	static bool HasElementsOfType(const struct FScriptTypedElementListProxy& ElementList, const class FName ElementTypeName);
	static bool IsValidIndex(const struct FScriptTypedElementListProxy& ElementList, const int32 Index_0);
	static int32 Num(const struct FScriptTypedElementListProxy& ElementList);
	static bool Remove(const struct FScriptTypedElementListProxy& ElementList, const struct FScriptTypedElementHandle& ElementHandle);
	static void Reserve(const struct FScriptTypedElementListProxy& ElementList, const int32 Size);
	static void Reset(const struct FScriptTypedElementListProxy& ElementList);
	static void Shrink(const struct FScriptTypedElementListProxy& ElementList);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TypedElementListLibrary">();
	}
	static class UTypedElementListLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTypedElementListLibrary>();
	}
};
static_assert(alignof(UTypedElementListLibrary) == 0x000008, "Wrong alignment on UTypedElementListLibrary");
static_assert(sizeof(UTypedElementListLibrary) == 0x000028, "Wrong size on UTypedElementListLibrary");

// Class TypedElementFramework.TypedElementCounterInterface
// 0x0000 (0x0028 - 0x0028)
class ITypedElementCounterInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TypedElementCounterInterface">();
	}
	static class ITypedElementCounterInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ITypedElementCounterInterface>();
	}
};
static_assert(alignof(ITypedElementCounterInterface) == 0x000008, "Wrong alignment on ITypedElementCounterInterface");
static_assert(sizeof(ITypedElementCounterInterface) == 0x000028, "Wrong size on ITypedElementCounterInterface");

// Class TypedElementFramework.TypedElementRegistry
// 0x0950 (0x0978 - 0x0028)
class UTypedElementRegistry final : public UObject
{
public:
	uint8                                         Pad_28[0x950];                                     // 0x0028(0x0950)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UTypedElementRegistry* GetInstance();

	class UObject* GetElementInterface(const struct FScriptTypedElementHandle& InElementHandle, const TSubclassOf<class IInterface> InBaseInterfaceType) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TypedElementRegistry">();
	}
	static class UTypedElementRegistry* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTypedElementRegistry>();
	}
};
static_assert(alignof(UTypedElementRegistry) == 0x000008, "Wrong alignment on UTypedElementRegistry");
static_assert(sizeof(UTypedElementRegistry) == 0x000978, "Wrong size on UTypedElementRegistry");

// Class TypedElementFramework.TestTypedElementInterfaceA
// 0x0000 (0x0028 - 0x0028)
class ITestTypedElementInterfaceA final : public IInterface
{
public:
	class FText GetDisplayName(const struct FScriptTypedElementHandle& InElementHandle);
	bool SetDisplayName(const struct FScriptTypedElementHandle& InElementHandle, const class FText& InNewName, bool bNotify);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TestTypedElementInterfaceA">();
	}
	static class ITestTypedElementInterfaceA* GetDefaultObj()
	{
		return GetDefaultObjImpl<ITestTypedElementInterfaceA>();
	}
};
static_assert(alignof(ITestTypedElementInterfaceA) == 0x000008, "Wrong alignment on ITestTypedElementInterfaceA");
static_assert(sizeof(ITestTypedElementInterfaceA) == 0x000028, "Wrong size on ITestTypedElementInterfaceA");

// Class TypedElementFramework.TestTypedElementInterfaceB
// 0x0000 (0x0028 - 0x0028)
class ITestTypedElementInterfaceB final : public IInterface
{
public:
	bool MarkAsTested(const struct FScriptTypedElementHandle& InElementHandle);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TestTypedElementInterfaceB">();
	}
	static class ITestTypedElementInterfaceB* GetDefaultObj()
	{
		return GetDefaultObjImpl<ITestTypedElementInterfaceB>();
	}
};
static_assert(alignof(ITestTypedElementInterfaceB) == 0x000008, "Wrong alignment on ITestTypedElementInterfaceB");
static_assert(sizeof(ITestTypedElementInterfaceB) == 0x000028, "Wrong size on ITestTypedElementInterfaceB");

// Class TypedElementFramework.TestTypedElementInterfaceC
// 0x0000 (0x0028 - 0x0028)
class ITestTypedElementInterfaceC final : public IInterface
{
public:
	bool GetIsTested(const struct FScriptTypedElementHandle& InElementHandle) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TestTypedElementInterfaceC">();
	}
	static class ITestTypedElementInterfaceC* GetDefaultObj()
	{
		return GetDefaultObjImpl<ITestTypedElementInterfaceC>();
	}
};
static_assert(alignof(ITestTypedElementInterfaceC) == 0x000008, "Wrong alignment on ITestTypedElementInterfaceC");
static_assert(sizeof(ITestTypedElementInterfaceC) == 0x000028, "Wrong size on ITestTypedElementInterfaceC");

// Class TypedElementFramework.TestTypedElementInterfaceA_ImplTyped
// 0x0008 (0x0030 - 0x0028)
class UTestTypedElementInterfaceA_ImplTyped final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TestTypedElementInterfaceA_ImplTyped">();
	}
	static class UTestTypedElementInterfaceA_ImplTyped* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTestTypedElementInterfaceA_ImplTyped>();
	}
};
static_assert(alignof(UTestTypedElementInterfaceA_ImplTyped) == 0x000008, "Wrong alignment on UTestTypedElementInterfaceA_ImplTyped");
static_assert(sizeof(UTestTypedElementInterfaceA_ImplTyped) == 0x000030, "Wrong size on UTestTypedElementInterfaceA_ImplTyped");

// Class TypedElementFramework.TestTypedElementInterfaceA_ImplUntyped
// 0x0008 (0x0030 - 0x0028)
class UTestTypedElementInterfaceA_ImplUntyped final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TestTypedElementInterfaceA_ImplUntyped">();
	}
	static class UTestTypedElementInterfaceA_ImplUntyped* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTestTypedElementInterfaceA_ImplUntyped>();
	}
};
static_assert(alignof(UTestTypedElementInterfaceA_ImplUntyped) == 0x000008, "Wrong alignment on UTestTypedElementInterfaceA_ImplUntyped");
static_assert(sizeof(UTestTypedElementInterfaceA_ImplUntyped) == 0x000030, "Wrong size on UTestTypedElementInterfaceA_ImplUntyped");

// Class TypedElementFramework.TestTypedElementInterfaceBAndC_Typed
// 0x0010 (0x0038 - 0x0028)
class UTestTypedElementInterfaceBAndC_Typed final : public UObject
{
public:
	uint8                                         Pad_28[0x10];                                      // 0x0028(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TestTypedElementInterfaceBAndC_Typed">();
	}
	static class UTestTypedElementInterfaceBAndC_Typed* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTestTypedElementInterfaceBAndC_Typed>();
	}
};
static_assert(alignof(UTestTypedElementInterfaceBAndC_Typed) == 0x000008, "Wrong alignment on UTestTypedElementInterfaceBAndC_Typed");
static_assert(sizeof(UTestTypedElementInterfaceBAndC_Typed) == 0x000038, "Wrong size on UTestTypedElementInterfaceBAndC_Typed");

}

