#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: LowEntryFileManager

#include "Basic.hpp"

#include "CoreUObject_classes.hpp"
#include "LowEntryFileManager_structs.hpp"
#include "Engine_classes.hpp"


namespace SDK
{

// Class LowEntryFileManager.LowEntryFileManagerDirectory
// 0x0038 (0x0060 - 0x0028)
class ULowEntryFileManagerDirectory final : public UObject
{
public:
	class FString                                 Directory;                                         // 0x0028(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Name_0;                                            // 0x0038(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Path;                                              // 0x0048(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsRoot;                                           // 0x0058(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Clear();
	void CopyTo(class ULowEntryFileManagerDirectory* NewDirectory, const bool OverrideExistingFiles);
	void Create();
	void Delete();
	void Exists(ELowEntryFileManagerYesNo* Branch);
	bool ExistsBool();
	TArray<class ULowEntryFileManagerDirectory*> GetDirectories();
	class ULowEntryFileManagerDirectory* GetDirectory(const class FString& Directory_);
	class ULowEntryFileManagerFile* GetFile(const class FString& File);
	TArray<class ULowEntryFileManagerFile*> GetFiles();
	class ULowEntryFileManagerDirectory* GetParentDirectory();
	void IsEmpty(ELowEntryFileManagerYesNo* Branch);
	bool IsEmptyBool();
	void IsRoot(ELowEntryFileManagerYesNo* Branch);
	bool IsRootBool();
	void MoveTo(class ULowEntryFileManagerDirectory* NewDirectory, const bool OverrideExistingFiles);

	class FString GetAbsolutePath() const;
	class FString GetDirName() const;
	class FString GetPath() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LowEntryFileManagerDirectory">();
	}
	static class ULowEntryFileManagerDirectory* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULowEntryFileManagerDirectory>();
	}
};
static_assert(alignof(ULowEntryFileManagerDirectory) == 0x000008, "Wrong alignment on ULowEntryFileManagerDirectory");
static_assert(sizeof(ULowEntryFileManagerDirectory) == 0x000060, "Wrong size on ULowEntryFileManagerDirectory");
static_assert(offsetof(ULowEntryFileManagerDirectory, Directory) == 0x000028, "Member 'ULowEntryFileManagerDirectory::Directory' has a wrong offset!");
static_assert(offsetof(ULowEntryFileManagerDirectory, Name_0) == 0x000038, "Member 'ULowEntryFileManagerDirectory::Name_0' has a wrong offset!");
static_assert(offsetof(ULowEntryFileManagerDirectory, Path) == 0x000048, "Member 'ULowEntryFileManagerDirectory::Path' has a wrong offset!");
static_assert(offsetof(ULowEntryFileManagerDirectory, bIsRoot) == 0x000058, "Member 'ULowEntryFileManagerDirectory::bIsRoot' has a wrong offset!");

// Class LowEntryFileManager.LowEntryFileManagerFile
// 0x0030 (0x0058 - 0x0028)
class ULowEntryFileManagerFile final : public UObject
{
public:
	class FString                                 Directory;                                         // 0x0028(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Name_0;                                            // 0x0038(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Path;                                              // 0x0048(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void AppendData(const TArray<uint8>& Data);
	void Clear();
	void CopyTo(class ULowEntryFileManagerFile* NewFile);
	void Create();
	void Delete();
	void Execute(const class FString& Parameters, bool* Success, int32* ReturnCode, class FString* StdOut, class FString* StdErr);
	void ExecuteAsync(const class FString& Parameters, bool* Success, int32* ProcessId, const bool Hidden, const int32 Priority, class ULowEntryFileManagerDirectory* OptionalWorkingDirectory);
	void Exists(ELowEntryFileManagerYesNo* Branch);
	bool ExistsBool();
	struct FDateTime GetAccessTimestamp();
	TArray<uint8> GetData();
	TArray<uint8> GetDataUnsafe();
	class ULowEntryFileManagerDirectory* GetParentDirectory();
	struct FDateTime GetTimeStamp();
	void IsEmpty(ELowEntryFileManagerYesNo* Branch);
	bool IsEmptyBool();
	void IsReadOnly(ELowEntryFileManagerYesNo* Branch);
	bool IsReadOnlyBool();
	void MoveTo(class ULowEntryFileManagerFile* NewFile);
	void SetData(const TArray<uint8>& Data);
	void SetReadOnly(const bool ReadOnly);
	void SetTimestamp(const struct FDateTime& Timestamp);
	int32 Size();
	int64 SizeUnsafe();

	class FString GetAbsolutePath() const;
	class FString GetExtension() const;
	class FString GetFileName() const;
	class FString GetFileNameWithoutExtension() const;
	class FString GetPath() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LowEntryFileManagerFile">();
	}
	static class ULowEntryFileManagerFile* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULowEntryFileManagerFile>();
	}
};
static_assert(alignof(ULowEntryFileManagerFile) == 0x000008, "Wrong alignment on ULowEntryFileManagerFile");
static_assert(sizeof(ULowEntryFileManagerFile) == 0x000058, "Wrong size on ULowEntryFileManagerFile");
static_assert(offsetof(ULowEntryFileManagerFile, Directory) == 0x000028, "Member 'ULowEntryFileManagerFile::Directory' has a wrong offset!");
static_assert(offsetof(ULowEntryFileManagerFile, Name_0) == 0x000038, "Member 'ULowEntryFileManagerFile::Name_0' has a wrong offset!");
static_assert(offsetof(ULowEntryFileManagerFile, Path) == 0x000048, "Member 'ULowEntryFileManagerFile::Path' has a wrong offset!");

// Class LowEntryFileManager.LowEntryFileManagerLibrary
// 0x0000 (0x0028 - 0x0028)
class ULowEntryFileManagerLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void AppendFileData(const class FString& File, const TArray<uint8>& Data);
	static void ClearDirectory(const class FString& Directory);
	static void ClearFile(const class FString& File);
	static void CopyDirectory(const class FString& Directory, const class FString& To, const bool OverrideExistingFiles);
	static void CopyFile(const class FString& File, const class FString& To);
	static void CreateNewDirectory(const class FString& Directory);
	static void CreateNewFile(const class FString& File);
	static void CreateParentDirectory(const class FString& Path);
	static void DeleteDirectory(const class FString& Directory);
	static void DeleteFile(const class FString& File);
	static void DirectoryExists(const class FString& Directory, ELowEntryFileManagerYesNo* Branch);
	static bool DirectoryExistsBool(const class FString& Directory);
	static void ExecuteFile(const class FString& File, const class FString& Parameters, bool* Success, int32* ReturnCode, class FString* StdOut, class FString* StdErr);
	static void ExecuteFileAsync(const class FString& File, const class FString& Parameters, bool* Success, int32* ProcessId, const bool Hidden, const int32 Priority, const class FString& OptionalWorkingDirectory);
	static void FileExists(const class FString& File, ELowEntryFileManagerYesNo* Branch);
	static bool FileExistsBool(const class FString& File);
	static class ULowEntryFileManagerDirectory* GetAbsoluteRoot();
	static class FString GetCloudDirPath();
	static TArray<class FString> GetDirectories(const class FString& Directory);
	static class ULowEntryFileManagerDirectory* GetDirectory(const class FString& Path);
	static TArray<class FString> GetDirectoryNames(const class FString& Directory);
	static TArray<class FString> GetDiskPaths();
	static TArray<class ULowEntryFileManagerDirectory*> GetDisks();
	static class FString GetEngineDirPath();
	static class FString GetEngineSavedDirPath();
	static struct FDateTime GetFileAccessTimestamp(const class FString& File);
	static TArray<uint8> GetFileData(const class FString& File);
	static TArray<uint8> GetFileDataUnsafe(const class FString& File);
	static TArray<class FString> GetFileNames(const class FString& Directory);
	static TArray<class FString> GetFiles(const class FString& Directory);
	static int32 GetFileSize(const class FString& File);
	static int64 GetFileSizeUnsafe(const class FString& File);
	static struct FDateTime GetFileTimestamp(const class FString& File);
	static class FString GetGameDirPath();
	static class FString GetGamePersistentDownloadDirPath();
	static class FString GetGameSavedDirPath();
	static class FString GetGameUserDirPath();
	static class FString GetProjectFilePath();
	static class ULowEntryFileManagerDirectory* GetRoot();
	static class FString GetRootDirPath();
	static void HasDiskPaths(ELowEntryFileManagerYesNo* Branch);
	static bool HasDiskPathsBool();
	static void IsDirectoryEmpty(const class FString& Directory, ELowEntryFileManagerYesNo* Branch);
	static bool IsDirectoryEmptyBool(const class FString& Directory);
	static void IsFileEmpty(const class FString& File, ELowEntryFileManagerYesNo* Branch);
	static bool IsFileEmptyBool(const class FString& File);
	static void IsFileReadOnly(const class FString& File, ELowEntryFileManagerYesNo* Branch);
	static bool IsFileReadOnlyBool(const class FString& File);
	static void MoveDirectory(const class FString& Directory, const class FString& To, const bool OverrideExistingFiles);
	static void MoveFile(const class FString& File, const class FString& To);
	static class FString RelativeToAbsolutePath(const class FString& RelativePath);
	static class FString RemoveInvalidFilenameCharacters(const class FString& String);
	static class FString RemoveInvalidPathCharacters(const class FString& String);
	static class FString ReplaceBackslashesBySlashes(const class FString& String);
	static class FString ReplaceInvalidFilenameCharacters(const class FString& String, const class FString& ReplacementCharacter);
	static class FString ReplaceInvalidPathCharacters(const class FString& String, const class FString& ReplacementCharacter);
	static void SetFileData(const class FString& File, const TArray<uint8>& Data);
	static void SetFileReadOnly(const class FString& File, const bool ReadOnly);
	static void SetFileTimestamp(const class FString& File, const struct FDateTime& Timestamp);
	static void SplitName(const class FString& Name_0, class FString* NamePart, class FString* ExtensionPart);
	static void SplitPath(const class FString& Path, class FString* PathPart, class FString* NamePart);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LowEntryFileManagerLibrary">();
	}
	static class ULowEntryFileManagerLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULowEntryFileManagerLibrary>();
	}
};
static_assert(alignof(ULowEntryFileManagerLibrary) == 0x000008, "Wrong alignment on ULowEntryFileManagerLibrary");
static_assert(sizeof(ULowEntryFileManagerLibrary) == 0x000028, "Wrong size on ULowEntryFileManagerLibrary");

}

