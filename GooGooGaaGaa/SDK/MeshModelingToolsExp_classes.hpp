#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: MeshModelingToolsExp

#include "Basic.hpp"

#include "MeshModelingToolsExp_structs.hpp"
#include "ModelingOperators_structs.hpp"
#include "MeshModelingTools_structs.hpp"
#include "MeshModelingTools_classes.hpp"
#include "InteractiveToolsFramework_structs.hpp"
#include "InteractiveToolsFramework_classes.hpp"
#include "ModelingComponents_structs.hpp"
#include "ModelingComponents_classes.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"


namespace SDK
{

// Class MeshModelingToolsExp.BakeInputMeshProperties
// 0x0098 (0x0140 - 0x00A8)
class UBakeInputMeshProperties final : public UInteractiveToolPropertySet
{
public:
	class UStaticMesh*                            TargetStaticMesh;                                  // 0x00A8(0x0008)(Edit, ZeroConstructor, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMesh*                          TargetSkeletalMesh;                                // 0x00B0(0x0008)(Edit, ZeroConstructor, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 TargetDynamicMesh;                                 // 0x00B8(0x0008)(Edit, ZeroConstructor, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 TargetUVLayer;                                     // 0x00C0(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasTargetUVLayer;                                 // 0x00D0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D1[0x7];                                       // 0x00D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMesh*                            SourceStaticMesh;                                  // 0x00D8(0x0008)(Edit, ZeroConstructor, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMesh*                          SourceSkeletalMesh;                                // 0x00E0(0x0008)(Edit, ZeroConstructor, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 SourceDynamicMesh;                                 // 0x00E8(0x0008)(Edit, ZeroConstructor, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHideSourceMesh;                                   // 0x00F0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F1[0x7];                                       // 0x00F1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             SourceNormalMap;                                   // 0x00F8(0x0008)(Edit, ZeroConstructor, NoDestructor, AdvancedDisplay, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SourceNormalMapUVLayer;                            // 0x0100(0x0010)(Edit, ZeroConstructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBakeNormalSpace                              SourceNormalSpace;                                 // 0x0110(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasSourceNormalMap;                               // 0x0114(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_115[0x3];                                      // 0x0115(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ProjectionDistance;                                // 0x0118(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bProjectionInWorldSpace;                           // 0x011C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11D[0x3];                                      // 0x011D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         TargetUVLayerNamesList;                            // 0x0120(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FString>                         SourceUVLayerNamesList;                            // 0x0130(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)

public:
	const TArray<class FString> GetSourceUVLayerNamesFunc() const;
	const TArray<class FString> GetTargetUVLayerNamesFunc() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BakeInputMeshProperties">();
	}
	static class UBakeInputMeshProperties* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBakeInputMeshProperties>();
	}
};
static_assert(alignof(UBakeInputMeshProperties) == 0x000008, "Wrong alignment on UBakeInputMeshProperties");
static_assert(sizeof(UBakeInputMeshProperties) == 0x000140, "Wrong size on UBakeInputMeshProperties");
static_assert(offsetof(UBakeInputMeshProperties, TargetStaticMesh) == 0x0000A8, "Member 'UBakeInputMeshProperties::TargetStaticMesh' has a wrong offset!");
static_assert(offsetof(UBakeInputMeshProperties, TargetSkeletalMesh) == 0x0000B0, "Member 'UBakeInputMeshProperties::TargetSkeletalMesh' has a wrong offset!");
static_assert(offsetof(UBakeInputMeshProperties, TargetDynamicMesh) == 0x0000B8, "Member 'UBakeInputMeshProperties::TargetDynamicMesh' has a wrong offset!");
static_assert(offsetof(UBakeInputMeshProperties, TargetUVLayer) == 0x0000C0, "Member 'UBakeInputMeshProperties::TargetUVLayer' has a wrong offset!");
static_assert(offsetof(UBakeInputMeshProperties, bHasTargetUVLayer) == 0x0000D0, "Member 'UBakeInputMeshProperties::bHasTargetUVLayer' has a wrong offset!");
static_assert(offsetof(UBakeInputMeshProperties, SourceStaticMesh) == 0x0000D8, "Member 'UBakeInputMeshProperties::SourceStaticMesh' has a wrong offset!");
static_assert(offsetof(UBakeInputMeshProperties, SourceSkeletalMesh) == 0x0000E0, "Member 'UBakeInputMeshProperties::SourceSkeletalMesh' has a wrong offset!");
static_assert(offsetof(UBakeInputMeshProperties, SourceDynamicMesh) == 0x0000E8, "Member 'UBakeInputMeshProperties::SourceDynamicMesh' has a wrong offset!");
static_assert(offsetof(UBakeInputMeshProperties, bHideSourceMesh) == 0x0000F0, "Member 'UBakeInputMeshProperties::bHideSourceMesh' has a wrong offset!");
static_assert(offsetof(UBakeInputMeshProperties, SourceNormalMap) == 0x0000F8, "Member 'UBakeInputMeshProperties::SourceNormalMap' has a wrong offset!");
static_assert(offsetof(UBakeInputMeshProperties, SourceNormalMapUVLayer) == 0x000100, "Member 'UBakeInputMeshProperties::SourceNormalMapUVLayer' has a wrong offset!");
static_assert(offsetof(UBakeInputMeshProperties, SourceNormalSpace) == 0x000110, "Member 'UBakeInputMeshProperties::SourceNormalSpace' has a wrong offset!");
static_assert(offsetof(UBakeInputMeshProperties, bHasSourceNormalMap) == 0x000114, "Member 'UBakeInputMeshProperties::bHasSourceNormalMap' has a wrong offset!");
static_assert(offsetof(UBakeInputMeshProperties, ProjectionDistance) == 0x000118, "Member 'UBakeInputMeshProperties::ProjectionDistance' has a wrong offset!");
static_assert(offsetof(UBakeInputMeshProperties, bProjectionInWorldSpace) == 0x00011C, "Member 'UBakeInputMeshProperties::bProjectionInWorldSpace' has a wrong offset!");
static_assert(offsetof(UBakeInputMeshProperties, TargetUVLayerNamesList) == 0x000120, "Member 'UBakeInputMeshProperties::TargetUVLayerNamesList' has a wrong offset!");
static_assert(offsetof(UBakeInputMeshProperties, SourceUVLayerNamesList) == 0x000130, "Member 'UBakeInputMeshProperties::SourceUVLayerNamesList' has a wrong offset!");

// Class MeshModelingToolsExp.EditPivotTool
// 0x0188 (0x0240 - 0x00B8)
class alignas(0x10) UEditPivotTool final : public UMultiSelectionMeshEditingTool
{
public:
	uint8                                         Pad_B8[0x10];                                      // 0x00B8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UEditPivotToolProperties*               TransformProps;                                    // 0x00C8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEditPivotToolActionPropertySet*        EditPivotActions;                                  // 0x00D0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D8[0xD8];                                      // 0x00D8(0x00D8)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FEditPivotTarget>               ActiveGizmos;                                      // 0x01B0(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class UDragAlignmentMechanic*                 DragAlignmentMechanic;                             // 0x01C0(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1C8[0x78];                                     // 0x01C8(0x0078)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EditPivotTool">();
	}
	static class UEditPivotTool* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEditPivotTool>();
	}
};
static_assert(alignof(UEditPivotTool) == 0x000010, "Wrong alignment on UEditPivotTool");
static_assert(sizeof(UEditPivotTool) == 0x000240, "Wrong size on UEditPivotTool");
static_assert(offsetof(UEditPivotTool, TransformProps) == 0x0000C8, "Member 'UEditPivotTool::TransformProps' has a wrong offset!");
static_assert(offsetof(UEditPivotTool, EditPivotActions) == 0x0000D0, "Member 'UEditPivotTool::EditPivotActions' has a wrong offset!");
static_assert(offsetof(UEditPivotTool, ActiveGizmos) == 0x0001B0, "Member 'UEditPivotTool::ActiveGizmos' has a wrong offset!");
static_assert(offsetof(UEditPivotTool, DragAlignmentMechanic) == 0x0001C0, "Member 'UEditPivotTool::DragAlignmentMechanic' has a wrong offset!");

// Class MeshModelingToolsExp.BakeNormalMapToolProperties
// 0x0000 (0x00A8 - 0x00A8)
class UBakeNormalMapToolProperties final : public UInteractiveToolPropertySet
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BakeNormalMapToolProperties">();
	}
	static class UBakeNormalMapToolProperties* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBakeNormalMapToolProperties>();
	}
};
static_assert(alignof(UBakeNormalMapToolProperties) == 0x000008, "Wrong alignment on UBakeNormalMapToolProperties");
static_assert(sizeof(UBakeNormalMapToolProperties) == 0x0000A8, "Wrong size on UBakeNormalMapToolProperties");

// Class MeshModelingToolsExp.BakeOcclusionMapToolProperties
// 0x0010 (0x00B8 - 0x00A8)
class UBakeOcclusionMapToolProperties final : public UInteractiveToolPropertySet
{
public:
	int32                                         OcclusionRays;                                     // 0x00A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDistance;                                       // 0x00AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpreadAngle;                                       // 0x00B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BiasAngle;                                         // 0x00B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BakeOcclusionMapToolProperties">();
	}
	static class UBakeOcclusionMapToolProperties* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBakeOcclusionMapToolProperties>();
	}
};
static_assert(alignof(UBakeOcclusionMapToolProperties) == 0x000008, "Wrong alignment on UBakeOcclusionMapToolProperties");
static_assert(sizeof(UBakeOcclusionMapToolProperties) == 0x0000B8, "Wrong size on UBakeOcclusionMapToolProperties");
static_assert(offsetof(UBakeOcclusionMapToolProperties, OcclusionRays) == 0x0000A8, "Member 'UBakeOcclusionMapToolProperties::OcclusionRays' has a wrong offset!");
static_assert(offsetof(UBakeOcclusionMapToolProperties, MaxDistance) == 0x0000AC, "Member 'UBakeOcclusionMapToolProperties::MaxDistance' has a wrong offset!");
static_assert(offsetof(UBakeOcclusionMapToolProperties, SpreadAngle) == 0x0000B0, "Member 'UBakeOcclusionMapToolProperties::SpreadAngle' has a wrong offset!");
static_assert(offsetof(UBakeOcclusionMapToolProperties, BiasAngle) == 0x0000B4, "Member 'UBakeOcclusionMapToolProperties::BiasAngle' has a wrong offset!");

// Class MeshModelingToolsExp.LatticeDeformerToolBuilder
// 0x0000 (0x0028 - 0x0028)
class ULatticeDeformerToolBuilder final : public USingleSelectionMeshEditingToolBuilder
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LatticeDeformerToolBuilder">();
	}
	static class ULatticeDeformerToolBuilder* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULatticeDeformerToolBuilder>();
	}
};
static_assert(alignof(ULatticeDeformerToolBuilder) == 0x000008, "Wrong alignment on ULatticeDeformerToolBuilder");
static_assert(sizeof(ULatticeDeformerToolBuilder) == 0x000028, "Wrong size on ULatticeDeformerToolBuilder");

// Class MeshModelingToolsExp.BakeCurvatureMapToolProperties
// 0x0018 (0x00C0 - 0x00A8)
class UBakeCurvatureMapToolProperties final : public UInteractiveToolPropertySet
{
public:
	EBakeCurvatureTypeMode                        CurvatureType;                                     // 0x00A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBakeCurvatureColorMode                       ColorMapping;                                      // 0x00AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ColorRangeMultiplier;                              // 0x00B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinRangeMultiplier;                                // 0x00B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBakeCurvatureClampMode                       Clamping;                                          // 0x00B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BC[0x4];                                       // 0x00BC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BakeCurvatureMapToolProperties">();
	}
	static class UBakeCurvatureMapToolProperties* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBakeCurvatureMapToolProperties>();
	}
};
static_assert(alignof(UBakeCurvatureMapToolProperties) == 0x000008, "Wrong alignment on UBakeCurvatureMapToolProperties");
static_assert(sizeof(UBakeCurvatureMapToolProperties) == 0x0000C0, "Wrong size on UBakeCurvatureMapToolProperties");
static_assert(offsetof(UBakeCurvatureMapToolProperties, CurvatureType) == 0x0000A8, "Member 'UBakeCurvatureMapToolProperties::CurvatureType' has a wrong offset!");
static_assert(offsetof(UBakeCurvatureMapToolProperties, ColorMapping) == 0x0000AC, "Member 'UBakeCurvatureMapToolProperties::ColorMapping' has a wrong offset!");
static_assert(offsetof(UBakeCurvatureMapToolProperties, ColorRangeMultiplier) == 0x0000B0, "Member 'UBakeCurvatureMapToolProperties::ColorRangeMultiplier' has a wrong offset!");
static_assert(offsetof(UBakeCurvatureMapToolProperties, MinRangeMultiplier) == 0x0000B4, "Member 'UBakeCurvatureMapToolProperties::MinRangeMultiplier' has a wrong offset!");
static_assert(offsetof(UBakeCurvatureMapToolProperties, Clamping) == 0x0000B8, "Member 'UBakeCurvatureMapToolProperties::Clamping' has a wrong offset!");

// Class MeshModelingToolsExp.BakeTexture2DProperties
// 0x0028 (0x00D0 - 0x00A8)
class UBakeTexture2DProperties final : public UInteractiveToolPropertySet
{
public:
	class UTexture2D*                             SourceTexture;                                     // 0x00A8(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 UVLayer;                                           // 0x00B0(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         UVLayerNamesList;                                  // 0x00C0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)

public:
	const TArray<class FString> GetUVLayerNamesFunc() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BakeTexture2DProperties">();
	}
	static class UBakeTexture2DProperties* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBakeTexture2DProperties>();
	}
};
static_assert(alignof(UBakeTexture2DProperties) == 0x000008, "Wrong alignment on UBakeTexture2DProperties");
static_assert(sizeof(UBakeTexture2DProperties) == 0x0000D0, "Wrong size on UBakeTexture2DProperties");
static_assert(offsetof(UBakeTexture2DProperties, SourceTexture) == 0x0000A8, "Member 'UBakeTexture2DProperties::SourceTexture' has a wrong offset!");
static_assert(offsetof(UBakeTexture2DProperties, UVLayer) == 0x0000B0, "Member 'UBakeTexture2DProperties::UVLayer' has a wrong offset!");
static_assert(offsetof(UBakeTexture2DProperties, UVLayerNamesList) == 0x0000C0, "Member 'UBakeTexture2DProperties::UVLayerNamesList' has a wrong offset!");

// Class MeshModelingToolsExp.SmoothHoleFillProperties
// 0x0028 (0x00D0 - 0x00A8)
class USmoothHoleFillProperties final : public UInteractiveToolPropertySet
{
public:
	bool                                          bConstrainToHoleInterior;                          // 0x00A8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A9[0x3];                                       // 0x00A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         RemeshingExteriorRegionWidth;                      // 0x00AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SmoothingExteriorRegionWidth;                      // 0x00B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SmoothingInteriorRegionWidth;                      // 0x00B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InteriorSmoothness;                                // 0x00B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BC[0x4];                                       // 0x00BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        FillDensityScalar;                                 // 0x00C0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bProjectDuringRemesh;                              // 0x00C8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C9[0x7];                                       // 0x00C9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SmoothHoleFillProperties">();
	}
	static class USmoothHoleFillProperties* GetDefaultObj()
	{
		return GetDefaultObjImpl<USmoothHoleFillProperties>();
	}
};
static_assert(alignof(USmoothHoleFillProperties) == 0x000008, "Wrong alignment on USmoothHoleFillProperties");
static_assert(sizeof(USmoothHoleFillProperties) == 0x0000D0, "Wrong size on USmoothHoleFillProperties");
static_assert(offsetof(USmoothHoleFillProperties, bConstrainToHoleInterior) == 0x0000A8, "Member 'USmoothHoleFillProperties::bConstrainToHoleInterior' has a wrong offset!");
static_assert(offsetof(USmoothHoleFillProperties, RemeshingExteriorRegionWidth) == 0x0000AC, "Member 'USmoothHoleFillProperties::RemeshingExteriorRegionWidth' has a wrong offset!");
static_assert(offsetof(USmoothHoleFillProperties, SmoothingExteriorRegionWidth) == 0x0000B0, "Member 'USmoothHoleFillProperties::SmoothingExteriorRegionWidth' has a wrong offset!");
static_assert(offsetof(USmoothHoleFillProperties, SmoothingInteriorRegionWidth) == 0x0000B4, "Member 'USmoothHoleFillProperties::SmoothingInteriorRegionWidth' has a wrong offset!");
static_assert(offsetof(USmoothHoleFillProperties, InteriorSmoothness) == 0x0000B8, "Member 'USmoothHoleFillProperties::InteriorSmoothness' has a wrong offset!");
static_assert(offsetof(USmoothHoleFillProperties, FillDensityScalar) == 0x0000C0, "Member 'USmoothHoleFillProperties::FillDensityScalar' has a wrong offset!");
static_assert(offsetof(USmoothHoleFillProperties, bProjectDuringRemesh) == 0x0000C8, "Member 'USmoothHoleFillProperties::bProjectDuringRemesh' has a wrong offset!");

// Class MeshModelingToolsExp.BakeMultiTexture2DProperties
// 0x0040 (0x00E8 - 0x00A8)
class UBakeMultiTexture2DProperties final : public UInteractiveToolPropertySet
{
public:
	TArray<class UTexture2D*>                     MaterialIDSourceTextures;                          // 0x00A8(0x0010)(Edit, EditFixedSize, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	class FString                                 UVLayer;                                           // 0x00B8(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         UVLayerNamesList;                                  // 0x00C8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UTexture2D*>                     AllSourceTextures;                                 // 0x00D8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	const TArray<class FString> GetUVLayerNamesFunc() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BakeMultiTexture2DProperties">();
	}
	static class UBakeMultiTexture2DProperties* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBakeMultiTexture2DProperties>();
	}
};
static_assert(alignof(UBakeMultiTexture2DProperties) == 0x000008, "Wrong alignment on UBakeMultiTexture2DProperties");
static_assert(sizeof(UBakeMultiTexture2DProperties) == 0x0000E8, "Wrong size on UBakeMultiTexture2DProperties");
static_assert(offsetof(UBakeMultiTexture2DProperties, MaterialIDSourceTextures) == 0x0000A8, "Member 'UBakeMultiTexture2DProperties::MaterialIDSourceTextures' has a wrong offset!");
static_assert(offsetof(UBakeMultiTexture2DProperties, UVLayer) == 0x0000B8, "Member 'UBakeMultiTexture2DProperties::UVLayer' has a wrong offset!");
static_assert(offsetof(UBakeMultiTexture2DProperties, UVLayerNamesList) == 0x0000C8, "Member 'UBakeMultiTexture2DProperties::UVLayerNamesList' has a wrong offset!");
static_assert(offsetof(UBakeMultiTexture2DProperties, AllSourceTextures) == 0x0000D8, "Member 'UBakeMultiTexture2DProperties::AllSourceTextures' has a wrong offset!");

// Class MeshModelingToolsExp.BakeVisualizationProperties
// 0x0010 (0x00B8 - 0x00A8)
class UBakeVisualizationProperties final : public UInteractiveToolPropertySet
{
public:
	bool                                          bPreviewAsMaterial;                                // 0x00A8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A9[0x3];                                       // 0x00A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Brightness;                                        // 0x00AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AOMultiplier;                                      // 0x00B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B4[0x4];                                       // 0x00B4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BakeVisualizationProperties">();
	}
	static class UBakeVisualizationProperties* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBakeVisualizationProperties>();
	}
};
static_assert(alignof(UBakeVisualizationProperties) == 0x000008, "Wrong alignment on UBakeVisualizationProperties");
static_assert(sizeof(UBakeVisualizationProperties) == 0x0000B8, "Wrong size on UBakeVisualizationProperties");
static_assert(offsetof(UBakeVisualizationProperties, bPreviewAsMaterial) == 0x0000A8, "Member 'UBakeVisualizationProperties::bPreviewAsMaterial' has a wrong offset!");
static_assert(offsetof(UBakeVisualizationProperties, Brightness) == 0x0000AC, "Member 'UBakeVisualizationProperties::Brightness' has a wrong offset!");
static_assert(offsetof(UBakeVisualizationProperties, AOMultiplier) == 0x0000B0, "Member 'UBakeVisualizationProperties::AOMultiplier' has a wrong offset!");

// Class MeshModelingToolsExp.EditPivotToolProperties
// 0x0008 (0x00B0 - 0x00A8)
class UEditPivotToolProperties final : public UInteractiveToolPropertySet
{
public:
	bool                                          bApplyToAllLODs;                                   // 0x00A8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableSnapDragging;                               // 0x00A9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEditPivotSnapDragRotationMode                RotationMode;                                      // 0x00AA(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AB[0x5];                                       // 0x00AB(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EditPivotToolProperties">();
	}
	static class UEditPivotToolProperties* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEditPivotToolProperties>();
	}
};
static_assert(alignof(UEditPivotToolProperties) == 0x000008, "Wrong alignment on UEditPivotToolProperties");
static_assert(sizeof(UEditPivotToolProperties) == 0x0000B0, "Wrong size on UEditPivotToolProperties");
static_assert(offsetof(UEditPivotToolProperties, bApplyToAllLODs) == 0x0000A8, "Member 'UEditPivotToolProperties::bApplyToAllLODs' has a wrong offset!");
static_assert(offsetof(UEditPivotToolProperties, bEnableSnapDragging) == 0x0000A9, "Member 'UEditPivotToolProperties::bEnableSnapDragging' has a wrong offset!");
static_assert(offsetof(UEditPivotToolProperties, RotationMode) == 0x0000AA, "Member 'UEditPivotToolProperties::RotationMode' has a wrong offset!");

// Class MeshModelingToolsExp.ExtrudeMeshSelectionToolBuilder
// 0x0000 (0x0028 - 0x0028)
class UExtrudeMeshSelectionToolBuilder final : public USingleTargetWithSelectionToolBuilder
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ExtrudeMeshSelectionToolBuilder">();
	}
	static class UExtrudeMeshSelectionToolBuilder* GetDefaultObj()
	{
		return GetDefaultObjImpl<UExtrudeMeshSelectionToolBuilder>();
	}
};
static_assert(alignof(UExtrudeMeshSelectionToolBuilder) == 0x000008, "Wrong alignment on UExtrudeMeshSelectionToolBuilder");
static_assert(sizeof(UExtrudeMeshSelectionToolBuilder) == 0x000028, "Wrong size on UExtrudeMeshSelectionToolBuilder");

// Class MeshModelingToolsExp.ExtrudeMeshSelectionToolProperties
// 0x0048 (0x00F0 - 0x00A8)
class UExtrudeMeshSelectionToolProperties final : public UInteractiveToolPropertySet
{
public:
	EExtrudeMeshSelectionInteractionMode          InputMode;                                         // 0x00A8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A9[0x7];                                       // 0x00A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        ExtrudeDistance;                                   // 0x00B0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EExtrudeMeshSelectionRegionModifierMode       RegionMode;                                        // 0x00B8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B9[0x3];                                       // 0x00B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NumSubdivisions;                                   // 0x00BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        CreaseAngle;                                       // 0x00C0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        RaycastMaxDistance;                                // 0x00C8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShellsToSolids;                                   // 0x00D0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInferGroupsFromNbrs;                              // 0x00D1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bGroupPerSubdivision;                              // 0x00D2(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bReplaceSelectionGroups;                           // 0x00D3(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D4[0x4];                                       // 0x00D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        UVScale;                                           // 0x00D8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUVIslandPerGroup;                                 // 0x00E0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInferMaterialID;                                  // 0x00E1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E2[0x2];                                       // 0x00E2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SetMaterialID;                                     // 0x00E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowInputMaterials;                               // 0x00E8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E9[0x7];                                       // 0x00E9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ExtrudeMeshSelectionToolProperties">();
	}
	static class UExtrudeMeshSelectionToolProperties* GetDefaultObj()
	{
		return GetDefaultObjImpl<UExtrudeMeshSelectionToolProperties>();
	}
};
static_assert(alignof(UExtrudeMeshSelectionToolProperties) == 0x000008, "Wrong alignment on UExtrudeMeshSelectionToolProperties");
static_assert(sizeof(UExtrudeMeshSelectionToolProperties) == 0x0000F0, "Wrong size on UExtrudeMeshSelectionToolProperties");
static_assert(offsetof(UExtrudeMeshSelectionToolProperties, InputMode) == 0x0000A8, "Member 'UExtrudeMeshSelectionToolProperties::InputMode' has a wrong offset!");
static_assert(offsetof(UExtrudeMeshSelectionToolProperties, ExtrudeDistance) == 0x0000B0, "Member 'UExtrudeMeshSelectionToolProperties::ExtrudeDistance' has a wrong offset!");
static_assert(offsetof(UExtrudeMeshSelectionToolProperties, RegionMode) == 0x0000B8, "Member 'UExtrudeMeshSelectionToolProperties::RegionMode' has a wrong offset!");
static_assert(offsetof(UExtrudeMeshSelectionToolProperties, NumSubdivisions) == 0x0000BC, "Member 'UExtrudeMeshSelectionToolProperties::NumSubdivisions' has a wrong offset!");
static_assert(offsetof(UExtrudeMeshSelectionToolProperties, CreaseAngle) == 0x0000C0, "Member 'UExtrudeMeshSelectionToolProperties::CreaseAngle' has a wrong offset!");
static_assert(offsetof(UExtrudeMeshSelectionToolProperties, RaycastMaxDistance) == 0x0000C8, "Member 'UExtrudeMeshSelectionToolProperties::RaycastMaxDistance' has a wrong offset!");
static_assert(offsetof(UExtrudeMeshSelectionToolProperties, bShellsToSolids) == 0x0000D0, "Member 'UExtrudeMeshSelectionToolProperties::bShellsToSolids' has a wrong offset!");
static_assert(offsetof(UExtrudeMeshSelectionToolProperties, bInferGroupsFromNbrs) == 0x0000D1, "Member 'UExtrudeMeshSelectionToolProperties::bInferGroupsFromNbrs' has a wrong offset!");
static_assert(offsetof(UExtrudeMeshSelectionToolProperties, bGroupPerSubdivision) == 0x0000D2, "Member 'UExtrudeMeshSelectionToolProperties::bGroupPerSubdivision' has a wrong offset!");
static_assert(offsetof(UExtrudeMeshSelectionToolProperties, bReplaceSelectionGroups) == 0x0000D3, "Member 'UExtrudeMeshSelectionToolProperties::bReplaceSelectionGroups' has a wrong offset!");
static_assert(offsetof(UExtrudeMeshSelectionToolProperties, UVScale) == 0x0000D8, "Member 'UExtrudeMeshSelectionToolProperties::UVScale' has a wrong offset!");
static_assert(offsetof(UExtrudeMeshSelectionToolProperties, bUVIslandPerGroup) == 0x0000E0, "Member 'UExtrudeMeshSelectionToolProperties::bUVIslandPerGroup' has a wrong offset!");
static_assert(offsetof(UExtrudeMeshSelectionToolProperties, bInferMaterialID) == 0x0000E1, "Member 'UExtrudeMeshSelectionToolProperties::bInferMaterialID' has a wrong offset!");
static_assert(offsetof(UExtrudeMeshSelectionToolProperties, SetMaterialID) == 0x0000E4, "Member 'UExtrudeMeshSelectionToolProperties::SetMaterialID' has a wrong offset!");
static_assert(offsetof(UExtrudeMeshSelectionToolProperties, bShowInputMaterials) == 0x0000E8, "Member 'UExtrudeMeshSelectionToolProperties::bShowInputMaterials' has a wrong offset!");

// Class MeshModelingToolsExp.SetCollisionGeometryToolProperties
// 0x0068 (0x0110 - 0x00A8)
class USetCollisionGeometryToolProperties final : public UInteractiveToolPropertySet
{
public:
	ECollisionGeometryType                        GeometryType;                                      // 0x00A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAppendToExisting;                                 // 0x00AC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseWorldSpace;                                    // 0x00AD(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AE[0x2];                                       // 0x00AE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	ESetCollisionGeometryInputMode                InputMode;                                         // 0x00B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRemoveContained;                                  // 0x00B4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableMaxCount;                                   // 0x00B5(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B6[0x2];                                       // 0x00B6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxCount;                                          // 0x00B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinThickness;                                      // 0x00BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDetectBoxes;                                      // 0x00C0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDetectSpheres;                                    // 0x00C1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDetectCapsules;                                   // 0x00C2(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMergeCollisionShapes;                             // 0x00C3(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MergeAboveCount;                                   // 0x00C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseNegativeSpaceInMerge;                          // 0x00C8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSimplifyHulls;                                    // 0x00C9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CA[0x2];                                       // 0x00CA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         HullTargetFaceCount;                               // 0x00CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxHullsPerMesh;                                   // 0x00D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ConvexDecompositionSearchFactor;                   // 0x00D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AddHullsErrorTolerance;                            // 0x00D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinPartThickness;                                  // 0x00DC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseNegativeSpaceInDecomposition;                  // 0x00E0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E1[0x7];                                       // 0x00E1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        NegativeSpaceTolerance;                            // 0x00E8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        NegativeSpaceMinRadius;                            // 0x00F0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreInternalNegativeSpace;                      // 0x00F8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F9[0x3];                                       // 0x00F9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HullTolerance;                                     // 0x00FC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EProjectedHullAxis                            SweepAxis;                                         // 0x0100(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LevelSetResolution;                                // 0x0104(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionGeometryMode                        SetCollisionType;                                  // 0x0108(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowTargetMesh;                                   // 0x010C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUsingMultipleInputs;                              // 0x010D(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10E[0x2];                                      // 0x010E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SetCollisionGeometryToolProperties">();
	}
	static class USetCollisionGeometryToolProperties* GetDefaultObj()
	{
		return GetDefaultObjImpl<USetCollisionGeometryToolProperties>();
	}
};
static_assert(alignof(USetCollisionGeometryToolProperties) == 0x000008, "Wrong alignment on USetCollisionGeometryToolProperties");
static_assert(sizeof(USetCollisionGeometryToolProperties) == 0x000110, "Wrong size on USetCollisionGeometryToolProperties");
static_assert(offsetof(USetCollisionGeometryToolProperties, GeometryType) == 0x0000A8, "Member 'USetCollisionGeometryToolProperties::GeometryType' has a wrong offset!");
static_assert(offsetof(USetCollisionGeometryToolProperties, bAppendToExisting) == 0x0000AC, "Member 'USetCollisionGeometryToolProperties::bAppendToExisting' has a wrong offset!");
static_assert(offsetof(USetCollisionGeometryToolProperties, bUseWorldSpace) == 0x0000AD, "Member 'USetCollisionGeometryToolProperties::bUseWorldSpace' has a wrong offset!");
static_assert(offsetof(USetCollisionGeometryToolProperties, InputMode) == 0x0000B0, "Member 'USetCollisionGeometryToolProperties::InputMode' has a wrong offset!");
static_assert(offsetof(USetCollisionGeometryToolProperties, bRemoveContained) == 0x0000B4, "Member 'USetCollisionGeometryToolProperties::bRemoveContained' has a wrong offset!");
static_assert(offsetof(USetCollisionGeometryToolProperties, bEnableMaxCount) == 0x0000B5, "Member 'USetCollisionGeometryToolProperties::bEnableMaxCount' has a wrong offset!");
static_assert(offsetof(USetCollisionGeometryToolProperties, MaxCount) == 0x0000B8, "Member 'USetCollisionGeometryToolProperties::MaxCount' has a wrong offset!");
static_assert(offsetof(USetCollisionGeometryToolProperties, MinThickness) == 0x0000BC, "Member 'USetCollisionGeometryToolProperties::MinThickness' has a wrong offset!");
static_assert(offsetof(USetCollisionGeometryToolProperties, bDetectBoxes) == 0x0000C0, "Member 'USetCollisionGeometryToolProperties::bDetectBoxes' has a wrong offset!");
static_assert(offsetof(USetCollisionGeometryToolProperties, bDetectSpheres) == 0x0000C1, "Member 'USetCollisionGeometryToolProperties::bDetectSpheres' has a wrong offset!");
static_assert(offsetof(USetCollisionGeometryToolProperties, bDetectCapsules) == 0x0000C2, "Member 'USetCollisionGeometryToolProperties::bDetectCapsules' has a wrong offset!");
static_assert(offsetof(USetCollisionGeometryToolProperties, bMergeCollisionShapes) == 0x0000C3, "Member 'USetCollisionGeometryToolProperties::bMergeCollisionShapes' has a wrong offset!");
static_assert(offsetof(USetCollisionGeometryToolProperties, MergeAboveCount) == 0x0000C4, "Member 'USetCollisionGeometryToolProperties::MergeAboveCount' has a wrong offset!");
static_assert(offsetof(USetCollisionGeometryToolProperties, bUseNegativeSpaceInMerge) == 0x0000C8, "Member 'USetCollisionGeometryToolProperties::bUseNegativeSpaceInMerge' has a wrong offset!");
static_assert(offsetof(USetCollisionGeometryToolProperties, bSimplifyHulls) == 0x0000C9, "Member 'USetCollisionGeometryToolProperties::bSimplifyHulls' has a wrong offset!");
static_assert(offsetof(USetCollisionGeometryToolProperties, HullTargetFaceCount) == 0x0000CC, "Member 'USetCollisionGeometryToolProperties::HullTargetFaceCount' has a wrong offset!");
static_assert(offsetof(USetCollisionGeometryToolProperties, MaxHullsPerMesh) == 0x0000D0, "Member 'USetCollisionGeometryToolProperties::MaxHullsPerMesh' has a wrong offset!");
static_assert(offsetof(USetCollisionGeometryToolProperties, ConvexDecompositionSearchFactor) == 0x0000D4, "Member 'USetCollisionGeometryToolProperties::ConvexDecompositionSearchFactor' has a wrong offset!");
static_assert(offsetof(USetCollisionGeometryToolProperties, AddHullsErrorTolerance) == 0x0000D8, "Member 'USetCollisionGeometryToolProperties::AddHullsErrorTolerance' has a wrong offset!");
static_assert(offsetof(USetCollisionGeometryToolProperties, MinPartThickness) == 0x0000DC, "Member 'USetCollisionGeometryToolProperties::MinPartThickness' has a wrong offset!");
static_assert(offsetof(USetCollisionGeometryToolProperties, bUseNegativeSpaceInDecomposition) == 0x0000E0, "Member 'USetCollisionGeometryToolProperties::bUseNegativeSpaceInDecomposition' has a wrong offset!");
static_assert(offsetof(USetCollisionGeometryToolProperties, NegativeSpaceTolerance) == 0x0000E8, "Member 'USetCollisionGeometryToolProperties::NegativeSpaceTolerance' has a wrong offset!");
static_assert(offsetof(USetCollisionGeometryToolProperties, NegativeSpaceMinRadius) == 0x0000F0, "Member 'USetCollisionGeometryToolProperties::NegativeSpaceMinRadius' has a wrong offset!");
static_assert(offsetof(USetCollisionGeometryToolProperties, bIgnoreInternalNegativeSpace) == 0x0000F8, "Member 'USetCollisionGeometryToolProperties::bIgnoreInternalNegativeSpace' has a wrong offset!");
static_assert(offsetof(USetCollisionGeometryToolProperties, HullTolerance) == 0x0000FC, "Member 'USetCollisionGeometryToolProperties::HullTolerance' has a wrong offset!");
static_assert(offsetof(USetCollisionGeometryToolProperties, SweepAxis) == 0x000100, "Member 'USetCollisionGeometryToolProperties::SweepAxis' has a wrong offset!");
static_assert(offsetof(USetCollisionGeometryToolProperties, LevelSetResolution) == 0x000104, "Member 'USetCollisionGeometryToolProperties::LevelSetResolution' has a wrong offset!");
static_assert(offsetof(USetCollisionGeometryToolProperties, SetCollisionType) == 0x000108, "Member 'USetCollisionGeometryToolProperties::SetCollisionType' has a wrong offset!");
static_assert(offsetof(USetCollisionGeometryToolProperties, bShowTargetMesh) == 0x00010C, "Member 'USetCollisionGeometryToolProperties::bShowTargetMesh' has a wrong offset!");
static_assert(offsetof(USetCollisionGeometryToolProperties, bUsingMultipleInputs) == 0x00010D, "Member 'USetCollisionGeometryToolProperties::bUsingMultipleInputs' has a wrong offset!");

// Class MeshModelingToolsExp.ExtrudeMeshSelectionTool
// 0x0748 (0x0868 - 0x0120)
class UExtrudeMeshSelectionTool final : public USingleTargetWithSelectionTool
{
public:
	class UExtrudeMeshSelectionToolProperties*    ExtrudeProperties;                                 // 0x0120(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_128[0x720];                                    // 0x0128(0x0720)(Fixing Size After Last Property [ Dumper-7 ])
	class UPreviewMesh*                           SourcePreview;                                     // 0x0848(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMeshOpPreviewWithBackgroundCompute*    EditCompute;                                       // 0x0850(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCombinedTransformGizmo*                TransformGizmo;                                    // 0x0858(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTransformProxy*                        TransformProxy;                                    // 0x0860(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ExtrudeMeshSelectionTool">();
	}
	static class UExtrudeMeshSelectionTool* GetDefaultObj()
	{
		return GetDefaultObjImpl<UExtrudeMeshSelectionTool>();
	}
};
static_assert(alignof(UExtrudeMeshSelectionTool) == 0x000008, "Wrong alignment on UExtrudeMeshSelectionTool");
static_assert(sizeof(UExtrudeMeshSelectionTool) == 0x000868, "Wrong size on UExtrudeMeshSelectionTool");
static_assert(offsetof(UExtrudeMeshSelectionTool, ExtrudeProperties) == 0x000120, "Member 'UExtrudeMeshSelectionTool::ExtrudeProperties' has a wrong offset!");
static_assert(offsetof(UExtrudeMeshSelectionTool, SourcePreview) == 0x000848, "Member 'UExtrudeMeshSelectionTool::SourcePreview' has a wrong offset!");
static_assert(offsetof(UExtrudeMeshSelectionTool, EditCompute) == 0x000850, "Member 'UExtrudeMeshSelectionTool::EditCompute' has a wrong offset!");
static_assert(offsetof(UExtrudeMeshSelectionTool, TransformGizmo) == 0x000858, "Member 'UExtrudeMeshSelectionTool::TransformGizmo' has a wrong offset!");
static_assert(offsetof(UExtrudeMeshSelectionTool, TransformProxy) == 0x000860, "Member 'UExtrudeMeshSelectionTool::TransformProxy' has a wrong offset!");

// Class MeshModelingToolsExp.MeshSculptBrushOpProps
// 0x0000 (0x00A8 - 0x00A8)
class UMeshSculptBrushOpProps : public UInteractiveToolPropertySet
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MeshSculptBrushOpProps">();
	}
	static class UMeshSculptBrushOpProps* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMeshSculptBrushOpProps>();
	}
};
static_assert(alignof(UMeshSculptBrushOpProps) == 0x000008, "Wrong alignment on UMeshSculptBrushOpProps");
static_assert(sizeof(UMeshSculptBrushOpProps) == 0x0000A8, "Wrong size on UMeshSculptBrushOpProps");

// Class MeshModelingToolsExp.DynamicMeshBrushTool
// 0x0048 (0x02E0 - 0x0298)
class UDynamicMeshBrushTool : public UBaseBrushTool
{
public:
	class UPreviewMesh*                           PreviewMesh;                                       // 0x0298(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A0[0x40];                                     // 0x02A0(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DynamicMeshBrushTool">();
	}
	static class UDynamicMeshBrushTool* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDynamicMeshBrushTool>();
	}
};
static_assert(alignof(UDynamicMeshBrushTool) == 0x000008, "Wrong alignment on UDynamicMeshBrushTool");
static_assert(sizeof(UDynamicMeshBrushTool) == 0x0002E0, "Wrong size on UDynamicMeshBrushTool");
static_assert(offsetof(UDynamicMeshBrushTool, PreviewMesh) == 0x000298, "Member 'UDynamicMeshBrushTool::PreviewMesh' has a wrong offset!");

// Class MeshModelingToolsExp.MeshAttributePaintTool
// 0x0520 (0x0800 - 0x02E0)
class alignas(0x10) UMeshAttributePaintTool final : public UDynamicMeshBrushTool
{
public:
	uint8                                         Pad_2E0[0x8];                                      // 0x02E0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UMeshAttributePaintBrushOperationProperties* BrushActionProps;                                  // 0x02E8(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMeshAttributePaintToolProperties*      AttribProps;                                       // 0x02F0(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F8[0x508];                                    // 0x02F8(0x0508)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MeshAttributePaintTool">();
	}
	static class UMeshAttributePaintTool* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMeshAttributePaintTool>();
	}
};
static_assert(alignof(UMeshAttributePaintTool) == 0x000010, "Wrong alignment on UMeshAttributePaintTool");
static_assert(sizeof(UMeshAttributePaintTool) == 0x000800, "Wrong size on UMeshAttributePaintTool");
static_assert(offsetof(UMeshAttributePaintTool, BrushActionProps) == 0x0002E8, "Member 'UMeshAttributePaintTool::BrushActionProps' has a wrong offset!");
static_assert(offsetof(UMeshAttributePaintTool, AttribProps) == 0x0002F0, "Member 'UMeshAttributePaintTool::AttribProps' has a wrong offset!");

// Class MeshModelingToolsExp.BaseKelvinletBrushOpProps
// 0x0010 (0x00B8 - 0x00A8)
class UBaseKelvinletBrushOpProps : public UMeshSculptBrushOpProps
{
public:
	float                                         Stiffness;                                         // 0x00A8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Incompressiblity;                                  // 0x00AC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BrushSteps;                                        // 0x00B0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B4[0x4];                                       // 0x00B4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseKelvinletBrushOpProps">();
	}
	static class UBaseKelvinletBrushOpProps* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBaseKelvinletBrushOpProps>();
	}
};
static_assert(alignof(UBaseKelvinletBrushOpProps) == 0x000008, "Wrong alignment on UBaseKelvinletBrushOpProps");
static_assert(sizeof(UBaseKelvinletBrushOpProps) == 0x0000B8, "Wrong size on UBaseKelvinletBrushOpProps");
static_assert(offsetof(UBaseKelvinletBrushOpProps, Stiffness) == 0x0000A8, "Member 'UBaseKelvinletBrushOpProps::Stiffness' has a wrong offset!");
static_assert(offsetof(UBaseKelvinletBrushOpProps, Incompressiblity) == 0x0000AC, "Member 'UBaseKelvinletBrushOpProps::Incompressiblity' has a wrong offset!");
static_assert(offsetof(UBaseKelvinletBrushOpProps, BrushSteps) == 0x0000B0, "Member 'UBaseKelvinletBrushOpProps::BrushSteps' has a wrong offset!");

// Class MeshModelingToolsExp.ScaleKelvinletBrushOpProps
// 0x0008 (0x00C0 - 0x00B8)
class UScaleKelvinletBrushOpProps final : public UBaseKelvinletBrushOpProps
{
public:
	float                                         Strength;                                          // 0x00B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Falloff;                                           // 0x00BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ScaleKelvinletBrushOpProps">();
	}
	static class UScaleKelvinletBrushOpProps* GetDefaultObj()
	{
		return GetDefaultObjImpl<UScaleKelvinletBrushOpProps>();
	}
};
static_assert(alignof(UScaleKelvinletBrushOpProps) == 0x000008, "Wrong alignment on UScaleKelvinletBrushOpProps");
static_assert(sizeof(UScaleKelvinletBrushOpProps) == 0x0000C0, "Wrong size on UScaleKelvinletBrushOpProps");
static_assert(offsetof(UScaleKelvinletBrushOpProps, Strength) == 0x0000B8, "Member 'UScaleKelvinletBrushOpProps::Strength' has a wrong offset!");
static_assert(offsetof(UScaleKelvinletBrushOpProps, Falloff) == 0x0000BC, "Member 'UScaleKelvinletBrushOpProps::Falloff' has a wrong offset!");

// Class MeshModelingToolsExp.SimpleCollisionEditorTool
// 0x0030 (0x00E0 - 0x00B0)
class USimpleCollisionEditorTool final : public USingleSelectionMeshEditingTool
{
public:
	uint8                                         Pad_B0[0x8];                                       // 0x00B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USimpleCollisionEditorToolActionProperties* ActionProperties;                                  // 0x00B8(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C0[0x20];                                      // 0x00C0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SimpleCollisionEditorTool">();
	}
	static class USimpleCollisionEditorTool* GetDefaultObj()
	{
		return GetDefaultObjImpl<USimpleCollisionEditorTool>();
	}
};
static_assert(alignof(USimpleCollisionEditorTool) == 0x000008, "Wrong alignment on USimpleCollisionEditorTool");
static_assert(sizeof(USimpleCollisionEditorTool) == 0x0000E0, "Wrong size on USimpleCollisionEditorTool");
static_assert(offsetof(USimpleCollisionEditorTool, ActionProperties) == 0x0000B8, "Member 'USimpleCollisionEditorTool::ActionProperties' has a wrong offset!");

// Class MeshModelingToolsExp.PullKelvinletBrushOpProps
// 0x0008 (0x00C0 - 0x00B8)
class UPullKelvinletBrushOpProps final : public UBaseKelvinletBrushOpProps
{
public:
	float                                         Falloff;                                           // 0x00B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Depth;                                             // 0x00BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PullKelvinletBrushOpProps">();
	}
	static class UPullKelvinletBrushOpProps* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPullKelvinletBrushOpProps>();
	}
};
static_assert(alignof(UPullKelvinletBrushOpProps) == 0x000008, "Wrong alignment on UPullKelvinletBrushOpProps");
static_assert(sizeof(UPullKelvinletBrushOpProps) == 0x0000C0, "Wrong size on UPullKelvinletBrushOpProps");
static_assert(offsetof(UPullKelvinletBrushOpProps, Falloff) == 0x0000B8, "Member 'UPullKelvinletBrushOpProps::Falloff' has a wrong offset!");
static_assert(offsetof(UPullKelvinletBrushOpProps, Depth) == 0x0000BC, "Member 'UPullKelvinletBrushOpProps::Depth' has a wrong offset!");

// Class MeshModelingToolsExp.SharpPullKelvinletBrushOpProps
// 0x0008 (0x00C0 - 0x00B8)
class USharpPullKelvinletBrushOpProps final : public UBaseKelvinletBrushOpProps
{
public:
	float                                         Falloff;                                           // 0x00B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Depth;                                             // 0x00BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SharpPullKelvinletBrushOpProps">();
	}
	static class USharpPullKelvinletBrushOpProps* GetDefaultObj()
	{
		return GetDefaultObjImpl<USharpPullKelvinletBrushOpProps>();
	}
};
static_assert(alignof(USharpPullKelvinletBrushOpProps) == 0x000008, "Wrong alignment on USharpPullKelvinletBrushOpProps");
static_assert(sizeof(USharpPullKelvinletBrushOpProps) == 0x0000C0, "Wrong size on USharpPullKelvinletBrushOpProps");
static_assert(offsetof(USharpPullKelvinletBrushOpProps, Falloff) == 0x0000B8, "Member 'USharpPullKelvinletBrushOpProps::Falloff' has a wrong offset!");
static_assert(offsetof(USharpPullKelvinletBrushOpProps, Depth) == 0x0000BC, "Member 'USharpPullKelvinletBrushOpProps::Depth' has a wrong offset!");

// Class MeshModelingToolsExp.PhysicsInspectorTool
// 0x0040 (0x00F8 - 0x00B8)
class UPhysicsInspectorTool final : public UMultiSelectionMeshEditingTool
{
public:
	uint8                                         Pad_B8[0x8];                                       // 0x00B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UCollisionGeometryVisualizationProperties* VizSettings;                                       // 0x00C0(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UPhysicsObjectToolPropertySet*>  ObjectData;                                        // 0x00C8(0x0010)(ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<class UPreviewGeometry*>               PreviewElements;                                   // 0x00D8(0x0010)(ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	uint8                                         Pad_E8[0x10];                                      // 0x00E8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PhysicsInspectorTool">();
	}
	static class UPhysicsInspectorTool* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPhysicsInspectorTool>();
	}
};
static_assert(alignof(UPhysicsInspectorTool) == 0x000008, "Wrong alignment on UPhysicsInspectorTool");
static_assert(sizeof(UPhysicsInspectorTool) == 0x0000F8, "Wrong size on UPhysicsInspectorTool");
static_assert(offsetof(UPhysicsInspectorTool, VizSettings) == 0x0000C0, "Member 'UPhysicsInspectorTool::VizSettings' has a wrong offset!");
static_assert(offsetof(UPhysicsInspectorTool, ObjectData) == 0x0000C8, "Member 'UPhysicsInspectorTool::ObjectData' has a wrong offset!");
static_assert(offsetof(UPhysicsInspectorTool, PreviewElements) == 0x0000D8, "Member 'UPhysicsInspectorTool::PreviewElements' has a wrong offset!");

// Class MeshModelingToolsExp.TwistKelvinletBrushOpProps
// 0x0008 (0x00C0 - 0x00B8)
class UTwistKelvinletBrushOpProps final : public UBaseKelvinletBrushOpProps
{
public:
	float                                         Strength;                                          // 0x00B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Falloff;                                           // 0x00BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TwistKelvinletBrushOpProps">();
	}
	static class UTwistKelvinletBrushOpProps* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTwistKelvinletBrushOpProps>();
	}
};
static_assert(alignof(UTwistKelvinletBrushOpProps) == 0x000008, "Wrong alignment on UTwistKelvinletBrushOpProps");
static_assert(sizeof(UTwistKelvinletBrushOpProps) == 0x0000C0, "Wrong size on UTwistKelvinletBrushOpProps");
static_assert(offsetof(UTwistKelvinletBrushOpProps, Strength) == 0x0000B8, "Member 'UTwistKelvinletBrushOpProps::Strength' has a wrong offset!");
static_assert(offsetof(UTwistKelvinletBrushOpProps, Falloff) == 0x0000BC, "Member 'UTwistKelvinletBrushOpProps::Falloff' has a wrong offset!");

// Class MeshModelingToolsExp.GroupEraseBrushOpProps
// 0x0048 (0x00F0 - 0x00A8)
class UGroupEraseBrushOpProps final : public UMeshSculptBrushOpProps
{
public:
	int32                                         Group;                                             // 0x00A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOnlyEraseCurrent;                                 // 0x00AC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AD[0x43];                                      // 0x00AD(0x0043)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GroupEraseBrushOpProps">();
	}
	static class UGroupEraseBrushOpProps* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGroupEraseBrushOpProps>();
	}
};
static_assert(alignof(UGroupEraseBrushOpProps) == 0x000008, "Wrong alignment on UGroupEraseBrushOpProps");
static_assert(sizeof(UGroupEraseBrushOpProps) == 0x0000F0, "Wrong size on UGroupEraseBrushOpProps");
static_assert(offsetof(UGroupEraseBrushOpProps, Group) == 0x0000A8, "Member 'UGroupEraseBrushOpProps::Group' has a wrong offset!");
static_assert(offsetof(UGroupEraseBrushOpProps, bOnlyEraseCurrent) == 0x0000AC, "Member 'UGroupEraseBrushOpProps::bOnlyEraseCurrent' has a wrong offset!");

// Class MeshModelingToolsExp.MeshAttributePaintToolProperties
// 0x0020 (0x00C8 - 0x00A8)
class UMeshAttributePaintToolProperties final : public UInteractiveToolPropertySet
{
public:
	class FString                                 Attribute;                                         // 0x00A8(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B8[0x10];                                      // 0x00B8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	const TArray<class FString> GetAttributeNames();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MeshAttributePaintToolProperties">();
	}
	static class UMeshAttributePaintToolProperties* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMeshAttributePaintToolProperties>();
	}
};
static_assert(alignof(UMeshAttributePaintToolProperties) == 0x000008, "Wrong alignment on UMeshAttributePaintToolProperties");
static_assert(sizeof(UMeshAttributePaintToolProperties) == 0x0000C8, "Wrong size on UMeshAttributePaintToolProperties");
static_assert(offsetof(UMeshAttributePaintToolProperties, Attribute) == 0x0000A8, "Member 'UMeshAttributePaintToolProperties::Attribute' has a wrong offset!");

// Class MeshModelingToolsExp.GroupPaintBrushOpProps
// 0x0008 (0x00B0 - 0x00A8)
class UGroupPaintBrushOpProps final : public UMeshSculptBrushOpProps
{
public:
	int32                                         Group;                                             // 0x00A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOnlyPaintUngrouped;                               // 0x00AC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AD[0x3];                                       // 0x00AD(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GroupPaintBrushOpProps">();
	}
	static class UGroupPaintBrushOpProps* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGroupPaintBrushOpProps>();
	}
};
static_assert(alignof(UGroupPaintBrushOpProps) == 0x000008, "Wrong alignment on UGroupPaintBrushOpProps");
static_assert(sizeof(UGroupPaintBrushOpProps) == 0x0000B0, "Wrong size on UGroupPaintBrushOpProps");
static_assert(offsetof(UGroupPaintBrushOpProps, Group) == 0x0000A8, "Member 'UGroupPaintBrushOpProps::Group' has a wrong offset!");
static_assert(offsetof(UGroupPaintBrushOpProps, bOnlyPaintUngrouped) == 0x0000AC, "Member 'UGroupPaintBrushOpProps::bOnlyPaintUngrouped' has a wrong offset!");

// Class MeshModelingToolsExp.InflateBrushOpProps
// 0x0008 (0x00B0 - 0x00A8)
class UInflateBrushOpProps final : public UMeshSculptBrushOpProps
{
public:
	float                                         Strength;                                          // 0x00A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Falloff;                                           // 0x00AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InflateBrushOpProps">();
	}
	static class UInflateBrushOpProps* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInflateBrushOpProps>();
	}
};
static_assert(alignof(UInflateBrushOpProps) == 0x000008, "Wrong alignment on UInflateBrushOpProps");
static_assert(sizeof(UInflateBrushOpProps) == 0x0000B0, "Wrong size on UInflateBrushOpProps");
static_assert(offsetof(UInflateBrushOpProps, Strength) == 0x0000A8, "Member 'UInflateBrushOpProps::Strength' has a wrong offset!");
static_assert(offsetof(UInflateBrushOpProps, Falloff) == 0x0000AC, "Member 'UInflateBrushOpProps::Falloff' has a wrong offset!");

// Class MeshModelingToolsExp.MeshInspectorToolBuilder
// 0x0000 (0x0028 - 0x0028)
class UMeshInspectorToolBuilder final : public USingleSelectionMeshEditingToolBuilder
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MeshInspectorToolBuilder">();
	}
	static class UMeshInspectorToolBuilder* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMeshInspectorToolBuilder>();
	}
};
static_assert(alignof(UMeshInspectorToolBuilder) == 0x000008, "Wrong alignment on UMeshInspectorToolBuilder");
static_assert(sizeof(UMeshInspectorToolBuilder) == 0x000028, "Wrong size on UMeshInspectorToolBuilder");

// Class MeshModelingToolsExp.MoveBrushOpProps
// 0x0010 (0x00B8 - 0x00A8)
class UMoveBrushOpProps final : public UMeshSculptBrushOpProps
{
public:
	float                                         Strength;                                          // 0x00A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Falloff;                                           // 0x00AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Depth;                                             // 0x00B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FModelingToolsAxisFilter               AxisFilters;                                       // 0x00B4(0x0003)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_B7[0x1];                                       // 0x00B7(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MoveBrushOpProps">();
	}
	static class UMoveBrushOpProps* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMoveBrushOpProps>();
	}
};
static_assert(alignof(UMoveBrushOpProps) == 0x000008, "Wrong alignment on UMoveBrushOpProps");
static_assert(sizeof(UMoveBrushOpProps) == 0x0000B8, "Wrong size on UMoveBrushOpProps");
static_assert(offsetof(UMoveBrushOpProps, Strength) == 0x0000A8, "Member 'UMoveBrushOpProps::Strength' has a wrong offset!");
static_assert(offsetof(UMoveBrushOpProps, Falloff) == 0x0000AC, "Member 'UMoveBrushOpProps::Falloff' has a wrong offset!");
static_assert(offsetof(UMoveBrushOpProps, Depth) == 0x0000B0, "Member 'UMoveBrushOpProps::Depth' has a wrong offset!");
static_assert(offsetof(UMoveBrushOpProps, AxisFilters) == 0x0000B4, "Member 'UMoveBrushOpProps::AxisFilters' has a wrong offset!");

// Class MeshModelingToolsExp.PinchBrushOpProps
// 0x0010 (0x00B8 - 0x00A8)
class UPinchBrushOpProps final : public UMeshSculptBrushOpProps
{
public:
	float                                         Strength;                                          // 0x00A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Falloff;                                           // 0x00AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Depth;                                             // 0x00B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPerpDamping;                                      // 0x00B4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B5[0x3];                                       // 0x00B5(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PinchBrushOpProps">();
	}
	static class UPinchBrushOpProps* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPinchBrushOpProps>();
	}
};
static_assert(alignof(UPinchBrushOpProps) == 0x000008, "Wrong alignment on UPinchBrushOpProps");
static_assert(sizeof(UPinchBrushOpProps) == 0x0000B8, "Wrong size on UPinchBrushOpProps");
static_assert(offsetof(UPinchBrushOpProps, Strength) == 0x0000A8, "Member 'UPinchBrushOpProps::Strength' has a wrong offset!");
static_assert(offsetof(UPinchBrushOpProps, Falloff) == 0x0000AC, "Member 'UPinchBrushOpProps::Falloff' has a wrong offset!");
static_assert(offsetof(UPinchBrushOpProps, Depth) == 0x0000B0, "Member 'UPinchBrushOpProps::Depth' has a wrong offset!");
static_assert(offsetof(UPinchBrushOpProps, bPerpDamping) == 0x0000B4, "Member 'UPinchBrushOpProps::bPerpDamping' has a wrong offset!");

// Class MeshModelingToolsExp.MeshGroupPaintToolBuilder
// 0x0000 (0x0030 - 0x0030)
class UMeshGroupPaintToolBuilder final : public UMeshSurfacePointMeshEditingToolBuilder
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MeshGroupPaintToolBuilder">();
	}
	static class UMeshGroupPaintToolBuilder* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMeshGroupPaintToolBuilder>();
	}
};
static_assert(alignof(UMeshGroupPaintToolBuilder) == 0x000008, "Wrong alignment on UMeshGroupPaintToolBuilder");
static_assert(sizeof(UMeshGroupPaintToolBuilder) == 0x000030, "Wrong size on UMeshGroupPaintToolBuilder");

// Class MeshModelingToolsExp.BasePlaneBrushOpProps
// 0x0000 (0x00A8 - 0x00A8)
class UBasePlaneBrushOpProps : public UMeshSculptBrushOpProps
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BasePlaneBrushOpProps">();
	}
	static class UBasePlaneBrushOpProps* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBasePlaneBrushOpProps>();
	}
};
static_assert(alignof(UBasePlaneBrushOpProps) == 0x000008, "Wrong alignment on UBasePlaneBrushOpProps");
static_assert(sizeof(UBasePlaneBrushOpProps) == 0x0000A8, "Wrong size on UBasePlaneBrushOpProps");

// Class MeshModelingToolsExp.PlaneBrushOpProps
// 0x0010 (0x00B8 - 0x00A8)
class UPlaneBrushOpProps final : public UBasePlaneBrushOpProps
{
public:
	float                                         Strength;                                          // 0x00A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Falloff;                                           // 0x00AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Depth;                                             // 0x00B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlaneBrushSideMode                           WhichSide;                                         // 0x00B4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B5[0x3];                                       // 0x00B5(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlaneBrushOpProps">();
	}
	static class UPlaneBrushOpProps* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlaneBrushOpProps>();
	}
};
static_assert(alignof(UPlaneBrushOpProps) == 0x000008, "Wrong alignment on UPlaneBrushOpProps");
static_assert(sizeof(UPlaneBrushOpProps) == 0x0000B8, "Wrong size on UPlaneBrushOpProps");
static_assert(offsetof(UPlaneBrushOpProps, Strength) == 0x0000A8, "Member 'UPlaneBrushOpProps::Strength' has a wrong offset!");
static_assert(offsetof(UPlaneBrushOpProps, Falloff) == 0x0000AC, "Member 'UPlaneBrushOpProps::Falloff' has a wrong offset!");
static_assert(offsetof(UPlaneBrushOpProps, Depth) == 0x0000B0, "Member 'UPlaneBrushOpProps::Depth' has a wrong offset!");
static_assert(offsetof(UPlaneBrushOpProps, WhichSide) == 0x0000B4, "Member 'UPlaneBrushOpProps::WhichSide' has a wrong offset!");

// Class MeshModelingToolsExp.MeshAttributePaintToolBuilder
// 0x0040 (0x0070 - 0x0030)
class UMeshAttributePaintToolBuilder final : public UMeshSurfacePointMeshEditingToolBuilder
{
public:
	uint8                                         Pad_30[0x40];                                      // 0x0030(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MeshAttributePaintToolBuilder">();
	}
	static class UMeshAttributePaintToolBuilder* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMeshAttributePaintToolBuilder>();
	}
};
static_assert(alignof(UMeshAttributePaintToolBuilder) == 0x000008, "Wrong alignment on UMeshAttributePaintToolBuilder");
static_assert(sizeof(UMeshAttributePaintToolBuilder) == 0x000070, "Wrong size on UMeshAttributePaintToolBuilder");

// Class MeshModelingToolsExp.ViewAlignedPlaneBrushOpProps
// 0x0010 (0x00B8 - 0x00A8)
class UViewAlignedPlaneBrushOpProps final : public UBasePlaneBrushOpProps
{
public:
	float                                         Strength;                                          // 0x00A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Falloff;                                           // 0x00AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Depth;                                             // 0x00B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlaneBrushSideMode                           WhichSide;                                         // 0x00B4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B5[0x3];                                       // 0x00B5(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ViewAlignedPlaneBrushOpProps">();
	}
	static class UViewAlignedPlaneBrushOpProps* GetDefaultObj()
	{
		return GetDefaultObjImpl<UViewAlignedPlaneBrushOpProps>();
	}
};
static_assert(alignof(UViewAlignedPlaneBrushOpProps) == 0x000008, "Wrong alignment on UViewAlignedPlaneBrushOpProps");
static_assert(sizeof(UViewAlignedPlaneBrushOpProps) == 0x0000B8, "Wrong size on UViewAlignedPlaneBrushOpProps");
static_assert(offsetof(UViewAlignedPlaneBrushOpProps, Strength) == 0x0000A8, "Member 'UViewAlignedPlaneBrushOpProps::Strength' has a wrong offset!");
static_assert(offsetof(UViewAlignedPlaneBrushOpProps, Falloff) == 0x0000AC, "Member 'UViewAlignedPlaneBrushOpProps::Falloff' has a wrong offset!");
static_assert(offsetof(UViewAlignedPlaneBrushOpProps, Depth) == 0x0000B0, "Member 'UViewAlignedPlaneBrushOpProps::Depth' has a wrong offset!");
static_assert(offsetof(UViewAlignedPlaneBrushOpProps, WhichSide) == 0x0000B4, "Member 'UViewAlignedPlaneBrushOpProps::WhichSide' has a wrong offset!");

// Class MeshModelingToolsExp.FixedPlaneBrushOpProps
// 0x0010 (0x00B8 - 0x00A8)
class UFixedPlaneBrushOpProps final : public UBasePlaneBrushOpProps
{
public:
	float                                         Strength;                                          // 0x00A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Falloff;                                           // 0x00AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Depth;                                             // 0x00B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlaneBrushSideMode                           WhichSide;                                         // 0x00B4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B5[0x3];                                       // 0x00B5(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FixedPlaneBrushOpProps">();
	}
	static class UFixedPlaneBrushOpProps* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFixedPlaneBrushOpProps>();
	}
};
static_assert(alignof(UFixedPlaneBrushOpProps) == 0x000008, "Wrong alignment on UFixedPlaneBrushOpProps");
static_assert(sizeof(UFixedPlaneBrushOpProps) == 0x0000B8, "Wrong size on UFixedPlaneBrushOpProps");
static_assert(offsetof(UFixedPlaneBrushOpProps, Strength) == 0x0000A8, "Member 'UFixedPlaneBrushOpProps::Strength' has a wrong offset!");
static_assert(offsetof(UFixedPlaneBrushOpProps, Falloff) == 0x0000AC, "Member 'UFixedPlaneBrushOpProps::Falloff' has a wrong offset!");
static_assert(offsetof(UFixedPlaneBrushOpProps, Depth) == 0x0000B0, "Member 'UFixedPlaneBrushOpProps::Depth' has a wrong offset!");
static_assert(offsetof(UFixedPlaneBrushOpProps, WhichSide) == 0x0000B4, "Member 'UFixedPlaneBrushOpProps::WhichSide' has a wrong offset!");

// Class MeshModelingToolsExp.MeshSculptToolBase
// 0x0AA0 (0x0BA0 - 0x0100)
class alignas(0x10) UMeshSculptToolBase : public UMeshSurfacePointTool
{
public:
	class USculptBrushProperties*                 BrushProperties;                                   // 0x0100(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWorkPlaneProperties*                   GizmoProperties;                                   // 0x0108(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_110[0x120];                                    // 0x0110(0x0120)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, class UMeshSculptBrushOpProps*>   BrushOpPropSets;                                   // 0x0230(0x0050)(Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	uint8                                         Pad_280[0x50];                                     // 0x0280(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, class UMeshSculptBrushOpProps*>   SecondaryBrushOpPropSets;                          // 0x02D0(0x0050)(Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	uint8                                         Pad_320[0x6F0];                                    // 0x0320(0x06F0)(Fixing Size After Last Property [ Dumper-7 ])
	class UMeshEditingViewProperties*             ViewProperties;                                    // 0x0A10(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*               ActiveOverrideMaterial;                            // 0x0A18(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBrushStampIndicator*                   BrushIndicator;                                    // 0x0A20(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsVolumetricIndicator;                            // 0x0A28(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A29[0x7];                                      // 0x0A29(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInstanceDynamic*               BrushIndicatorMaterial;                            // 0x0A30(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPreviewMesh*                           BrushIndicatorMesh;                                // 0x0A38(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCombinedTransformGizmo*                PlaneTransformGizmo;                               // 0x0A40(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTransformProxy*                        PlaneTransformProxy;                               // 0x0A48(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A50[0x150];                                    // 0x0A50(0x0150)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MeshSculptToolBase">();
	}
	static class UMeshSculptToolBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMeshSculptToolBase>();
	}
};
static_assert(alignof(UMeshSculptToolBase) == 0x000010, "Wrong alignment on UMeshSculptToolBase");
static_assert(sizeof(UMeshSculptToolBase) == 0x000BA0, "Wrong size on UMeshSculptToolBase");
static_assert(offsetof(UMeshSculptToolBase, BrushProperties) == 0x000100, "Member 'UMeshSculptToolBase::BrushProperties' has a wrong offset!");
static_assert(offsetof(UMeshSculptToolBase, GizmoProperties) == 0x000108, "Member 'UMeshSculptToolBase::GizmoProperties' has a wrong offset!");
static_assert(offsetof(UMeshSculptToolBase, BrushOpPropSets) == 0x000230, "Member 'UMeshSculptToolBase::BrushOpPropSets' has a wrong offset!");
static_assert(offsetof(UMeshSculptToolBase, SecondaryBrushOpPropSets) == 0x0002D0, "Member 'UMeshSculptToolBase::SecondaryBrushOpPropSets' has a wrong offset!");
static_assert(offsetof(UMeshSculptToolBase, ViewProperties) == 0x000A10, "Member 'UMeshSculptToolBase::ViewProperties' has a wrong offset!");
static_assert(offsetof(UMeshSculptToolBase, ActiveOverrideMaterial) == 0x000A18, "Member 'UMeshSculptToolBase::ActiveOverrideMaterial' has a wrong offset!");
static_assert(offsetof(UMeshSculptToolBase, BrushIndicator) == 0x000A20, "Member 'UMeshSculptToolBase::BrushIndicator' has a wrong offset!");
static_assert(offsetof(UMeshSculptToolBase, bIsVolumetricIndicator) == 0x000A28, "Member 'UMeshSculptToolBase::bIsVolumetricIndicator' has a wrong offset!");
static_assert(offsetof(UMeshSculptToolBase, BrushIndicatorMaterial) == 0x000A30, "Member 'UMeshSculptToolBase::BrushIndicatorMaterial' has a wrong offset!");
static_assert(offsetof(UMeshSculptToolBase, BrushIndicatorMesh) == 0x000A38, "Member 'UMeshSculptToolBase::BrushIndicatorMesh' has a wrong offset!");
static_assert(offsetof(UMeshSculptToolBase, PlaneTransformGizmo) == 0x000A40, "Member 'UMeshSculptToolBase::PlaneTransformGizmo' has a wrong offset!");
static_assert(offsetof(UMeshSculptToolBase, PlaneTransformProxy) == 0x000A48, "Member 'UMeshSculptToolBase::PlaneTransformProxy' has a wrong offset!");

// Class MeshModelingToolsExp.StandardSculptBrushOpProps
// 0x0008 (0x00B0 - 0x00A8)
class UStandardSculptBrushOpProps final : public UMeshSculptBrushOpProps
{
public:
	float                                         Strength;                                          // 0x00A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Falloff;                                           // 0x00AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StandardSculptBrushOpProps">();
	}
	static class UStandardSculptBrushOpProps* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStandardSculptBrushOpProps>();
	}
};
static_assert(alignof(UStandardSculptBrushOpProps) == 0x000008, "Wrong alignment on UStandardSculptBrushOpProps");
static_assert(sizeof(UStandardSculptBrushOpProps) == 0x0000B0, "Wrong size on UStandardSculptBrushOpProps");
static_assert(offsetof(UStandardSculptBrushOpProps, Strength) == 0x0000A8, "Member 'UStandardSculptBrushOpProps::Strength' has a wrong offset!");
static_assert(offsetof(UStandardSculptBrushOpProps, Falloff) == 0x0000AC, "Member 'UStandardSculptBrushOpProps::Falloff' has a wrong offset!");

// Class MeshModelingToolsExp.ViewAlignedSculptBrushOpProps
// 0x0008 (0x00B0 - 0x00A8)
class UViewAlignedSculptBrushOpProps final : public UMeshSculptBrushOpProps
{
public:
	float                                         Strength;                                          // 0x00A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Falloff;                                           // 0x00AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ViewAlignedSculptBrushOpProps">();
	}
	static class UViewAlignedSculptBrushOpProps* GetDefaultObj()
	{
		return GetDefaultObjImpl<UViewAlignedSculptBrushOpProps>();
	}
};
static_assert(alignof(UViewAlignedSculptBrushOpProps) == 0x000008, "Wrong alignment on UViewAlignedSculptBrushOpProps");
static_assert(sizeof(UViewAlignedSculptBrushOpProps) == 0x0000B0, "Wrong size on UViewAlignedSculptBrushOpProps");
static_assert(offsetof(UViewAlignedSculptBrushOpProps, Strength) == 0x0000A8, "Member 'UViewAlignedSculptBrushOpProps::Strength' has a wrong offset!");
static_assert(offsetof(UViewAlignedSculptBrushOpProps, Falloff) == 0x0000AC, "Member 'UViewAlignedSculptBrushOpProps::Falloff' has a wrong offset!");

// Class MeshModelingToolsExp.MeshSelectionToolProperties
// 0x0010 (0x00B8 - 0x00A8)
class UMeshSelectionToolProperties final : public UInteractiveToolPropertySet
{
public:
	EMeshSelectionToolPrimaryMode                 SelectionMode;                                     // 0x00A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AngleTolerance;                                    // 0x00AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHitBackFaces;                                     // 0x00B0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowPoints;                                       // 0x00B1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B2[0x2];                                       // 0x00B2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	EMeshFacesColorMode                           FaceColorMode;                                     // 0x00B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MeshSelectionToolProperties">();
	}
	static class UMeshSelectionToolProperties* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMeshSelectionToolProperties>();
	}
};
static_assert(alignof(UMeshSelectionToolProperties) == 0x000008, "Wrong alignment on UMeshSelectionToolProperties");
static_assert(sizeof(UMeshSelectionToolProperties) == 0x0000B8, "Wrong size on UMeshSelectionToolProperties");
static_assert(offsetof(UMeshSelectionToolProperties, SelectionMode) == 0x0000A8, "Member 'UMeshSelectionToolProperties::SelectionMode' has a wrong offset!");
static_assert(offsetof(UMeshSelectionToolProperties, AngleTolerance) == 0x0000AC, "Member 'UMeshSelectionToolProperties::AngleTolerance' has a wrong offset!");
static_assert(offsetof(UMeshSelectionToolProperties, bHitBackFaces) == 0x0000B0, "Member 'UMeshSelectionToolProperties::bHitBackFaces' has a wrong offset!");
static_assert(offsetof(UMeshSelectionToolProperties, bShowPoints) == 0x0000B1, "Member 'UMeshSelectionToolProperties::bShowPoints' has a wrong offset!");
static_assert(offsetof(UMeshSelectionToolProperties, FaceColorMode) == 0x0000B4, "Member 'UMeshSelectionToolProperties::FaceColorMode' has a wrong offset!");

// Class MeshModelingToolsExp.SculptMaxBrushOpProps
// 0x0018 (0x00C0 - 0x00A8)
class USculptMaxBrushOpProps final : public UMeshSculptBrushOpProps
{
public:
	float                                         Strength;                                          // 0x00A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Falloff;                                           // 0x00AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxHeight;                                         // 0x00B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseFixedHeight;                                   // 0x00B4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B5[0x3];                                       // 0x00B5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FixedHeight;                                       // 0x00B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BC[0x4];                                       // 0x00BC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SculptMaxBrushOpProps">();
	}
	static class USculptMaxBrushOpProps* GetDefaultObj()
	{
		return GetDefaultObjImpl<USculptMaxBrushOpProps>();
	}
};
static_assert(alignof(USculptMaxBrushOpProps) == 0x000008, "Wrong alignment on USculptMaxBrushOpProps");
static_assert(sizeof(USculptMaxBrushOpProps) == 0x0000C0, "Wrong size on USculptMaxBrushOpProps");
static_assert(offsetof(USculptMaxBrushOpProps, Strength) == 0x0000A8, "Member 'USculptMaxBrushOpProps::Strength' has a wrong offset!");
static_assert(offsetof(USculptMaxBrushOpProps, Falloff) == 0x0000AC, "Member 'USculptMaxBrushOpProps::Falloff' has a wrong offset!");
static_assert(offsetof(USculptMaxBrushOpProps, MaxHeight) == 0x0000B0, "Member 'USculptMaxBrushOpProps::MaxHeight' has a wrong offset!");
static_assert(offsetof(USculptMaxBrushOpProps, bUseFixedHeight) == 0x0000B4, "Member 'USculptMaxBrushOpProps::bUseFixedHeight' has a wrong offset!");
static_assert(offsetof(USculptMaxBrushOpProps, FixedHeight) == 0x0000B8, "Member 'USculptMaxBrushOpProps::FixedHeight' has a wrong offset!");

// Class MeshModelingToolsExp.BaseSmoothBrushOpProps
// 0x0000 (0x00A8 - 0x00A8)
class UBaseSmoothBrushOpProps : public UMeshSculptBrushOpProps
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseSmoothBrushOpProps">();
	}
	static class UBaseSmoothBrushOpProps* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBaseSmoothBrushOpProps>();
	}
};
static_assert(alignof(UBaseSmoothBrushOpProps) == 0x000008, "Wrong alignment on UBaseSmoothBrushOpProps");
static_assert(sizeof(UBaseSmoothBrushOpProps) == 0x0000A8, "Wrong size on UBaseSmoothBrushOpProps");

// Class MeshModelingToolsExp.MeshInspectorMaterialProperties
// 0x0078 (0x0120 - 0x00A8)
class UMeshInspectorMaterialProperties final : public UInteractiveToolPropertySet
{
public:
	EMeshInspectorMaterialMode                    MaterialMode;                                      // 0x00A8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A9[0x3];                                       // 0x00A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CheckerDensity;                                    // 0x00AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     OverrideMaterial;                                  // 0x00B0(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 UVChannel;                                         // 0x00B8(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         UVChannelNamesList;                                // 0x00C8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bFlatShading;                                      // 0x00D8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D9[0x3];                                       // 0x00D9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           Color;                                             // 0x00DC(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_EC[0x4];                                       // 0x00EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        Opacity;                                           // 0x00F0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           TransparentMaterialColor;                          // 0x00F8(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTwoSided;                                         // 0x0108(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_109[0x7];                                      // 0x0109(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInstanceDynamic*               CheckerMaterial;                                   // 0x0110(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*               ActiveCustomMaterial;                              // 0x0118(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	const TArray<class FString> GetUVChannelNamesFunc() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MeshInspectorMaterialProperties">();
	}
	static class UMeshInspectorMaterialProperties* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMeshInspectorMaterialProperties>();
	}
};
static_assert(alignof(UMeshInspectorMaterialProperties) == 0x000008, "Wrong alignment on UMeshInspectorMaterialProperties");
static_assert(sizeof(UMeshInspectorMaterialProperties) == 0x000120, "Wrong size on UMeshInspectorMaterialProperties");
static_assert(offsetof(UMeshInspectorMaterialProperties, MaterialMode) == 0x0000A8, "Member 'UMeshInspectorMaterialProperties::MaterialMode' has a wrong offset!");
static_assert(offsetof(UMeshInspectorMaterialProperties, CheckerDensity) == 0x0000AC, "Member 'UMeshInspectorMaterialProperties::CheckerDensity' has a wrong offset!");
static_assert(offsetof(UMeshInspectorMaterialProperties, OverrideMaterial) == 0x0000B0, "Member 'UMeshInspectorMaterialProperties::OverrideMaterial' has a wrong offset!");
static_assert(offsetof(UMeshInspectorMaterialProperties, UVChannel) == 0x0000B8, "Member 'UMeshInspectorMaterialProperties::UVChannel' has a wrong offset!");
static_assert(offsetof(UMeshInspectorMaterialProperties, UVChannelNamesList) == 0x0000C8, "Member 'UMeshInspectorMaterialProperties::UVChannelNamesList' has a wrong offset!");
static_assert(offsetof(UMeshInspectorMaterialProperties, bFlatShading) == 0x0000D8, "Member 'UMeshInspectorMaterialProperties::bFlatShading' has a wrong offset!");
static_assert(offsetof(UMeshInspectorMaterialProperties, Color) == 0x0000DC, "Member 'UMeshInspectorMaterialProperties::Color' has a wrong offset!");
static_assert(offsetof(UMeshInspectorMaterialProperties, Opacity) == 0x0000F0, "Member 'UMeshInspectorMaterialProperties::Opacity' has a wrong offset!");
static_assert(offsetof(UMeshInspectorMaterialProperties, TransparentMaterialColor) == 0x0000F8, "Member 'UMeshInspectorMaterialProperties::TransparentMaterialColor' has a wrong offset!");
static_assert(offsetof(UMeshInspectorMaterialProperties, bTwoSided) == 0x000108, "Member 'UMeshInspectorMaterialProperties::bTwoSided' has a wrong offset!");
static_assert(offsetof(UMeshInspectorMaterialProperties, CheckerMaterial) == 0x000110, "Member 'UMeshInspectorMaterialProperties::CheckerMaterial' has a wrong offset!");
static_assert(offsetof(UMeshInspectorMaterialProperties, ActiveCustomMaterial) == 0x000118, "Member 'UMeshInspectorMaterialProperties::ActiveCustomMaterial' has a wrong offset!");

// Class MeshModelingToolsExp.SmoothBrushOpProps
// 0x0010 (0x00B8 - 0x00A8)
class USmoothBrushOpProps final : public UBaseSmoothBrushOpProps
{
public:
	float                                         Strength;                                          // 0x00A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Falloff;                                           // 0x00AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPreserveUVFlow;                                   // 0x00B0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B1[0x7];                                       // 0x00B1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SmoothBrushOpProps">();
	}
	static class USmoothBrushOpProps* GetDefaultObj()
	{
		return GetDefaultObjImpl<USmoothBrushOpProps>();
	}
};
static_assert(alignof(USmoothBrushOpProps) == 0x000008, "Wrong alignment on USmoothBrushOpProps");
static_assert(sizeof(USmoothBrushOpProps) == 0x0000B8, "Wrong size on USmoothBrushOpProps");
static_assert(offsetof(USmoothBrushOpProps, Strength) == 0x0000A8, "Member 'USmoothBrushOpProps::Strength' has a wrong offset!");
static_assert(offsetof(USmoothBrushOpProps, Falloff) == 0x0000AC, "Member 'USmoothBrushOpProps::Falloff' has a wrong offset!");
static_assert(offsetof(USmoothBrushOpProps, bPreserveUVFlow) == 0x0000B0, "Member 'USmoothBrushOpProps::bPreserveUVFlow' has a wrong offset!");

// Class MeshModelingToolsExp.SecondarySmoothBrushOpProps
// 0x0010 (0x00B8 - 0x00A8)
class USecondarySmoothBrushOpProps final : public UBaseSmoothBrushOpProps
{
public:
	float                                         Strength;                                          // 0x00A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Falloff;                                           // 0x00AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPreserveUVFlow;                                   // 0x00B0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B1[0x7];                                       // 0x00B1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SecondarySmoothBrushOpProps">();
	}
	static class USecondarySmoothBrushOpProps* GetDefaultObj()
	{
		return GetDefaultObjImpl<USecondarySmoothBrushOpProps>();
	}
};
static_assert(alignof(USecondarySmoothBrushOpProps) == 0x000008, "Wrong alignment on USecondarySmoothBrushOpProps");
static_assert(sizeof(USecondarySmoothBrushOpProps) == 0x0000B8, "Wrong size on USecondarySmoothBrushOpProps");
static_assert(offsetof(USecondarySmoothBrushOpProps, Strength) == 0x0000A8, "Member 'USecondarySmoothBrushOpProps::Strength' has a wrong offset!");
static_assert(offsetof(USecondarySmoothBrushOpProps, Falloff) == 0x0000AC, "Member 'USecondarySmoothBrushOpProps::Falloff' has a wrong offset!");
static_assert(offsetof(USecondarySmoothBrushOpProps, bPreserveUVFlow) == 0x0000B0, "Member 'USecondarySmoothBrushOpProps::bPreserveUVFlow' has a wrong offset!");

// Class MeshModelingToolsExp.MeshGroupPaintToolActionPropertySet
// 0x0008 (0x00B0 - 0x00A8)
class UMeshGroupPaintToolActionPropertySet : public UInteractiveToolPropertySet
{
public:
	uint8                                         Pad_A8[0x8];                                       // 0x00A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MeshGroupPaintToolActionPropertySet">();
	}
	static class UMeshGroupPaintToolActionPropertySet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMeshGroupPaintToolActionPropertySet>();
	}
};
static_assert(alignof(UMeshGroupPaintToolActionPropertySet) == 0x000008, "Wrong alignment on UMeshGroupPaintToolActionPropertySet");
static_assert(sizeof(UMeshGroupPaintToolActionPropertySet) == 0x0000B0, "Wrong size on UMeshGroupPaintToolActionPropertySet");

// Class MeshModelingToolsExp.SmoothFillBrushOpProps
// 0x0010 (0x00B8 - 0x00A8)
class USmoothFillBrushOpProps final : public UBaseSmoothBrushOpProps
{
public:
	float                                         Strength;                                          // 0x00A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Falloff;                                           // 0x00AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPreserveUVFlow;                                   // 0x00B0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B1[0x7];                                       // 0x00B1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SmoothFillBrushOpProps">();
	}
	static class USmoothFillBrushOpProps* GetDefaultObj()
	{
		return GetDefaultObjImpl<USmoothFillBrushOpProps>();
	}
};
static_assert(alignof(USmoothFillBrushOpProps) == 0x000008, "Wrong alignment on USmoothFillBrushOpProps");
static_assert(sizeof(USmoothFillBrushOpProps) == 0x0000B8, "Wrong size on USmoothFillBrushOpProps");
static_assert(offsetof(USmoothFillBrushOpProps, Strength) == 0x0000A8, "Member 'USmoothFillBrushOpProps::Strength' has a wrong offset!");
static_assert(offsetof(USmoothFillBrushOpProps, Falloff) == 0x0000AC, "Member 'USmoothFillBrushOpProps::Falloff' has a wrong offset!");
static_assert(offsetof(USmoothFillBrushOpProps, bPreserveUVFlow) == 0x0000B0, "Member 'USmoothFillBrushOpProps::bPreserveUVFlow' has a wrong offset!");

// Class MeshModelingToolsExp.FlattenBrushOpProps
// 0x0010 (0x00B8 - 0x00A8)
class UFlattenBrushOpProps final : public UMeshSculptBrushOpProps
{
public:
	float                                         Strength;                                          // 0x00A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Falloff;                                           // 0x00AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Depth;                                             // 0x00B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlaneBrushSideMode                           WhichSide;                                         // 0x00B4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B5[0x3];                                       // 0x00B5(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlattenBrushOpProps">();
	}
	static class UFlattenBrushOpProps* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlattenBrushOpProps>();
	}
};
static_assert(alignof(UFlattenBrushOpProps) == 0x000008, "Wrong alignment on UFlattenBrushOpProps");
static_assert(sizeof(UFlattenBrushOpProps) == 0x0000B8, "Wrong size on UFlattenBrushOpProps");
static_assert(offsetof(UFlattenBrushOpProps, Strength) == 0x0000A8, "Member 'UFlattenBrushOpProps::Strength' has a wrong offset!");
static_assert(offsetof(UFlattenBrushOpProps, Falloff) == 0x0000AC, "Member 'UFlattenBrushOpProps::Falloff' has a wrong offset!");
static_assert(offsetof(UFlattenBrushOpProps, Depth) == 0x0000B0, "Member 'UFlattenBrushOpProps::Depth' has a wrong offset!");
static_assert(offsetof(UFlattenBrushOpProps, WhichSide) == 0x0000B4, "Member 'UFlattenBrushOpProps::WhichSide' has a wrong offset!");

// Class MeshModelingToolsExp.MeshSelectionToolActionPropertySet
// 0x0008 (0x00B0 - 0x00A8)
class UMeshSelectionToolActionPropertySet : public UInteractiveToolPropertySet
{
public:
	uint8                                         Pad_A8[0x8];                                       // 0x00A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MeshSelectionToolActionPropertySet">();
	}
	static class UMeshSelectionToolActionPropertySet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMeshSelectionToolActionPropertySet>();
	}
};
static_assert(alignof(UMeshSelectionToolActionPropertySet) == 0x000008, "Wrong alignment on UMeshSelectionToolActionPropertySet");
static_assert(sizeof(UMeshSelectionToolActionPropertySet) == 0x0000B0, "Wrong size on UMeshSelectionToolActionPropertySet");

// Class MeshModelingToolsExp.MeshSelectionEditActions
// 0x0000 (0x00B0 - 0x00B0)
class UMeshSelectionEditActions final : public UMeshSelectionToolActionPropertySet
{
public:
	void Clear();
	void ExpandToMaterials();
	void FloodFill();
	void Grow();
	void Invert();
	void LargestAreaPart();
	void LargestTriCountPart();
	void OptimizeBorder();
	void SelectAll();
	void Shrink();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MeshSelectionEditActions">();
	}
	static class UMeshSelectionEditActions* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMeshSelectionEditActions>();
	}
};
static_assert(alignof(UMeshSelectionEditActions) == 0x000008, "Wrong alignment on UMeshSelectionEditActions");
static_assert(sizeof(UMeshSelectionEditActions) == 0x0000B0, "Wrong size on UMeshSelectionEditActions");

// Class MeshModelingToolsExp.EraseBrushOpProps
// 0x0008 (0x00B0 - 0x00A8)
class UEraseBrushOpProps final : public UMeshSculptBrushOpProps
{
public:
	float                                         Strength;                                          // 0x00A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Falloff;                                           // 0x00AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EraseBrushOpProps">();
	}
	static class UEraseBrushOpProps* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEraseBrushOpProps>();
	}
};
static_assert(alignof(UEraseBrushOpProps) == 0x000008, "Wrong alignment on UEraseBrushOpProps");
static_assert(sizeof(UEraseBrushOpProps) == 0x0000B0, "Wrong size on UEraseBrushOpProps");
static_assert(offsetof(UEraseBrushOpProps, Strength) == 0x0000A8, "Member 'UEraseBrushOpProps::Strength' has a wrong offset!");
static_assert(offsetof(UEraseBrushOpProps, Falloff) == 0x0000AC, "Member 'UEraseBrushOpProps::Falloff' has a wrong offset!");

// Class MeshModelingToolsExp.VertexColorBaseBrushOpProps
// 0x0010 (0x00B8 - 0x00A8)
class UVertexColorBaseBrushOpProps : public UMeshSculptBrushOpProps
{
public:
	float                                         Strength;                                          // 0x00A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Falloff;                                           // 0x00AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVertexColorPaintBrushOpBlendMode             BlendMode;                                         // 0x00B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bApplyFalloff;                                     // 0x00B4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B5[0x3];                                       // 0x00B5(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VertexColorBaseBrushOpProps">();
	}
	static class UVertexColorBaseBrushOpProps* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVertexColorBaseBrushOpProps>();
	}
};
static_assert(alignof(UVertexColorBaseBrushOpProps) == 0x000008, "Wrong alignment on UVertexColorBaseBrushOpProps");
static_assert(sizeof(UVertexColorBaseBrushOpProps) == 0x0000B8, "Wrong size on UVertexColorBaseBrushOpProps");
static_assert(offsetof(UVertexColorBaseBrushOpProps, Strength) == 0x0000A8, "Member 'UVertexColorBaseBrushOpProps::Strength' has a wrong offset!");
static_assert(offsetof(UVertexColorBaseBrushOpProps, Falloff) == 0x0000AC, "Member 'UVertexColorBaseBrushOpProps::Falloff' has a wrong offset!");
static_assert(offsetof(UVertexColorBaseBrushOpProps, BlendMode) == 0x0000B0, "Member 'UVertexColorBaseBrushOpProps::BlendMode' has a wrong offset!");
static_assert(offsetof(UVertexColorBaseBrushOpProps, bApplyFalloff) == 0x0000B4, "Member 'UVertexColorBaseBrushOpProps::bApplyFalloff' has a wrong offset!");

// Class MeshModelingToolsExp.VertexPaintBasicProperties
// 0x0038 (0x00E0 - 0x00A8)
class UVertexPaintBasicProperties final : public UInteractiveToolPropertySet
{
public:
	EMeshVertexPaintBrushType                     PrimaryBrushType;                                  // 0x00A8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMeshVertexPaintInteractionType               SubToolType;                                       // 0x00A9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AA[0x2];                                       // 0x00AA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           PaintColor;                                        // 0x00AC(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMeshVertexPaintColorBlendMode                BlendMode;                                         // 0x00BC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMeshVertexPaintSecondaryActionType           SecondaryActionType;                               // 0x00BD(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BE[0x2];                                       // 0x00BE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           EraseColor;                                        // 0x00C0(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SmoothStrength;                                    // 0x00D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FModelingToolsColorChannelFilter       ChannelFilter;                                     // 0x00D4(0x0004)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bHardEdges;                                        // 0x00D8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D9[0x7];                                       // 0x00D9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VertexPaintBasicProperties">();
	}
	static class UVertexPaintBasicProperties* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVertexPaintBasicProperties>();
	}
};
static_assert(alignof(UVertexPaintBasicProperties) == 0x000008, "Wrong alignment on UVertexPaintBasicProperties");
static_assert(sizeof(UVertexPaintBasicProperties) == 0x0000E0, "Wrong size on UVertexPaintBasicProperties");
static_assert(offsetof(UVertexPaintBasicProperties, PrimaryBrushType) == 0x0000A8, "Member 'UVertexPaintBasicProperties::PrimaryBrushType' has a wrong offset!");
static_assert(offsetof(UVertexPaintBasicProperties, SubToolType) == 0x0000A9, "Member 'UVertexPaintBasicProperties::SubToolType' has a wrong offset!");
static_assert(offsetof(UVertexPaintBasicProperties, PaintColor) == 0x0000AC, "Member 'UVertexPaintBasicProperties::PaintColor' has a wrong offset!");
static_assert(offsetof(UVertexPaintBasicProperties, BlendMode) == 0x0000BC, "Member 'UVertexPaintBasicProperties::BlendMode' has a wrong offset!");
static_assert(offsetof(UVertexPaintBasicProperties, SecondaryActionType) == 0x0000BD, "Member 'UVertexPaintBasicProperties::SecondaryActionType' has a wrong offset!");
static_assert(offsetof(UVertexPaintBasicProperties, EraseColor) == 0x0000C0, "Member 'UVertexPaintBasicProperties::EraseColor' has a wrong offset!");
static_assert(offsetof(UVertexPaintBasicProperties, SmoothStrength) == 0x0000D0, "Member 'UVertexPaintBasicProperties::SmoothStrength' has a wrong offset!");
static_assert(offsetof(UVertexPaintBasicProperties, ChannelFilter) == 0x0000D4, "Member 'UVertexPaintBasicProperties::ChannelFilter' has a wrong offset!");
static_assert(offsetof(UVertexPaintBasicProperties, bHardEdges) == 0x0000D8, "Member 'UVertexPaintBasicProperties::bHardEdges' has a wrong offset!");

// Class MeshModelingToolsExp.VertexColorPaintBrushOpProps
// 0x0010 (0x00C8 - 0x00B8)
class UVertexColorPaintBrushOpProps final : public UVertexColorBaseBrushOpProps
{
public:
	struct FLinearColor                           Color;                                             // 0x00B8(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VertexColorPaintBrushOpProps">();
	}
	static class UVertexColorPaintBrushOpProps* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVertexColorPaintBrushOpProps>();
	}
};
static_assert(alignof(UVertexColorPaintBrushOpProps) == 0x000008, "Wrong alignment on UVertexColorPaintBrushOpProps");
static_assert(sizeof(UVertexColorPaintBrushOpProps) == 0x0000C8, "Wrong size on UVertexColorPaintBrushOpProps");
static_assert(offsetof(UVertexColorPaintBrushOpProps, Color) == 0x0000B8, "Member 'UVertexColorPaintBrushOpProps::Color' has a wrong offset!");

// Class MeshModelingToolsExp.VertexColorSoftenBrushOpProps
// 0x0000 (0x00B8 - 0x00B8)
class UVertexColorSoftenBrushOpProps final : public UVertexColorBaseBrushOpProps
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VertexColorSoftenBrushOpProps">();
	}
	static class UVertexColorSoftenBrushOpProps* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVertexColorSoftenBrushOpProps>();
	}
};
static_assert(alignof(UVertexColorSoftenBrushOpProps) == 0x000008, "Wrong alignment on UVertexColorSoftenBrushOpProps");
static_assert(sizeof(UVertexColorSoftenBrushOpProps) == 0x0000B8, "Wrong size on UVertexColorSoftenBrushOpProps");

// Class MeshModelingToolsExp.MeshSpaceDeformerToolBuilder
// 0x0000 (0x0028 - 0x0028)
class UMeshSpaceDeformerToolBuilder final : public USingleSelectionMeshEditingToolBuilder
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MeshSpaceDeformerToolBuilder">();
	}
	static class UMeshSpaceDeformerToolBuilder* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMeshSpaceDeformerToolBuilder>();
	}
};
static_assert(alignof(UMeshSpaceDeformerToolBuilder) == 0x000008, "Wrong alignment on UMeshSpaceDeformerToolBuilder");
static_assert(sizeof(UMeshSpaceDeformerToolBuilder) == 0x000028, "Wrong size on UMeshSpaceDeformerToolBuilder");

// Class MeshModelingToolsExp.VertexColorSmoothBrushOpProps
// 0x0000 (0x00B8 - 0x00B8)
class UVertexColorSmoothBrushOpProps final : public UVertexColorBaseBrushOpProps
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VertexColorSmoothBrushOpProps">();
	}
	static class UVertexColorSmoothBrushOpProps* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVertexColorSmoothBrushOpProps>();
	}
};
static_assert(alignof(UVertexColorSmoothBrushOpProps) == 0x000008, "Wrong alignment on UVertexColorSmoothBrushOpProps");
static_assert(sizeof(UVertexColorSmoothBrushOpProps) == 0x0000B8, "Wrong size on UVertexColorSmoothBrushOpProps");

// Class MeshModelingToolsExp.OffsetMeshSelectionToolBuilder
// 0x0000 (0x0028 - 0x0028)
class UOffsetMeshSelectionToolBuilder final : public USingleTargetWithSelectionToolBuilder
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OffsetMeshSelectionToolBuilder">();
	}
	static class UOffsetMeshSelectionToolBuilder* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOffsetMeshSelectionToolBuilder>();
	}
};
static_assert(alignof(UOffsetMeshSelectionToolBuilder) == 0x000008, "Wrong alignment on UOffsetMeshSelectionToolBuilder");
static_assert(sizeof(UOffsetMeshSelectionToolBuilder) == 0x000028, "Wrong size on UOffsetMeshSelectionToolBuilder");

// Class MeshModelingToolsExp.MeshSelectionToolBuilder
// 0x0000 (0x0030 - 0x0030)
class UMeshSelectionToolBuilder final : public UMeshSurfacePointMeshEditingToolBuilder
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MeshSelectionToolBuilder">();
	}
	static class UMeshSelectionToolBuilder* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMeshSelectionToolBuilder>();
	}
};
static_assert(alignof(UMeshSelectionToolBuilder) == 0x000008, "Wrong alignment on UMeshSelectionToolBuilder");
static_assert(sizeof(UMeshSelectionToolBuilder) == 0x000030, "Wrong size on UMeshSelectionToolBuilder");

// Class MeshModelingToolsExp.OffsetMeshSelectionToolProperties
// 0x0038 (0x00E0 - 0x00A8)
class UOffsetMeshSelectionToolProperties final : public UInteractiveToolPropertySet
{
public:
	double                                        OffsetDistance;                                    // 0x00A8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOffsetMeshSelectionDirectionMode             Direction;                                         // 0x00B0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B1[0x3];                                       // 0x00B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NumSubdivisions;                                   // 0x00B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        CreaseAngle;                                       // 0x00B8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShellsToSolids;                                   // 0x00C0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInferGroupsFromNbrs;                              // 0x00C1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bGroupPerSubdivision;                              // 0x00C2(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bReplaceSelectionGroups;                           // 0x00C3(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C4[0x4];                                       // 0x00C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        UVScale;                                           // 0x00C8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUVIslandPerGroup;                                 // 0x00D0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInferMaterialID;                                  // 0x00D1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D2[0x2];                                       // 0x00D2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SetMaterialID;                                     // 0x00D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowInputMaterials;                               // 0x00D8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D9[0x7];                                       // 0x00D9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OffsetMeshSelectionToolProperties">();
	}
	static class UOffsetMeshSelectionToolProperties* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOffsetMeshSelectionToolProperties>();
	}
};
static_assert(alignof(UOffsetMeshSelectionToolProperties) == 0x000008, "Wrong alignment on UOffsetMeshSelectionToolProperties");
static_assert(sizeof(UOffsetMeshSelectionToolProperties) == 0x0000E0, "Wrong size on UOffsetMeshSelectionToolProperties");
static_assert(offsetof(UOffsetMeshSelectionToolProperties, OffsetDistance) == 0x0000A8, "Member 'UOffsetMeshSelectionToolProperties::OffsetDistance' has a wrong offset!");
static_assert(offsetof(UOffsetMeshSelectionToolProperties, Direction) == 0x0000B0, "Member 'UOffsetMeshSelectionToolProperties::Direction' has a wrong offset!");
static_assert(offsetof(UOffsetMeshSelectionToolProperties, NumSubdivisions) == 0x0000B4, "Member 'UOffsetMeshSelectionToolProperties::NumSubdivisions' has a wrong offset!");
static_assert(offsetof(UOffsetMeshSelectionToolProperties, CreaseAngle) == 0x0000B8, "Member 'UOffsetMeshSelectionToolProperties::CreaseAngle' has a wrong offset!");
static_assert(offsetof(UOffsetMeshSelectionToolProperties, bShellsToSolids) == 0x0000C0, "Member 'UOffsetMeshSelectionToolProperties::bShellsToSolids' has a wrong offset!");
static_assert(offsetof(UOffsetMeshSelectionToolProperties, bInferGroupsFromNbrs) == 0x0000C1, "Member 'UOffsetMeshSelectionToolProperties::bInferGroupsFromNbrs' has a wrong offset!");
static_assert(offsetof(UOffsetMeshSelectionToolProperties, bGroupPerSubdivision) == 0x0000C2, "Member 'UOffsetMeshSelectionToolProperties::bGroupPerSubdivision' has a wrong offset!");
static_assert(offsetof(UOffsetMeshSelectionToolProperties, bReplaceSelectionGroups) == 0x0000C3, "Member 'UOffsetMeshSelectionToolProperties::bReplaceSelectionGroups' has a wrong offset!");
static_assert(offsetof(UOffsetMeshSelectionToolProperties, UVScale) == 0x0000C8, "Member 'UOffsetMeshSelectionToolProperties::UVScale' has a wrong offset!");
static_assert(offsetof(UOffsetMeshSelectionToolProperties, bUVIslandPerGroup) == 0x0000D0, "Member 'UOffsetMeshSelectionToolProperties::bUVIslandPerGroup' has a wrong offset!");
static_assert(offsetof(UOffsetMeshSelectionToolProperties, bInferMaterialID) == 0x0000D1, "Member 'UOffsetMeshSelectionToolProperties::bInferMaterialID' has a wrong offset!");
static_assert(offsetof(UOffsetMeshSelectionToolProperties, SetMaterialID) == 0x0000D4, "Member 'UOffsetMeshSelectionToolProperties::SetMaterialID' has a wrong offset!");
static_assert(offsetof(UOffsetMeshSelectionToolProperties, bShowInputMaterials) == 0x0000D8, "Member 'UOffsetMeshSelectionToolProperties::bShowInputMaterials' has a wrong offset!");

// Class MeshModelingToolsExp.OffsetMeshSelectionTool
// 0x0738 (0x0858 - 0x0120)
class UOffsetMeshSelectionTool final : public USingleTargetWithSelectionTool
{
public:
	class UOffsetMeshSelectionToolProperties*     OffsetProperties;                                  // 0x0120(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_128[0x720];                                    // 0x0128(0x0720)(Fixing Size After Last Property [ Dumper-7 ])
	class UPreviewMesh*                           SourcePreview;                                     // 0x0848(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMeshOpPreviewWithBackgroundCompute*    EditCompute;                                       // 0x0850(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OffsetMeshSelectionTool">();
	}
	static class UOffsetMeshSelectionTool* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOffsetMeshSelectionTool>();
	}
};
static_assert(alignof(UOffsetMeshSelectionTool) == 0x000008, "Wrong alignment on UOffsetMeshSelectionTool");
static_assert(sizeof(UOffsetMeshSelectionTool) == 0x000858, "Wrong size on UOffsetMeshSelectionTool");
static_assert(offsetof(UOffsetMeshSelectionTool, OffsetProperties) == 0x000120, "Member 'UOffsetMeshSelectionTool::OffsetProperties' has a wrong offset!");
static_assert(offsetof(UOffsetMeshSelectionTool, SourcePreview) == 0x000848, "Member 'UOffsetMeshSelectionTool::SourcePreview' has a wrong offset!");
static_assert(offsetof(UOffsetMeshSelectionTool, EditCompute) == 0x000850, "Member 'UOffsetMeshSelectionTool::EditCompute' has a wrong offset!");

// Class MeshModelingToolsExp.DisplaceMeshDirectionalFilterProperties
// 0x0028 (0x00D0 - 0x00A8)
class UDisplaceMeshDirectionalFilterProperties final : public UInteractiveToolPropertySet
{
public:
	bool                                          bEnableFilter;                                     // 0x00A8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A9[0x7];                                       // 0x00A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                FilterDirection;                                   // 0x00B0(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FilterWidth;                                       // 0x00C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CC[0x4];                                       // 0x00CC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DisplaceMeshDirectionalFilterProperties">();
	}
	static class UDisplaceMeshDirectionalFilterProperties* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDisplaceMeshDirectionalFilterProperties>();
	}
};
static_assert(alignof(UDisplaceMeshDirectionalFilterProperties) == 0x000008, "Wrong alignment on UDisplaceMeshDirectionalFilterProperties");
static_assert(sizeof(UDisplaceMeshDirectionalFilterProperties) == 0x0000D0, "Wrong size on UDisplaceMeshDirectionalFilterProperties");
static_assert(offsetof(UDisplaceMeshDirectionalFilterProperties, bEnableFilter) == 0x0000A8, "Member 'UDisplaceMeshDirectionalFilterProperties::bEnableFilter' has a wrong offset!");
static_assert(offsetof(UDisplaceMeshDirectionalFilterProperties, FilterDirection) == 0x0000B0, "Member 'UDisplaceMeshDirectionalFilterProperties::FilterDirection' has a wrong offset!");
static_assert(offsetof(UDisplaceMeshDirectionalFilterProperties, FilterWidth) == 0x0000C8, "Member 'UDisplaceMeshDirectionalFilterProperties::FilterWidth' has a wrong offset!");

// Class MeshModelingToolsExp.PatternToolBuilder
// 0x0008 (0x0030 - 0x0028)
class UPatternToolBuilder final : public UMultiSelectionMeshEditingToolBuilder
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PatternToolBuilder">();
	}
	static class UPatternToolBuilder* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPatternToolBuilder>();
	}
};
static_assert(alignof(UPatternToolBuilder) == 0x000008, "Wrong alignment on UPatternToolBuilder");
static_assert(sizeof(UPatternToolBuilder) == 0x000030, "Wrong size on UPatternToolBuilder");

// Class MeshModelingToolsExp.PatternToolSettings
// 0x0018 (0x00C0 - 0x00A8)
class UPatternToolSettings final : public UInteractiveToolPropertySet
{
public:
	int32                                         Seed;                                              // 0x00A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bProjectElementsDown;                              // 0x00AC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AD[0x3];                                       // 0x00AD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ProjectionOffset;                                  // 0x00B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHideSources;                                      // 0x00B4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseRelativeTransforms;                            // 0x00B5(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRandomlyPickElements;                             // 0x00B6(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPatternToolShape                             Shape;                                             // 0x00B7(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPatternToolSingleAxis                        SingleAxis;                                        // 0x00B8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPatternToolSinglePlane                       SinglePlane;                                       // 0x00B9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BA[0x6];                                       // 0x00BA(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PatternToolSettings">();
	}
	static class UPatternToolSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPatternToolSettings>();
	}
};
static_assert(alignof(UPatternToolSettings) == 0x000008, "Wrong alignment on UPatternToolSettings");
static_assert(sizeof(UPatternToolSettings) == 0x0000C0, "Wrong size on UPatternToolSettings");
static_assert(offsetof(UPatternToolSettings, Seed) == 0x0000A8, "Member 'UPatternToolSettings::Seed' has a wrong offset!");
static_assert(offsetof(UPatternToolSettings, bProjectElementsDown) == 0x0000AC, "Member 'UPatternToolSettings::bProjectElementsDown' has a wrong offset!");
static_assert(offsetof(UPatternToolSettings, ProjectionOffset) == 0x0000B0, "Member 'UPatternToolSettings::ProjectionOffset' has a wrong offset!");
static_assert(offsetof(UPatternToolSettings, bHideSources) == 0x0000B4, "Member 'UPatternToolSettings::bHideSources' has a wrong offset!");
static_assert(offsetof(UPatternToolSettings, bUseRelativeTransforms) == 0x0000B5, "Member 'UPatternToolSettings::bUseRelativeTransforms' has a wrong offset!");
static_assert(offsetof(UPatternToolSettings, bRandomlyPickElements) == 0x0000B6, "Member 'UPatternToolSettings::bRandomlyPickElements' has a wrong offset!");
static_assert(offsetof(UPatternToolSettings, Shape) == 0x0000B7, "Member 'UPatternToolSettings::Shape' has a wrong offset!");
static_assert(offsetof(UPatternToolSettings, SingleAxis) == 0x0000B8, "Member 'UPatternToolSettings::SingleAxis' has a wrong offset!");
static_assert(offsetof(UPatternToolSettings, SinglePlane) == 0x0000B9, "Member 'UPatternToolSettings::SinglePlane' has a wrong offset!");

// Class MeshModelingToolsExp.VertexBrushAlphaProperties
// 0x0020 (0x00C8 - 0x00A8)
class UVertexBrushAlphaProperties final : public UInteractiveToolPropertySet
{
public:
	class UTexture2D*                             Alpha;                                             // 0x00A8(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotationAngle;                                     // 0x00B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRandomize;                                        // 0x00B4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B5[0x3];                                       // 0x00B5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RandomRange;                                       // 0x00B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UMeshVertexSculptTool>   Tool;                                              // 0x00BC(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C4[0x4];                                       // 0x00C4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VertexBrushAlphaProperties">();
	}
	static class UVertexBrushAlphaProperties* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVertexBrushAlphaProperties>();
	}
};
static_assert(alignof(UVertexBrushAlphaProperties) == 0x000008, "Wrong alignment on UVertexBrushAlphaProperties");
static_assert(sizeof(UVertexBrushAlphaProperties) == 0x0000C8, "Wrong size on UVertexBrushAlphaProperties");
static_assert(offsetof(UVertexBrushAlphaProperties, Alpha) == 0x0000A8, "Member 'UVertexBrushAlphaProperties::Alpha' has a wrong offset!");
static_assert(offsetof(UVertexBrushAlphaProperties, RotationAngle) == 0x0000B0, "Member 'UVertexBrushAlphaProperties::RotationAngle' has a wrong offset!");
static_assert(offsetof(UVertexBrushAlphaProperties, bRandomize) == 0x0000B4, "Member 'UVertexBrushAlphaProperties::bRandomize' has a wrong offset!");
static_assert(offsetof(UVertexBrushAlphaProperties, RandomRange) == 0x0000B8, "Member 'UVertexBrushAlphaProperties::RandomRange' has a wrong offset!");
static_assert(offsetof(UVertexBrushAlphaProperties, Tool) == 0x0000BC, "Member 'UVertexBrushAlphaProperties::Tool' has a wrong offset!");

// Class MeshModelingToolsExp.PatternTool_BoundingBoxSettings
// 0x0010 (0x00B8 - 0x00A8)
class UPatternTool_BoundingBoxSettings final : public UInteractiveToolPropertySet
{
public:
	bool                                          bIgnoreTransforms;                                 // 0x00A8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A9[0x3];                                       // 0x00A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Adjustment;                                        // 0x00AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bVisualize;                                        // 0x00B0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B1[0x7];                                       // 0x00B1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PatternTool_BoundingBoxSettings">();
	}
	static class UPatternTool_BoundingBoxSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPatternTool_BoundingBoxSettings>();
	}
};
static_assert(alignof(UPatternTool_BoundingBoxSettings) == 0x000008, "Wrong alignment on UPatternTool_BoundingBoxSettings");
static_assert(sizeof(UPatternTool_BoundingBoxSettings) == 0x0000B8, "Wrong size on UPatternTool_BoundingBoxSettings");
static_assert(offsetof(UPatternTool_BoundingBoxSettings, bIgnoreTransforms) == 0x0000A8, "Member 'UPatternTool_BoundingBoxSettings::bIgnoreTransforms' has a wrong offset!");
static_assert(offsetof(UPatternTool_BoundingBoxSettings, Adjustment) == 0x0000AC, "Member 'UPatternTool_BoundingBoxSettings::Adjustment' has a wrong offset!");
static_assert(offsetof(UPatternTool_BoundingBoxSettings, bVisualize) == 0x0000B0, "Member 'UPatternTool_BoundingBoxSettings::bVisualize' has a wrong offset!");

// Class MeshModelingToolsExp.PatternTool_LinearSettings
// 0x0020 (0x00C8 - 0x00A8)
class UPatternTool_LinearSettings final : public UInteractiveToolPropertySet
{
public:
	EPatternToolAxisSpacingMode                   SpacingMode;                                       // 0x00A8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A9[0x3];                                       // 0x00A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Count;                                             // 0x00AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        StepSize;                                          // 0x00B0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        Extent;                                            // 0x00B8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCentered;                                         // 0x00C0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C1[0x7];                                       // 0x00C1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PatternTool_LinearSettings">();
	}
	static class UPatternTool_LinearSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPatternTool_LinearSettings>();
	}
};
static_assert(alignof(UPatternTool_LinearSettings) == 0x000008, "Wrong alignment on UPatternTool_LinearSettings");
static_assert(sizeof(UPatternTool_LinearSettings) == 0x0000C8, "Wrong size on UPatternTool_LinearSettings");
static_assert(offsetof(UPatternTool_LinearSettings, SpacingMode) == 0x0000A8, "Member 'UPatternTool_LinearSettings::SpacingMode' has a wrong offset!");
static_assert(offsetof(UPatternTool_LinearSettings, Count) == 0x0000AC, "Member 'UPatternTool_LinearSettings::Count' has a wrong offset!");
static_assert(offsetof(UPatternTool_LinearSettings, StepSize) == 0x0000B0, "Member 'UPatternTool_LinearSettings::StepSize' has a wrong offset!");
static_assert(offsetof(UPatternTool_LinearSettings, Extent) == 0x0000B8, "Member 'UPatternTool_LinearSettings::Extent' has a wrong offset!");
static_assert(offsetof(UPatternTool_LinearSettings, bCentered) == 0x0000C0, "Member 'UPatternTool_LinearSettings::bCentered' has a wrong offset!");

// Class MeshModelingToolsExp.DisplaceMeshTool
// 0x03B0 (0x0460 - 0x00B0)
class alignas(0x10) UDisplaceMeshTool final : public USingleSelectionMeshEditingTool
{
public:
	class UDisplaceMeshCommonProperties*          CommonProperties;                                  // 0x00B0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDisplaceMeshDirectionalFilterProperties* DirectionalFilterProperties;                       // 0x00B8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDisplaceMeshTextureMapProperties*      TextureMapProperties;                              // 0x00C0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDisplaceMeshPerlinNoiseProperties*     NoiseProperties;                                   // 0x00C8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDisplaceMeshSineWaveProperties*        SineWaveProperties;                                // 0x00D0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USelectiveTessellationProperties*       SelectiveTessellationProperties;                   // 0x00D8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            ActiveContrastCurveTarget;                         // 0x00E0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMeshStatisticsProperties*              MeshStatistics;                                    // 0x00E8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F0[0x340];                                     // 0x00F0(0x0340)(Fixing Size After Last Property [ Dumper-7 ])
	class AInternalToolFrameworkActor*            PreviewMeshActor;                                  // 0x0430(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDynamicMeshComponent*                  DynamicMeshComponent;                              // 0x0438(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_440[0x20];                                     // 0x0440(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DisplaceMeshTool">();
	}
	static class UDisplaceMeshTool* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDisplaceMeshTool>();
	}
};
static_assert(alignof(UDisplaceMeshTool) == 0x000010, "Wrong alignment on UDisplaceMeshTool");
static_assert(sizeof(UDisplaceMeshTool) == 0x000460, "Wrong size on UDisplaceMeshTool");
static_assert(offsetof(UDisplaceMeshTool, CommonProperties) == 0x0000B0, "Member 'UDisplaceMeshTool::CommonProperties' has a wrong offset!");
static_assert(offsetof(UDisplaceMeshTool, DirectionalFilterProperties) == 0x0000B8, "Member 'UDisplaceMeshTool::DirectionalFilterProperties' has a wrong offset!");
static_assert(offsetof(UDisplaceMeshTool, TextureMapProperties) == 0x0000C0, "Member 'UDisplaceMeshTool::TextureMapProperties' has a wrong offset!");
static_assert(offsetof(UDisplaceMeshTool, NoiseProperties) == 0x0000C8, "Member 'UDisplaceMeshTool::NoiseProperties' has a wrong offset!");
static_assert(offsetof(UDisplaceMeshTool, SineWaveProperties) == 0x0000D0, "Member 'UDisplaceMeshTool::SineWaveProperties' has a wrong offset!");
static_assert(offsetof(UDisplaceMeshTool, SelectiveTessellationProperties) == 0x0000D8, "Member 'UDisplaceMeshTool::SelectiveTessellationProperties' has a wrong offset!");
static_assert(offsetof(UDisplaceMeshTool, ActiveContrastCurveTarget) == 0x0000E0, "Member 'UDisplaceMeshTool::ActiveContrastCurveTarget' has a wrong offset!");
static_assert(offsetof(UDisplaceMeshTool, MeshStatistics) == 0x0000E8, "Member 'UDisplaceMeshTool::MeshStatistics' has a wrong offset!");
static_assert(offsetof(UDisplaceMeshTool, PreviewMeshActor) == 0x000430, "Member 'UDisplaceMeshTool::PreviewMeshActor' has a wrong offset!");
static_assert(offsetof(UDisplaceMeshTool, DynamicMeshComponent) == 0x000438, "Member 'UDisplaceMeshTool::DynamicMeshComponent' has a wrong offset!");

// Class MeshModelingToolsExp.PatternTool_GridSettings
// 0x0038 (0x00E0 - 0x00A8)
class UPatternTool_GridSettings final : public UInteractiveToolPropertySet
{
public:
	EPatternToolAxisSpacingMode                   SpacingX;                                          // 0x00A8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A9[0x3];                                       // 0x00A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CountX;                                            // 0x00AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        StepSizeX;                                         // 0x00B0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        ExtentX;                                           // 0x00B8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCenteredX;                                        // 0x00C0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPatternToolAxisSpacingMode                   SpacingY;                                          // 0x00C1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C2[0x2];                                       // 0x00C2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CountY;                                            // 0x00C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        StepSizeY;                                         // 0x00C8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        ExtentY;                                           // 0x00D0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCenteredY;                                        // 0x00D8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D9[0x7];                                       // 0x00D9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PatternTool_GridSettings">();
	}
	static class UPatternTool_GridSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPatternTool_GridSettings>();
	}
};
static_assert(alignof(UPatternTool_GridSettings) == 0x000008, "Wrong alignment on UPatternTool_GridSettings");
static_assert(sizeof(UPatternTool_GridSettings) == 0x0000E0, "Wrong size on UPatternTool_GridSettings");
static_assert(offsetof(UPatternTool_GridSettings, SpacingX) == 0x0000A8, "Member 'UPatternTool_GridSettings::SpacingX' has a wrong offset!");
static_assert(offsetof(UPatternTool_GridSettings, CountX) == 0x0000AC, "Member 'UPatternTool_GridSettings::CountX' has a wrong offset!");
static_assert(offsetof(UPatternTool_GridSettings, StepSizeX) == 0x0000B0, "Member 'UPatternTool_GridSettings::StepSizeX' has a wrong offset!");
static_assert(offsetof(UPatternTool_GridSettings, ExtentX) == 0x0000B8, "Member 'UPatternTool_GridSettings::ExtentX' has a wrong offset!");
static_assert(offsetof(UPatternTool_GridSettings, bCenteredX) == 0x0000C0, "Member 'UPatternTool_GridSettings::bCenteredX' has a wrong offset!");
static_assert(offsetof(UPatternTool_GridSettings, SpacingY) == 0x0000C1, "Member 'UPatternTool_GridSettings::SpacingY' has a wrong offset!");
static_assert(offsetof(UPatternTool_GridSettings, CountY) == 0x0000C4, "Member 'UPatternTool_GridSettings::CountY' has a wrong offset!");
static_assert(offsetof(UPatternTool_GridSettings, StepSizeY) == 0x0000C8, "Member 'UPatternTool_GridSettings::StepSizeY' has a wrong offset!");
static_assert(offsetof(UPatternTool_GridSettings, ExtentY) == 0x0000D0, "Member 'UPatternTool_GridSettings::ExtentY' has a wrong offset!");
static_assert(offsetof(UPatternTool_GridSettings, bCenteredY) == 0x0000D8, "Member 'UPatternTool_GridSettings::bCenteredY' has a wrong offset!");

// Class MeshModelingToolsExp.PatternTool_RadialSettings
// 0x0038 (0x00E0 - 0x00A8)
class UPatternTool_RadialSettings final : public UInteractiveToolPropertySet
{
public:
	EPatternToolAxisSpacingMode                   SpacingMode;                                       // 0x00A8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A9[0x3];                                       // 0x00A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Count;                                             // 0x00AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        StepSize;                                          // 0x00B0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        Radius;                                            // 0x00B8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        StartAngle;                                        // 0x00C0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        EndAngle;                                          // 0x00C8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        AngleShift;                                        // 0x00D0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOriented;                                         // 0x00D8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D9[0x7];                                       // 0x00D9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PatternTool_RadialSettings">();
	}
	static class UPatternTool_RadialSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPatternTool_RadialSettings>();
	}
};
static_assert(alignof(UPatternTool_RadialSettings) == 0x000008, "Wrong alignment on UPatternTool_RadialSettings");
static_assert(sizeof(UPatternTool_RadialSettings) == 0x0000E0, "Wrong size on UPatternTool_RadialSettings");
static_assert(offsetof(UPatternTool_RadialSettings, SpacingMode) == 0x0000A8, "Member 'UPatternTool_RadialSettings::SpacingMode' has a wrong offset!");
static_assert(offsetof(UPatternTool_RadialSettings, Count) == 0x0000AC, "Member 'UPatternTool_RadialSettings::Count' has a wrong offset!");
static_assert(offsetof(UPatternTool_RadialSettings, StepSize) == 0x0000B0, "Member 'UPatternTool_RadialSettings::StepSize' has a wrong offset!");
static_assert(offsetof(UPatternTool_RadialSettings, Radius) == 0x0000B8, "Member 'UPatternTool_RadialSettings::Radius' has a wrong offset!");
static_assert(offsetof(UPatternTool_RadialSettings, StartAngle) == 0x0000C0, "Member 'UPatternTool_RadialSettings::StartAngle' has a wrong offset!");
static_assert(offsetof(UPatternTool_RadialSettings, EndAngle) == 0x0000C8, "Member 'UPatternTool_RadialSettings::EndAngle' has a wrong offset!");
static_assert(offsetof(UPatternTool_RadialSettings, AngleShift) == 0x0000D0, "Member 'UPatternTool_RadialSettings::AngleShift' has a wrong offset!");
static_assert(offsetof(UPatternTool_RadialSettings, bOriented) == 0x0000D8, "Member 'UPatternTool_RadialSettings::bOriented' has a wrong offset!");

// Class MeshModelingToolsExp.SelectiveTessellationProperties
// 0x0020 (0x00C8 - 0x00A8)
class USelectiveTessellationProperties final : public UInteractiveToolPropertySet
{
public:
	EDisplaceMeshToolTriangleSelectionType        SelectionType;                                     // 0x00A8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A9[0x3];                                       // 0x00A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ActiveMaterial;                                    // 0x00AC(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B4[0x4];                                       // 0x00B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         MaterialIDList;                                    // 0x00B8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)

public:
	TArray<class FString> GetMaterialIDsFunc();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SelectiveTessellationProperties">();
	}
	static class USelectiveTessellationProperties* GetDefaultObj()
	{
		return GetDefaultObjImpl<USelectiveTessellationProperties>();
	}
};
static_assert(alignof(USelectiveTessellationProperties) == 0x000008, "Wrong alignment on USelectiveTessellationProperties");
static_assert(sizeof(USelectiveTessellationProperties) == 0x0000C8, "Wrong size on USelectiveTessellationProperties");
static_assert(offsetof(USelectiveTessellationProperties, SelectionType) == 0x0000A8, "Member 'USelectiveTessellationProperties::SelectionType' has a wrong offset!");
static_assert(offsetof(USelectiveTessellationProperties, ActiveMaterial) == 0x0000AC, "Member 'USelectiveTessellationProperties::ActiveMaterial' has a wrong offset!");
static_assert(offsetof(USelectiveTessellationProperties, MaterialIDList) == 0x0000B8, "Member 'USelectiveTessellationProperties::MaterialIDList' has a wrong offset!");

// Class MeshModelingToolsExp.PatternTool_RotationSettings
// 0x0050 (0x00F8 - 0x00A8)
class UPatternTool_RotationSettings final : public UInteractiveToolPropertySet
{
public:
	bool                                          bInterpolate;                                      // 0x00A8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bJitter;                                           // 0x00A9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AA[0x6];                                       // 0x00AA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               StartRotation;                                     // 0x00B0(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               EndRotation;                                       // 0x00C8(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               Jitter;                                            // 0x00E0(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PatternTool_RotationSettings">();
	}
	static class UPatternTool_RotationSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPatternTool_RotationSettings>();
	}
};
static_assert(alignof(UPatternTool_RotationSettings) == 0x000008, "Wrong alignment on UPatternTool_RotationSettings");
static_assert(sizeof(UPatternTool_RotationSettings) == 0x0000F8, "Wrong size on UPatternTool_RotationSettings");
static_assert(offsetof(UPatternTool_RotationSettings, bInterpolate) == 0x0000A8, "Member 'UPatternTool_RotationSettings::bInterpolate' has a wrong offset!");
static_assert(offsetof(UPatternTool_RotationSettings, bJitter) == 0x0000A9, "Member 'UPatternTool_RotationSettings::bJitter' has a wrong offset!");
static_assert(offsetof(UPatternTool_RotationSettings, StartRotation) == 0x0000B0, "Member 'UPatternTool_RotationSettings::StartRotation' has a wrong offset!");
static_assert(offsetof(UPatternTool_RotationSettings, EndRotation) == 0x0000C8, "Member 'UPatternTool_RotationSettings::EndRotation' has a wrong offset!");
static_assert(offsetof(UPatternTool_RotationSettings, Jitter) == 0x0000E0, "Member 'UPatternTool_RotationSettings::Jitter' has a wrong offset!");

// Class MeshModelingToolsExp.PatternTool_TranslationSettings
// 0x0050 (0x00F8 - 0x00A8)
class UPatternTool_TranslationSettings final : public UInteractiveToolPropertySet
{
public:
	bool                                          bInterpolate;                                      // 0x00A8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bJitter;                                           // 0x00A9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AA[0x6];                                       // 0x00AA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                StartTranslation;                                  // 0x00B0(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                EndTranslation;                                    // 0x00C8(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Jitter;                                            // 0x00E0(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PatternTool_TranslationSettings">();
	}
	static class UPatternTool_TranslationSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPatternTool_TranslationSettings>();
	}
};
static_assert(alignof(UPatternTool_TranslationSettings) == 0x000008, "Wrong alignment on UPatternTool_TranslationSettings");
static_assert(sizeof(UPatternTool_TranslationSettings) == 0x0000F8, "Wrong size on UPatternTool_TranslationSettings");
static_assert(offsetof(UPatternTool_TranslationSettings, bInterpolate) == 0x0000A8, "Member 'UPatternTool_TranslationSettings::bInterpolate' has a wrong offset!");
static_assert(offsetof(UPatternTool_TranslationSettings, bJitter) == 0x0000A9, "Member 'UPatternTool_TranslationSettings::bJitter' has a wrong offset!");
static_assert(offsetof(UPatternTool_TranslationSettings, StartTranslation) == 0x0000B0, "Member 'UPatternTool_TranslationSettings::StartTranslation' has a wrong offset!");
static_assert(offsetof(UPatternTool_TranslationSettings, EndTranslation) == 0x0000C8, "Member 'UPatternTool_TranslationSettings::EndTranslation' has a wrong offset!");
static_assert(offsetof(UPatternTool_TranslationSettings, Jitter) == 0x0000E0, "Member 'UPatternTool_TranslationSettings::Jitter' has a wrong offset!");

// Class MeshModelingToolsExp.MeshVertexSculptToolBuilder
// 0x0000 (0x0030 - 0x0030)
class UMeshVertexSculptToolBuilder final : public UMeshSurfacePointMeshEditingToolBuilder
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MeshVertexSculptToolBuilder">();
	}
	static class UMeshVertexSculptToolBuilder* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMeshVertexSculptToolBuilder>();
	}
};
static_assert(alignof(UMeshVertexSculptToolBuilder) == 0x000008, "Wrong alignment on UMeshVertexSculptToolBuilder");
static_assert(sizeof(UMeshVertexSculptToolBuilder) == 0x000030, "Wrong size on UMeshVertexSculptToolBuilder");

// Class MeshModelingToolsExp.PatternTool_ScaleSettings
// 0x0050 (0x00F8 - 0x00A8)
class UPatternTool_ScaleSettings final : public UInteractiveToolPropertySet
{
public:
	bool                                          bProportional;                                     // 0x00A8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInterpolate;                                      // 0x00A9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bJitter;                                           // 0x00AA(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AB[0x5];                                       // 0x00AB(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                StartScale;                                        // 0x00B0(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                EndScale;                                          // 0x00C8(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Jitter;                                            // 0x00E0(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PatternTool_ScaleSettings">();
	}
	static class UPatternTool_ScaleSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPatternTool_ScaleSettings>();
	}
};
static_assert(alignof(UPatternTool_ScaleSettings) == 0x000008, "Wrong alignment on UPatternTool_ScaleSettings");
static_assert(sizeof(UPatternTool_ScaleSettings) == 0x0000F8, "Wrong size on UPatternTool_ScaleSettings");
static_assert(offsetof(UPatternTool_ScaleSettings, bProportional) == 0x0000A8, "Member 'UPatternTool_ScaleSettings::bProportional' has a wrong offset!");
static_assert(offsetof(UPatternTool_ScaleSettings, bInterpolate) == 0x0000A9, "Member 'UPatternTool_ScaleSettings::bInterpolate' has a wrong offset!");
static_assert(offsetof(UPatternTool_ScaleSettings, bJitter) == 0x0000AA, "Member 'UPatternTool_ScaleSettings::bJitter' has a wrong offset!");
static_assert(offsetof(UPatternTool_ScaleSettings, StartScale) == 0x0000B0, "Member 'UPatternTool_ScaleSettings::StartScale' has a wrong offset!");
static_assert(offsetof(UPatternTool_ScaleSettings, EndScale) == 0x0000C8, "Member 'UPatternTool_ScaleSettings::EndScale' has a wrong offset!");
static_assert(offsetof(UPatternTool_ScaleSettings, Jitter) == 0x0000E0, "Member 'UPatternTool_ScaleSettings::Jitter' has a wrong offset!");

// Class MeshModelingToolsExp.PatternTool_OutputSettings
// 0x0008 (0x00B0 - 0x00A8)
class UPatternTool_OutputSettings final : public UInteractiveToolPropertySet
{
public:
	bool                                          bSeparateActors;                                   // 0x00A8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bConvertToDynamic;                                 // 0x00A9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCreateISMCs;                                      // 0x00AA(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHaveStaticMeshes;                                 // 0x00AB(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableCreateISMCs;                                // 0x00AC(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AD[0x3];                                       // 0x00AD(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PatternTool_OutputSettings">();
	}
	static class UPatternTool_OutputSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPatternTool_OutputSettings>();
	}
};
static_assert(alignof(UPatternTool_OutputSettings) == 0x000008, "Wrong alignment on UPatternTool_OutputSettings");
static_assert(sizeof(UPatternTool_OutputSettings) == 0x0000B0, "Wrong size on UPatternTool_OutputSettings");
static_assert(offsetof(UPatternTool_OutputSettings, bSeparateActors) == 0x0000A8, "Member 'UPatternTool_OutputSettings::bSeparateActors' has a wrong offset!");
static_assert(offsetof(UPatternTool_OutputSettings, bConvertToDynamic) == 0x0000A9, "Member 'UPatternTool_OutputSettings::bConvertToDynamic' has a wrong offset!");
static_assert(offsetof(UPatternTool_OutputSettings, bCreateISMCs) == 0x0000AA, "Member 'UPatternTool_OutputSettings::bCreateISMCs' has a wrong offset!");
static_assert(offsetof(UPatternTool_OutputSettings, bHaveStaticMeshes) == 0x0000AB, "Member 'UPatternTool_OutputSettings::bHaveStaticMeshes' has a wrong offset!");
static_assert(offsetof(UPatternTool_OutputSettings, bEnableCreateISMCs) == 0x0000AC, "Member 'UPatternTool_OutputSettings::bEnableCreateISMCs' has a wrong offset!");

// Class MeshModelingToolsExp.OffsetMeshToolProperties
// 0x0010 (0x00B8 - 0x00A8)
class UOffsetMeshToolProperties final : public UInteractiveToolPropertySet
{
public:
	EOffsetMeshToolOffsetType                     OffsetType;                                        // 0x00A8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A9[0x3];                                       // 0x00A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Distance;                                          // 0x00AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCreateShell;                                      // 0x00B0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B1[0x7];                                       // 0x00B1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OffsetMeshToolProperties">();
	}
	static class UOffsetMeshToolProperties* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOffsetMeshToolProperties>();
	}
};
static_assert(alignof(UOffsetMeshToolProperties) == 0x000008, "Wrong alignment on UOffsetMeshToolProperties");
static_assert(sizeof(UOffsetMeshToolProperties) == 0x0000B8, "Wrong size on UOffsetMeshToolProperties");
static_assert(offsetof(UOffsetMeshToolProperties, OffsetType) == 0x0000A8, "Member 'UOffsetMeshToolProperties::OffsetType' has a wrong offset!");
static_assert(offsetof(UOffsetMeshToolProperties, Distance) == 0x0000AC, "Member 'UOffsetMeshToolProperties::Distance' has a wrong offset!");
static_assert(offsetof(UOffsetMeshToolProperties, bCreateShell) == 0x0000B0, "Member 'UOffsetMeshToolProperties::bCreateShell' has a wrong offset!");

// Class MeshModelingToolsExp.PatternTool
// 0x03F8 (0x04B0 - 0x00B8)
class alignas(0x10) UPatternTool final : public UMultiSelectionMeshEditingTool
{
public:
	class UPatternToolSettings*                   Settings;                                          // 0x00B8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPatternTool_BoundingBoxSettings*       BoundingBoxSettings;                               // 0x00C0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPatternTool_LinearSettings*            LinearSettings;                                    // 0x00C8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPatternTool_GridSettings*              GridSettings;                                      // 0x00D0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPatternTool_RadialSettings*            RadialSettings;                                    // 0x00D8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPatternTool_RotationSettings*          RotationSettings;                                  // 0x00E0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPatternTool_TranslationSettings*       TranslationSettings;                               // 0x00E8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPatternTool_ScaleSettings*             ScaleSettings;                                     // 0x00F0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F8[0x58];                                      // 0x00F8(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	class UPatternTool_OutputSettings*            OutputSettings;                                    // 0x0150(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_158[0x48];                                     // 0x0158(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	class UTransformProxy*                        PatternGizmoProxy;                                 // 0x01A0(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCombinedTransformGizmo*                PatternGizmo;                                      // 0x01A8(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1B0[0x18];                                     // 0x01B0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UDragAlignmentMechanic*                 DragAlignmentMechanic;                             // 0x01C8(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UConstructionPlaneMechanic*             PlaneMechanic;                                     // 0x01D0(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1D8[0x1E0];                                    // 0x01D8(0x01E0)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<class UPrimitiveComponent*>              AllComponents;                                     // 0x03B8(0x0050)(ExportObject, ContainsInstancedReference, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	uint8                                         Pad_408[0xA0];                                     // 0x0408(0x00A0)(Fixing Size After Last Property [ Dumper-7 ])
	class UPreviewGeometry*                       PreviewGeometry;                                   // 0x04A8(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PatternTool">();
	}
	static class UPatternTool* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPatternTool>();
	}
};
static_assert(alignof(UPatternTool) == 0x000010, "Wrong alignment on UPatternTool");
static_assert(sizeof(UPatternTool) == 0x0004B0, "Wrong size on UPatternTool");
static_assert(offsetof(UPatternTool, Settings) == 0x0000B8, "Member 'UPatternTool::Settings' has a wrong offset!");
static_assert(offsetof(UPatternTool, BoundingBoxSettings) == 0x0000C0, "Member 'UPatternTool::BoundingBoxSettings' has a wrong offset!");
static_assert(offsetof(UPatternTool, LinearSettings) == 0x0000C8, "Member 'UPatternTool::LinearSettings' has a wrong offset!");
static_assert(offsetof(UPatternTool, GridSettings) == 0x0000D0, "Member 'UPatternTool::GridSettings' has a wrong offset!");
static_assert(offsetof(UPatternTool, RadialSettings) == 0x0000D8, "Member 'UPatternTool::RadialSettings' has a wrong offset!");
static_assert(offsetof(UPatternTool, RotationSettings) == 0x0000E0, "Member 'UPatternTool::RotationSettings' has a wrong offset!");
static_assert(offsetof(UPatternTool, TranslationSettings) == 0x0000E8, "Member 'UPatternTool::TranslationSettings' has a wrong offset!");
static_assert(offsetof(UPatternTool, ScaleSettings) == 0x0000F0, "Member 'UPatternTool::ScaleSettings' has a wrong offset!");
static_assert(offsetof(UPatternTool, OutputSettings) == 0x000150, "Member 'UPatternTool::OutputSettings' has a wrong offset!");
static_assert(offsetof(UPatternTool, PatternGizmoProxy) == 0x0001A0, "Member 'UPatternTool::PatternGizmoProxy' has a wrong offset!");
static_assert(offsetof(UPatternTool, PatternGizmo) == 0x0001A8, "Member 'UPatternTool::PatternGizmo' has a wrong offset!");
static_assert(offsetof(UPatternTool, DragAlignmentMechanic) == 0x0001C8, "Member 'UPatternTool::DragAlignmentMechanic' has a wrong offset!");
static_assert(offsetof(UPatternTool, PlaneMechanic) == 0x0001D0, "Member 'UPatternTool::PlaneMechanic' has a wrong offset!");
static_assert(offsetof(UPatternTool, AllComponents) == 0x0003B8, "Member 'UPatternTool::AllComponents' has a wrong offset!");
static_assert(offsetof(UPatternTool, PreviewGeometry) == 0x0004A8, "Member 'UPatternTool::PreviewGeometry' has a wrong offset!");

// Class MeshModelingToolsExp.MeshConstraintProperties
// 0x0008 (0x00B0 - 0x00A8)
class UMeshConstraintProperties : public UInteractiveToolPropertySet
{
public:
	bool                                          bPreserveSharpEdges;                               // 0x00A8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMeshBoundaryConstraint                       MeshBoundaryConstraint;                            // 0x00A9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGroupBoundaryConstraint                      GroupBoundaryConstraint;                           // 0x00AA(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMaterialBoundaryConstraint                   MaterialBoundaryConstraint;                        // 0x00AB(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPreventNormalFlips;                               // 0x00AC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPreventTinyTriangles;                             // 0x00AD(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AE[0x2];                                       // 0x00AE(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool IsPreventNormalFlipsEnabled() const;
	bool IsPreventTinyTrianglesEnabled() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MeshConstraintProperties">();
	}
	static class UMeshConstraintProperties* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMeshConstraintProperties>();
	}
};
static_assert(alignof(UMeshConstraintProperties) == 0x000008, "Wrong alignment on UMeshConstraintProperties");
static_assert(sizeof(UMeshConstraintProperties) == 0x0000B0, "Wrong size on UMeshConstraintProperties");
static_assert(offsetof(UMeshConstraintProperties, bPreserveSharpEdges) == 0x0000A8, "Member 'UMeshConstraintProperties::bPreserveSharpEdges' has a wrong offset!");
static_assert(offsetof(UMeshConstraintProperties, MeshBoundaryConstraint) == 0x0000A9, "Member 'UMeshConstraintProperties::MeshBoundaryConstraint' has a wrong offset!");
static_assert(offsetof(UMeshConstraintProperties, GroupBoundaryConstraint) == 0x0000AA, "Member 'UMeshConstraintProperties::GroupBoundaryConstraint' has a wrong offset!");
static_assert(offsetof(UMeshConstraintProperties, MaterialBoundaryConstraint) == 0x0000AB, "Member 'UMeshConstraintProperties::MaterialBoundaryConstraint' has a wrong offset!");
static_assert(offsetof(UMeshConstraintProperties, bPreventNormalFlips) == 0x0000AC, "Member 'UMeshConstraintProperties::bPreventNormalFlips' has a wrong offset!");
static_assert(offsetof(UMeshConstraintProperties, bPreventTinyTriangles) == 0x0000AD, "Member 'UMeshConstraintProperties::bPreventTinyTriangles' has a wrong offset!");

// Class MeshModelingToolsExp.MeshVertexSculptTool
// 0x0960 (0x1500 - 0x0BA0)
class UMeshVertexSculptTool final : public UMeshSculptToolBase
{
public:
	uint8                                         Pad_BA0[0x8];                                      // 0x0BA0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UVertexBrushSculptProperties*           SculptProperties;                                  // 0x0BA8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVertexBrushAlphaProperties*            AlphaProperties;                                   // 0x0BB0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             BrushAlpha;                                        // 0x0BB8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMeshSymmetryProperties*                SymmetryProperties;                                // 0x0BC0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BC8[0x18];                                     // 0x0BC8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class AInternalToolFrameworkActor*            PreviewMeshActor;                                  // 0x0BE0(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDynamicMeshComponent*                  DynamicMeshComponent;                              // 0x0BE8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_BF0[0x910];                                    // 0x0BF0(0x0910)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MeshVertexSculptTool">();
	}
	static class UMeshVertexSculptTool* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMeshVertexSculptTool>();
	}
};
static_assert(alignof(UMeshVertexSculptTool) == 0x000010, "Wrong alignment on UMeshVertexSculptTool");
static_assert(sizeof(UMeshVertexSculptTool) == 0x001500, "Wrong size on UMeshVertexSculptTool");
static_assert(offsetof(UMeshVertexSculptTool, SculptProperties) == 0x000BA8, "Member 'UMeshVertexSculptTool::SculptProperties' has a wrong offset!");
static_assert(offsetof(UMeshVertexSculptTool, AlphaProperties) == 0x000BB0, "Member 'UMeshVertexSculptTool::AlphaProperties' has a wrong offset!");
static_assert(offsetof(UMeshVertexSculptTool, BrushAlpha) == 0x000BB8, "Member 'UMeshVertexSculptTool::BrushAlpha' has a wrong offset!");
static_assert(offsetof(UMeshVertexSculptTool, SymmetryProperties) == 0x000BC0, "Member 'UMeshVertexSculptTool::SymmetryProperties' has a wrong offset!");
static_assert(offsetof(UMeshVertexSculptTool, PreviewMeshActor) == 0x000BE0, "Member 'UMeshVertexSculptTool::PreviewMeshActor' has a wrong offset!");
static_assert(offsetof(UMeshVertexSculptTool, DynamicMeshComponent) == 0x000BE8, "Member 'UMeshVertexSculptTool::DynamicMeshComponent' has a wrong offset!");

// Class MeshModelingToolsExp.RemeshProperties
// 0x0008 (0x00B8 - 0x00B0)
class URemeshProperties : public UMeshConstraintProperties
{
public:
	float                                         SmoothingStrength;                                 // 0x00B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFlips;                                            // 0x00B4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSplits;                                           // 0x00B5(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCollapses;                                        // 0x00B6(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B7[0x1];                                       // 0x00B7(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RemeshProperties">();
	}
	static class URemeshProperties* GetDefaultObj()
	{
		return GetDefaultObjImpl<URemeshProperties>();
	}
};
static_assert(alignof(URemeshProperties) == 0x000008, "Wrong alignment on URemeshProperties");
static_assert(sizeof(URemeshProperties) == 0x0000B8, "Wrong size on URemeshProperties");
static_assert(offsetof(URemeshProperties, SmoothingStrength) == 0x0000B0, "Member 'URemeshProperties::SmoothingStrength' has a wrong offset!");
static_assert(offsetof(URemeshProperties, bFlips) == 0x0000B4, "Member 'URemeshProperties::bFlips' has a wrong offset!");
static_assert(offsetof(URemeshProperties, bSplits) == 0x0000B5, "Member 'URemeshProperties::bSplits' has a wrong offset!");
static_assert(offsetof(URemeshProperties, bCollapses) == 0x0000B6, "Member 'URemeshProperties::bCollapses' has a wrong offset!");

// Class MeshModelingToolsExp.RevolveSplineToolProperties
// 0x0050 (0x0168 - 0x0118)
class URevolveSplineToolProperties final : public URevolveProperties
{
public:
	ERevolveSplineSampleMode                      SampleMode;                                        // 0x0118(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_119[0x7];                                      // 0x0119(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        ErrorTolerance;                                    // 0x0120(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        MaxSampleDistance;                                 // 0x0128(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERevolvePropertiesCapFillMode                 CapFillMode;                                       // 0x0130(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bClosePathToAxis;                                  // 0x0131(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_132[0x6];                                      // 0x0132(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                AxisOrigin;                                        // 0x0138(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              AxisOrientation;                                   // 0x0150(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bResetAxisOnStart;                                 // 0x0160(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_161[0x7];                                      // 0x0161(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RevolveSplineToolProperties">();
	}
	static class URevolveSplineToolProperties* GetDefaultObj()
	{
		return GetDefaultObjImpl<URevolveSplineToolProperties>();
	}
};
static_assert(alignof(URevolveSplineToolProperties) == 0x000008, "Wrong alignment on URevolveSplineToolProperties");
static_assert(sizeof(URevolveSplineToolProperties) == 0x000168, "Wrong size on URevolveSplineToolProperties");
static_assert(offsetof(URevolveSplineToolProperties, SampleMode) == 0x000118, "Member 'URevolveSplineToolProperties::SampleMode' has a wrong offset!");
static_assert(offsetof(URevolveSplineToolProperties, ErrorTolerance) == 0x000120, "Member 'URevolveSplineToolProperties::ErrorTolerance' has a wrong offset!");
static_assert(offsetof(URevolveSplineToolProperties, MaxSampleDistance) == 0x000128, "Member 'URevolveSplineToolProperties::MaxSampleDistance' has a wrong offset!");
static_assert(offsetof(URevolveSplineToolProperties, CapFillMode) == 0x000130, "Member 'URevolveSplineToolProperties::CapFillMode' has a wrong offset!");
static_assert(offsetof(URevolveSplineToolProperties, bClosePathToAxis) == 0x000131, "Member 'URevolveSplineToolProperties::bClosePathToAxis' has a wrong offset!");
static_assert(offsetof(URevolveSplineToolProperties, AxisOrigin) == 0x000138, "Member 'URevolveSplineToolProperties::AxisOrigin' has a wrong offset!");
static_assert(offsetof(URevolveSplineToolProperties, AxisOrientation) == 0x000150, "Member 'URevolveSplineToolProperties::AxisOrientation' has a wrong offset!");
static_assert(offsetof(URevolveSplineToolProperties, bResetAxisOnStart) == 0x000160, "Member 'URevolveSplineToolProperties::bResetAxisOnStart' has a wrong offset!");

// Class MeshModelingToolsExp.MeshVertexPaintToolActionPropertySet
// 0x0008 (0x00B0 - 0x00A8)
class UMeshVertexPaintToolActionPropertySet : public UInteractiveToolPropertySet
{
public:
	uint8                                         Pad_A8[0x8];                                       // 0x00A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MeshVertexPaintToolActionPropertySet">();
	}
	static class UMeshVertexPaintToolActionPropertySet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMeshVertexPaintToolActionPropertySet>();
	}
};
static_assert(alignof(UMeshVertexPaintToolActionPropertySet) == 0x000008, "Wrong alignment on UMeshVertexPaintToolActionPropertySet");
static_assert(sizeof(UMeshVertexPaintToolActionPropertySet) == 0x0000B0, "Wrong size on UMeshVertexPaintToolActionPropertySet");

// Class MeshModelingToolsExp.MeshVertexPaintToolUtilityActions
// 0x0050 (0x0100 - 0x00B0)
class UMeshVertexPaintToolUtilityActions final : public UMeshVertexPaintToolActionPropertySet
{
public:
	EMeshVertexPaintToolUtilityOperations         Operation;                                         // 0x00B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMeshVertexPaintColorChannel                  SourceChannel;                                     // 0x00B4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B5[0x3];                                       // 0x00B5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SourceValue;                                       // 0x00B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   WeightMap;                                         // 0x00BC(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C4[0x4];                                       // 0x00C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         WeightMapsList;                                    // 0x00C8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FModelingToolsColorChannelFilter       TargetChannels;                                    // 0x00D8(0x0004)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	EMeshVertexPaintColorChannel                  TargetChannel;                                     // 0x00DC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCopyToHiRes;                                      // 0x00DD(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DE[0x2];                                       // 0x00DE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 CopyToLODName;                                     // 0x00E0(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         LODNamesList;                                      // 0x00F0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void ApplySelectedOperation();
	TArray<class FString> GetWeightMapsFunc();

	const TArray<class FString> GetLODNamesFunc() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MeshVertexPaintToolUtilityActions">();
	}
	static class UMeshVertexPaintToolUtilityActions* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMeshVertexPaintToolUtilityActions>();
	}
};
static_assert(alignof(UMeshVertexPaintToolUtilityActions) == 0x000008, "Wrong alignment on UMeshVertexPaintToolUtilityActions");
static_assert(sizeof(UMeshVertexPaintToolUtilityActions) == 0x000100, "Wrong size on UMeshVertexPaintToolUtilityActions");
static_assert(offsetof(UMeshVertexPaintToolUtilityActions, Operation) == 0x0000B0, "Member 'UMeshVertexPaintToolUtilityActions::Operation' has a wrong offset!");
static_assert(offsetof(UMeshVertexPaintToolUtilityActions, SourceChannel) == 0x0000B4, "Member 'UMeshVertexPaintToolUtilityActions::SourceChannel' has a wrong offset!");
static_assert(offsetof(UMeshVertexPaintToolUtilityActions, SourceValue) == 0x0000B8, "Member 'UMeshVertexPaintToolUtilityActions::SourceValue' has a wrong offset!");
static_assert(offsetof(UMeshVertexPaintToolUtilityActions, WeightMap) == 0x0000BC, "Member 'UMeshVertexPaintToolUtilityActions::WeightMap' has a wrong offset!");
static_assert(offsetof(UMeshVertexPaintToolUtilityActions, WeightMapsList) == 0x0000C8, "Member 'UMeshVertexPaintToolUtilityActions::WeightMapsList' has a wrong offset!");
static_assert(offsetof(UMeshVertexPaintToolUtilityActions, TargetChannels) == 0x0000D8, "Member 'UMeshVertexPaintToolUtilityActions::TargetChannels' has a wrong offset!");
static_assert(offsetof(UMeshVertexPaintToolUtilityActions, TargetChannel) == 0x0000DC, "Member 'UMeshVertexPaintToolUtilityActions::TargetChannel' has a wrong offset!");
static_assert(offsetof(UMeshVertexPaintToolUtilityActions, bCopyToHiRes) == 0x0000DD, "Member 'UMeshVertexPaintToolUtilityActions::bCopyToHiRes' has a wrong offset!");
static_assert(offsetof(UMeshVertexPaintToolUtilityActions, CopyToLODName) == 0x0000E0, "Member 'UMeshVertexPaintToolUtilityActions::CopyToLODName' has a wrong offset!");
static_assert(offsetof(UMeshVertexPaintToolUtilityActions, LODNamesList) == 0x0000F0, "Member 'UMeshVertexPaintToolUtilityActions::LODNamesList' has a wrong offset!");

// Class MeshModelingToolsExp.RevolveSplineToolActionPropertySet
// 0x0008 (0x00B0 - 0x00A8)
class URevolveSplineToolActionPropertySet final : public UInteractiveToolPropertySet
{
public:
	uint8                                         Pad_A8[0x8];                                       // 0x00A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ResetAxis();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RevolveSplineToolActionPropertySet">();
	}
	static class URevolveSplineToolActionPropertySet* GetDefaultObj()
	{
		return GetDefaultObjImpl<URevolveSplineToolActionPropertySet>();
	}
};
static_assert(alignof(URevolveSplineToolActionPropertySet) == 0x000008, "Wrong alignment on URevolveSplineToolActionPropertySet");
static_assert(sizeof(URevolveSplineToolActionPropertySet) == 0x0000B0, "Wrong size on URevolveSplineToolActionPropertySet");

// Class MeshModelingToolsExp.RevolveSplineTool
// 0x00E0 (0x0178 - 0x0098)
class URevolveSplineTool final : public UInteractiveTool
{
public:
	uint8                                         Pad_98[0x10];                                      // 0x0098(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class URevolveSplineToolProperties*           Settings;                                          // 0x00A8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UNewMeshMaterialProperties*             MaterialProperties;                                // 0x00B0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCreateMeshObjectTypeProperties*        OutputTypeProperties;                              // 0x00B8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class URevolveSplineToolActionPropertySet*    ToolActions;                                       // 0x00C0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMeshOpPreviewWithBackgroundCompute*    Preview;                                           // 0x00C8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UConstructionPlaneMechanic*             PlaneMechanic;                                     // 0x00D0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D8[0xA0];                                      // 0x00D8(0x00A0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RevolveSplineTool">();
	}
	static class URevolveSplineTool* GetDefaultObj()
	{
		return GetDefaultObjImpl<URevolveSplineTool>();
	}
};
static_assert(alignof(URevolveSplineTool) == 0x000008, "Wrong alignment on URevolveSplineTool");
static_assert(sizeof(URevolveSplineTool) == 0x000178, "Wrong size on URevolveSplineTool");
static_assert(offsetof(URevolveSplineTool, Settings) == 0x0000A8, "Member 'URevolveSplineTool::Settings' has a wrong offset!");
static_assert(offsetof(URevolveSplineTool, MaterialProperties) == 0x0000B0, "Member 'URevolveSplineTool::MaterialProperties' has a wrong offset!");
static_assert(offsetof(URevolveSplineTool, OutputTypeProperties) == 0x0000B8, "Member 'URevolveSplineTool::OutputTypeProperties' has a wrong offset!");
static_assert(offsetof(URevolveSplineTool, ToolActions) == 0x0000C0, "Member 'URevolveSplineTool::ToolActions' has a wrong offset!");
static_assert(offsetof(URevolveSplineTool, Preview) == 0x0000C8, "Member 'URevolveSplineTool::Preview' has a wrong offset!");
static_assert(offsetof(URevolveSplineTool, PlaneMechanic) == 0x0000D0, "Member 'URevolveSplineTool::PlaneMechanic' has a wrong offset!");

// Class MeshModelingToolsExp.MirrorToolActionPropertySet
// 0x0010 (0x00B8 - 0x00A8)
class UMirrorToolActionPropertySet final : public UInteractiveToolPropertySet
{
public:
	uint8                                         Pad_A8[0x8];                                       // 0x00A8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bButtonsOnlyChangeOrientation;                     // 0x00B0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B1[0x7];                                       // 0x00B1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Backward();
	void Down();
	void Forward();
	void Left();
	void Right();
	void ShiftToCenter();
	void Up();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MirrorToolActionPropertySet">();
	}
	static class UMirrorToolActionPropertySet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMirrorToolActionPropertySet>();
	}
};
static_assert(alignof(UMirrorToolActionPropertySet) == 0x000008, "Wrong alignment on UMirrorToolActionPropertySet");
static_assert(sizeof(UMirrorToolActionPropertySet) == 0x0000B8, "Wrong size on UMirrorToolActionPropertySet");
static_assert(offsetof(UMirrorToolActionPropertySet, bButtonsOnlyChangeOrientation) == 0x0000B0, "Member 'UMirrorToolActionPropertySet::bButtonsOnlyChangeOrientation' has a wrong offset!");

// Class MeshModelingToolsExp.RevolveSplineToolBuilder
// 0x0000 (0x0028 - 0x0028)
class URevolveSplineToolBuilder final : public UInteractiveToolBuilder
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RevolveSplineToolBuilder">();
	}
	static class URevolveSplineToolBuilder* GetDefaultObj()
	{
		return GetDefaultObjImpl<URevolveSplineToolBuilder>();
	}
};
static_assert(alignof(URevolveSplineToolBuilder) == 0x000008, "Wrong alignment on URevolveSplineToolBuilder");
static_assert(sizeof(URevolveSplineToolBuilder) == 0x000028, "Wrong size on URevolveSplineToolBuilder");

// Class MeshModelingToolsExp.AddPatchToolBuilder
// 0x0000 (0x0028 - 0x0028)
class UAddPatchToolBuilder final : public UInteractiveToolBuilder
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AddPatchToolBuilder">();
	}
	static class UAddPatchToolBuilder* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAddPatchToolBuilder>();
	}
};
static_assert(alignof(UAddPatchToolBuilder) == 0x000008, "Wrong alignment on UAddPatchToolBuilder");
static_assert(sizeof(UAddPatchToolBuilder) == 0x000028, "Wrong size on UAddPatchToolBuilder");

// Class MeshModelingToolsExp.ExtractCollisionGeometryToolBuilder
// 0x0000 (0x0028 - 0x0028)
class UExtractCollisionGeometryToolBuilder final : public USingleSelectionMeshEditingToolBuilder
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ExtractCollisionGeometryToolBuilder">();
	}
	static class UExtractCollisionGeometryToolBuilder* GetDefaultObj()
	{
		return GetDefaultObjImpl<UExtractCollisionGeometryToolBuilder>();
	}
};
static_assert(alignof(UExtractCollisionGeometryToolBuilder) == 0x000008, "Wrong alignment on UExtractCollisionGeometryToolBuilder");
static_assert(sizeof(UExtractCollisionGeometryToolBuilder) == 0x000028, "Wrong size on UExtractCollisionGeometryToolBuilder");

// Class MeshModelingToolsExp.AddPatchToolProperties
// 0x0010 (0x00B8 - 0x00A8)
class UAddPatchToolProperties final : public UInteractiveToolPropertySet
{
public:
	float                                         Width;                                             // 0x00A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Rotation;                                          // 0x00AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Subdivisions;                                      // 0x00B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Shift;                                             // 0x00B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AddPatchToolProperties">();
	}
	static class UAddPatchToolProperties* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAddPatchToolProperties>();
	}
};
static_assert(alignof(UAddPatchToolProperties) == 0x000008, "Wrong alignment on UAddPatchToolProperties");
static_assert(sizeof(UAddPatchToolProperties) == 0x0000B8, "Wrong size on UAddPatchToolProperties");
static_assert(offsetof(UAddPatchToolProperties, Width) == 0x0000A8, "Member 'UAddPatchToolProperties::Width' has a wrong offset!");
static_assert(offsetof(UAddPatchToolProperties, Rotation) == 0x0000AC, "Member 'UAddPatchToolProperties::Rotation' has a wrong offset!");
static_assert(offsetof(UAddPatchToolProperties, Subdivisions) == 0x0000B0, "Member 'UAddPatchToolProperties::Subdivisions' has a wrong offset!");
static_assert(offsetof(UAddPatchToolProperties, Shift) == 0x0000B4, "Member 'UAddPatchToolProperties::Shift' has a wrong offset!");

// Class MeshModelingToolsExp.AddPatchTool
// 0x0088 (0x0128 - 0x00A0)
class UAddPatchTool final : public USingleClickTool
{
public:
	uint8                                         Pad_A0[0x8];                                       // 0x00A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UAddPatchToolProperties*                ShapeSettings;                                     // 0x00A8(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNewMeshMaterialProperties*             MaterialProperties;                                // 0x00B0(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPreviewMesh*                           PreviewMesh;                                       // 0x00B8(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C0[0x68];                                      // 0x00C0(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AddPatchTool">();
	}
	static class UAddPatchTool* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAddPatchTool>();
	}
};
static_assert(alignof(UAddPatchTool) == 0x000008, "Wrong alignment on UAddPatchTool");
static_assert(sizeof(UAddPatchTool) == 0x000128, "Wrong size on UAddPatchTool");
static_assert(offsetof(UAddPatchTool, ShapeSettings) == 0x0000A8, "Member 'UAddPatchTool::ShapeSettings' has a wrong offset!");
static_assert(offsetof(UAddPatchTool, MaterialProperties) == 0x0000B0, "Member 'UAddPatchTool::MaterialProperties' has a wrong offset!");
static_assert(offsetof(UAddPatchTool, PreviewMesh) == 0x0000B8, "Member 'UAddPatchTool::PreviewMesh' has a wrong offset!");

// Class MeshModelingToolsExp.IterativeOffsetProperties
// 0x0010 (0x00B8 - 0x00A8)
class UIterativeOffsetProperties final : public UInteractiveToolPropertySet
{
public:
	int32                                         Steps;                                             // 0x00A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOffsetBoundaries;                                 // 0x00AC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AD[0x3];                                       // 0x00AD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SmoothingPerStep;                                  // 0x00B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bReprojectSmooth;                                  // 0x00B4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B5[0x3];                                       // 0x00B5(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IterativeOffsetProperties">();
	}
	static class UIterativeOffsetProperties* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIterativeOffsetProperties>();
	}
};
static_assert(alignof(UIterativeOffsetProperties) == 0x000008, "Wrong alignment on UIterativeOffsetProperties");
static_assert(sizeof(UIterativeOffsetProperties) == 0x0000B8, "Wrong size on UIterativeOffsetProperties");
static_assert(offsetof(UIterativeOffsetProperties, Steps) == 0x0000A8, "Member 'UIterativeOffsetProperties::Steps' has a wrong offset!");
static_assert(offsetof(UIterativeOffsetProperties, bOffsetBoundaries) == 0x0000AC, "Member 'UIterativeOffsetProperties::bOffsetBoundaries' has a wrong offset!");
static_assert(offsetof(UIterativeOffsetProperties, SmoothingPerStep) == 0x0000B0, "Member 'UIterativeOffsetProperties::SmoothingPerStep' has a wrong offset!");
static_assert(offsetof(UIterativeOffsetProperties, bReprojectSmooth) == 0x0000B4, "Member 'UIterativeOffsetProperties::bReprojectSmooth' has a wrong offset!");

// Class MeshModelingToolsExp.AlignObjectsToolBuilder
// 0x0000 (0x0028 - 0x0028)
class UAlignObjectsToolBuilder final : public UMultiSelectionMeshEditingToolBuilder
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AlignObjectsToolBuilder">();
	}
	static class UAlignObjectsToolBuilder* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAlignObjectsToolBuilder>();
	}
};
static_assert(alignof(UAlignObjectsToolBuilder) == 0x000008, "Wrong alignment on UAlignObjectsToolBuilder");
static_assert(sizeof(UAlignObjectsToolBuilder) == 0x000028, "Wrong size on UAlignObjectsToolBuilder");

// Class MeshModelingToolsExp.AlignObjectsToolProperties
// 0x0010 (0x00B8 - 0x00A8)
class UAlignObjectsToolProperties final : public UInteractiveToolPropertySet
{
public:
	EAlignObjectsAlignTypes                       AlignType;                                         // 0x00A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAlignObjectsAlignToOptions                   AlignTo;                                           // 0x00AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAlignObjectsBoxPoint                         BoxPosition;                                       // 0x00B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAlignX;                                           // 0x00B4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAlignY;                                           // 0x00B5(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAlignZ;                                           // 0x00B6(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B7[0x1];                                       // 0x00B7(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AlignObjectsToolProperties">();
	}
	static class UAlignObjectsToolProperties* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAlignObjectsToolProperties>();
	}
};
static_assert(alignof(UAlignObjectsToolProperties) == 0x000008, "Wrong alignment on UAlignObjectsToolProperties");
static_assert(sizeof(UAlignObjectsToolProperties) == 0x0000B8, "Wrong size on UAlignObjectsToolProperties");
static_assert(offsetof(UAlignObjectsToolProperties, AlignType) == 0x0000A8, "Member 'UAlignObjectsToolProperties::AlignType' has a wrong offset!");
static_assert(offsetof(UAlignObjectsToolProperties, AlignTo) == 0x0000AC, "Member 'UAlignObjectsToolProperties::AlignTo' has a wrong offset!");
static_assert(offsetof(UAlignObjectsToolProperties, BoxPosition) == 0x0000B0, "Member 'UAlignObjectsToolProperties::BoxPosition' has a wrong offset!");
static_assert(offsetof(UAlignObjectsToolProperties, bAlignX) == 0x0000B4, "Member 'UAlignObjectsToolProperties::bAlignX' has a wrong offset!");
static_assert(offsetof(UAlignObjectsToolProperties, bAlignY) == 0x0000B5, "Member 'UAlignObjectsToolProperties::bAlignY' has a wrong offset!");
static_assert(offsetof(UAlignObjectsToolProperties, bAlignZ) == 0x0000B6, "Member 'UAlignObjectsToolProperties::bAlignZ' has a wrong offset!");

// Class MeshModelingToolsExp.MirrorToolProperties
// 0x0018 (0x00C0 - 0x00A8)
class UMirrorToolProperties final : public UInteractiveToolPropertySet
{
public:
	EMirrorOperationMode                          OperationMode;                                     // 0x00A8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCropAlongMirrorPlaneFirst;                        // 0x00A9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSimplifyAlongCrop;                                // 0x00AA(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWeldVerticesOnMirrorPlane;                        // 0x00AB(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AC[0x4];                                       // 0x00AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        PlaneTolerance;                                    // 0x00B0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowBowtieVertexCreation;                        // 0x00B8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowPreview;                                      // 0x00B9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMirrorSaveMode                               WriteTo;                                           // 0x00BA(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BB[0x5];                                       // 0x00BB(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MirrorToolProperties">();
	}
	static class UMirrorToolProperties* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMirrorToolProperties>();
	}
};
static_assert(alignof(UMirrorToolProperties) == 0x000008, "Wrong alignment on UMirrorToolProperties");
static_assert(sizeof(UMirrorToolProperties) == 0x0000C0, "Wrong size on UMirrorToolProperties");
static_assert(offsetof(UMirrorToolProperties, OperationMode) == 0x0000A8, "Member 'UMirrorToolProperties::OperationMode' has a wrong offset!");
static_assert(offsetof(UMirrorToolProperties, bCropAlongMirrorPlaneFirst) == 0x0000A9, "Member 'UMirrorToolProperties::bCropAlongMirrorPlaneFirst' has a wrong offset!");
static_assert(offsetof(UMirrorToolProperties, bSimplifyAlongCrop) == 0x0000AA, "Member 'UMirrorToolProperties::bSimplifyAlongCrop' has a wrong offset!");
static_assert(offsetof(UMirrorToolProperties, bWeldVerticesOnMirrorPlane) == 0x0000AB, "Member 'UMirrorToolProperties::bWeldVerticesOnMirrorPlane' has a wrong offset!");
static_assert(offsetof(UMirrorToolProperties, PlaneTolerance) == 0x0000B0, "Member 'UMirrorToolProperties::PlaneTolerance' has a wrong offset!");
static_assert(offsetof(UMirrorToolProperties, bAllowBowtieVertexCreation) == 0x0000B8, "Member 'UMirrorToolProperties::bAllowBowtieVertexCreation' has a wrong offset!");
static_assert(offsetof(UMirrorToolProperties, bShowPreview) == 0x0000B9, "Member 'UMirrorToolProperties::bShowPreview' has a wrong offset!");
static_assert(offsetof(UMirrorToolProperties, WriteTo) == 0x0000BA, "Member 'UMirrorToolProperties::WriteTo' has a wrong offset!");

// Class MeshModelingToolsExp.AlignObjectsTool
// 0x00A0 (0x0158 - 0x00B8)
class UAlignObjectsTool final : public UMultiSelectionMeshEditingTool
{
public:
	uint8                                         Pad_B8[0x8];                                       // 0x00B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UAlignObjectsToolProperties*            AlignProps;                                        // 0x00C0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C8[0x90];                                      // 0x00C8(0x0090)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AlignObjectsTool">();
	}
	static class UAlignObjectsTool* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAlignObjectsTool>();
	}
};
static_assert(alignof(UAlignObjectsTool) == 0x000008, "Wrong alignment on UAlignObjectsTool");
static_assert(sizeof(UAlignObjectsTool) == 0x000158, "Wrong size on UAlignObjectsTool");
static_assert(offsetof(UAlignObjectsTool, AlignProps) == 0x0000C0, "Member 'UAlignObjectsTool::AlignProps' has a wrong offset!");

// Class MeshModelingToolsExp.BakeMeshAttributeMapsToolBuilder
// 0x0000 (0x0028 - 0x0028)
class UBakeMeshAttributeMapsToolBuilder final : public UMultiSelectionMeshEditingToolBuilder
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BakeMeshAttributeMapsToolBuilder">();
	}
	static class UBakeMeshAttributeMapsToolBuilder* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBakeMeshAttributeMapsToolBuilder>();
	}
};
static_assert(alignof(UBakeMeshAttributeMapsToolBuilder) == 0x000008, "Wrong alignment on UBakeMeshAttributeMapsToolBuilder");
static_assert(sizeof(UBakeMeshAttributeMapsToolBuilder) == 0x000028, "Wrong size on UBakeMeshAttributeMapsToolBuilder");

// Class MeshModelingToolsExp.PhysicsObjectToolPropertySet
// 0x0068 (0x0110 - 0x00A8)
class UPhysicsObjectToolPropertySet final : public UInteractiveToolPropertySet
{
public:
	class FString                                 ObjectName;                                        // 0x00A8(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionGeometryMode                        CollisionType;                                     // 0x00B8(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BC[0x4];                                       // 0x00BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FPhysicsSphereData>             Spheres;                                           // 0x00C0(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TArray<struct FPhysicsBoxData>                Boxes;                                             // 0x00D0(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TArray<struct FPhysicsCapsuleData>            Capsules;                                          // 0x00E0(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TArray<struct FPhysicsConvexData>             Convexes;                                          // 0x00F0(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TArray<struct FPhysicsLevelSetData>           LevelSets;                                         // 0x0100(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PhysicsObjectToolPropertySet">();
	}
	static class UPhysicsObjectToolPropertySet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPhysicsObjectToolPropertySet>();
	}
};
static_assert(alignof(UPhysicsObjectToolPropertySet) == 0x000008, "Wrong alignment on UPhysicsObjectToolPropertySet");
static_assert(sizeof(UPhysicsObjectToolPropertySet) == 0x000110, "Wrong size on UPhysicsObjectToolPropertySet");
static_assert(offsetof(UPhysicsObjectToolPropertySet, ObjectName) == 0x0000A8, "Member 'UPhysicsObjectToolPropertySet::ObjectName' has a wrong offset!");
static_assert(offsetof(UPhysicsObjectToolPropertySet, CollisionType) == 0x0000B8, "Member 'UPhysicsObjectToolPropertySet::CollisionType' has a wrong offset!");
static_assert(offsetof(UPhysicsObjectToolPropertySet, Spheres) == 0x0000C0, "Member 'UPhysicsObjectToolPropertySet::Spheres' has a wrong offset!");
static_assert(offsetof(UPhysicsObjectToolPropertySet, Boxes) == 0x0000D0, "Member 'UPhysicsObjectToolPropertySet::Boxes' has a wrong offset!");
static_assert(offsetof(UPhysicsObjectToolPropertySet, Capsules) == 0x0000E0, "Member 'UPhysicsObjectToolPropertySet::Capsules' has a wrong offset!");
static_assert(offsetof(UPhysicsObjectToolPropertySet, Convexes) == 0x0000F0, "Member 'UPhysicsObjectToolPropertySet::Convexes' has a wrong offset!");
static_assert(offsetof(UPhysicsObjectToolPropertySet, LevelSets) == 0x000100, "Member 'UPhysicsObjectToolPropertySet::LevelSets' has a wrong offset!");

// Class MeshModelingToolsExp.BakeMeshAttributeMapsToolProperties
// 0x0090 (0x0138 - 0x00A8)
class UBakeMeshAttributeMapsToolProperties final : public UInteractiveToolPropertySet
{
public:
	int32                                         MapTypes;                                          // 0x00A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AC[0x4];                                       // 0x00AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 MapPreview;                                        // 0x00B0(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBakeTextureResolution                        Resolution;                                        // 0x00C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBakeTextureBitDepth                          BitDepth;                                          // 0x00C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBakeTextureSamplesPerPixel                   SamplesPerPixel;                                   // 0x00C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CC[0x4];                                       // 0x00CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             SampleFilterMask;                                  // 0x00D0(0x0008)(Edit, ZeroConstructor, NoDestructor, AdvancedDisplay, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         MapPreviewNamesList;                               // 0x00D8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_E8[0x50];                                      // 0x00E8(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	const TArray<class FString> GetMapPreviewNamesFunc();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BakeMeshAttributeMapsToolProperties">();
	}
	static class UBakeMeshAttributeMapsToolProperties* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBakeMeshAttributeMapsToolProperties>();
	}
};
static_assert(alignof(UBakeMeshAttributeMapsToolProperties) == 0x000008, "Wrong alignment on UBakeMeshAttributeMapsToolProperties");
static_assert(sizeof(UBakeMeshAttributeMapsToolProperties) == 0x000138, "Wrong size on UBakeMeshAttributeMapsToolProperties");
static_assert(offsetof(UBakeMeshAttributeMapsToolProperties, MapTypes) == 0x0000A8, "Member 'UBakeMeshAttributeMapsToolProperties::MapTypes' has a wrong offset!");
static_assert(offsetof(UBakeMeshAttributeMapsToolProperties, MapPreview) == 0x0000B0, "Member 'UBakeMeshAttributeMapsToolProperties::MapPreview' has a wrong offset!");
static_assert(offsetof(UBakeMeshAttributeMapsToolProperties, Resolution) == 0x0000C0, "Member 'UBakeMeshAttributeMapsToolProperties::Resolution' has a wrong offset!");
static_assert(offsetof(UBakeMeshAttributeMapsToolProperties, BitDepth) == 0x0000C4, "Member 'UBakeMeshAttributeMapsToolProperties::BitDepth' has a wrong offset!");
static_assert(offsetof(UBakeMeshAttributeMapsToolProperties, SamplesPerPixel) == 0x0000C8, "Member 'UBakeMeshAttributeMapsToolProperties::SamplesPerPixel' has a wrong offset!");
static_assert(offsetof(UBakeMeshAttributeMapsToolProperties, SampleFilterMask) == 0x0000D0, "Member 'UBakeMeshAttributeMapsToolProperties::SampleFilterMask' has a wrong offset!");
static_assert(offsetof(UBakeMeshAttributeMapsToolProperties, MapPreviewNamesList) == 0x0000D8, "Member 'UBakeMeshAttributeMapsToolProperties::MapPreviewNamesList' has a wrong offset!");

// Class MeshModelingToolsExp.BakeMeshAttributeTool
// 0x00F0 (0x01A8 - 0x00B8)
class UBakeMeshAttributeTool : public UMultiSelectionMeshEditingTool
{
public:
	uint8                                         Pad_B8[0x10];                                      // 0x00B8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UBakeOcclusionMapToolProperties*        OcclusionSettings;                                 // 0x00C8(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBakeCurvatureMapToolProperties*        CurvatureSettings;                                 // 0x00D0(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBakeTexture2DProperties*               TextureSettings;                                   // 0x00D8(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBakeMultiTexture2DProperties*          MultiTextureSettings;                              // 0x00E0(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstanceDynamic*               WorkingPreviewMaterial;                            // 0x00E8(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstanceDynamic*               ErrorPreviewMaterial;                              // 0x00F0(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_F8[0xB0];                                      // 0x00F8(0x00B0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BakeMeshAttributeTool">();
	}
	static class UBakeMeshAttributeTool* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBakeMeshAttributeTool>();
	}
};
static_assert(alignof(UBakeMeshAttributeTool) == 0x000008, "Wrong alignment on UBakeMeshAttributeTool");
static_assert(sizeof(UBakeMeshAttributeTool) == 0x0001A8, "Wrong size on UBakeMeshAttributeTool");
static_assert(offsetof(UBakeMeshAttributeTool, OcclusionSettings) == 0x0000C8, "Member 'UBakeMeshAttributeTool::OcclusionSettings' has a wrong offset!");
static_assert(offsetof(UBakeMeshAttributeTool, CurvatureSettings) == 0x0000D0, "Member 'UBakeMeshAttributeTool::CurvatureSettings' has a wrong offset!");
static_assert(offsetof(UBakeMeshAttributeTool, TextureSettings) == 0x0000D8, "Member 'UBakeMeshAttributeTool::TextureSettings' has a wrong offset!");
static_assert(offsetof(UBakeMeshAttributeTool, MultiTextureSettings) == 0x0000E0, "Member 'UBakeMeshAttributeTool::MultiTextureSettings' has a wrong offset!");
static_assert(offsetof(UBakeMeshAttributeTool, WorkingPreviewMaterial) == 0x0000E8, "Member 'UBakeMeshAttributeTool::WorkingPreviewMaterial' has a wrong offset!");
static_assert(offsetof(UBakeMeshAttributeTool, ErrorPreviewMaterial) == 0x0000F0, "Member 'UBakeMeshAttributeTool::ErrorPreviewMaterial' has a wrong offset!");

// Class MeshModelingToolsExp.SimpleCollisionEditorToolBuilder
// 0x0000 (0x0028 - 0x0028)
class USimpleCollisionEditorToolBuilder final : public USingleSelectionMeshEditingToolBuilder
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SimpleCollisionEditorToolBuilder">();
	}
	static class USimpleCollisionEditorToolBuilder* GetDefaultObj()
	{
		return GetDefaultObjImpl<USimpleCollisionEditorToolBuilder>();
	}
};
static_assert(alignof(USimpleCollisionEditorToolBuilder) == 0x000008, "Wrong alignment on USimpleCollisionEditorToolBuilder");
static_assert(sizeof(USimpleCollisionEditorToolBuilder) == 0x000028, "Wrong size on USimpleCollisionEditorToolBuilder");

// Class MeshModelingToolsExp.BakeMeshAttributeMapsToolBase
// 0x0178 (0x0320 - 0x01A8)
class UBakeMeshAttributeMapsToolBase : public UBakeMeshAttributeTool
{
public:
	uint8                                         Pad_1A8[0x8];                                      // 0x01A8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UBakeVisualizationProperties*           VisualizationProps;                                // 0x01B0(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPreviewMesh*                           PreviewMesh;                                       // 0x01B8(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstanceDynamic*               PreviewMaterial;                                   // 0x01C0(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstanceDynamic*               BentNormalPreviewMaterial;                         // 0x01C8(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1D0[0x50];                                     // 0x01D0(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EBakeMapType, class UTexture2D*>         CachedMaps;                                        // 0x0220(0x0050)(Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	uint8                                         Pad_270[0x98];                                     // 0x0270(0x0098)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             EmptyNormalMap;                                    // 0x0308(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             EmptyColorMapBlack;                                // 0x0310(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             EmptyColorMapWhite;                                // 0x0318(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BakeMeshAttributeMapsToolBase">();
	}
	static class UBakeMeshAttributeMapsToolBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBakeMeshAttributeMapsToolBase>();
	}
};
static_assert(alignof(UBakeMeshAttributeMapsToolBase) == 0x000008, "Wrong alignment on UBakeMeshAttributeMapsToolBase");
static_assert(sizeof(UBakeMeshAttributeMapsToolBase) == 0x000320, "Wrong size on UBakeMeshAttributeMapsToolBase");
static_assert(offsetof(UBakeMeshAttributeMapsToolBase, VisualizationProps) == 0x0001B0, "Member 'UBakeMeshAttributeMapsToolBase::VisualizationProps' has a wrong offset!");
static_assert(offsetof(UBakeMeshAttributeMapsToolBase, PreviewMesh) == 0x0001B8, "Member 'UBakeMeshAttributeMapsToolBase::PreviewMesh' has a wrong offset!");
static_assert(offsetof(UBakeMeshAttributeMapsToolBase, PreviewMaterial) == 0x0001C0, "Member 'UBakeMeshAttributeMapsToolBase::PreviewMaterial' has a wrong offset!");
static_assert(offsetof(UBakeMeshAttributeMapsToolBase, BentNormalPreviewMaterial) == 0x0001C8, "Member 'UBakeMeshAttributeMapsToolBase::BentNormalPreviewMaterial' has a wrong offset!");
static_assert(offsetof(UBakeMeshAttributeMapsToolBase, CachedMaps) == 0x000220, "Member 'UBakeMeshAttributeMapsToolBase::CachedMaps' has a wrong offset!");
static_assert(offsetof(UBakeMeshAttributeMapsToolBase, EmptyNormalMap) == 0x000308, "Member 'UBakeMeshAttributeMapsToolBase::EmptyNormalMap' has a wrong offset!");
static_assert(offsetof(UBakeMeshAttributeMapsToolBase, EmptyColorMapBlack) == 0x000310, "Member 'UBakeMeshAttributeMapsToolBase::EmptyColorMapBlack' has a wrong offset!");
static_assert(offsetof(UBakeMeshAttributeMapsToolBase, EmptyColorMapWhite) == 0x000318, "Member 'UBakeMeshAttributeMapsToolBase::EmptyColorMapWhite' has a wrong offset!");

// Class MeshModelingToolsExp.BakeMeshAttributeMapsTool
// 0x0070 (0x0390 - 0x0320)
class UBakeMeshAttributeMapsTool final : public UBakeMeshAttributeMapsToolBase
{
public:
	class UBakeInputMeshProperties*               InputMeshSettings;                                 // 0x0320(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBakeMeshAttributeMapsToolProperties*   Settings;                                          // 0x0328(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBakeMeshAttributeMapsResultToolProperties* ResultSettings;                                    // 0x0330(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_338[0x58];                                     // 0x0338(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BakeMeshAttributeMapsTool">();
	}
	static class UBakeMeshAttributeMapsTool* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBakeMeshAttributeMapsTool>();
	}
};
static_assert(alignof(UBakeMeshAttributeMapsTool) == 0x000008, "Wrong alignment on UBakeMeshAttributeMapsTool");
static_assert(sizeof(UBakeMeshAttributeMapsTool) == 0x000390, "Wrong size on UBakeMeshAttributeMapsTool");
static_assert(offsetof(UBakeMeshAttributeMapsTool, InputMeshSettings) == 0x000320, "Member 'UBakeMeshAttributeMapsTool::InputMeshSettings' has a wrong offset!");
static_assert(offsetof(UBakeMeshAttributeMapsTool, Settings) == 0x000328, "Member 'UBakeMeshAttributeMapsTool::Settings' has a wrong offset!");
static_assert(offsetof(UBakeMeshAttributeMapsTool, ResultSettings) == 0x000330, "Member 'UBakeMeshAttributeMapsTool::ResultSettings' has a wrong offset!");

// Class MeshModelingToolsExp.ExtractCollisionGeometryTool
// 0x0278 (0x0328 - 0x00B0)
class UExtractCollisionGeometryTool final : public USingleSelectionMeshEditingTool
{
public:
	class UCreateMeshObjectTypeProperties*        OutputTypeProperties;                              // 0x00B0(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UExtractCollisionToolProperties*        Settings;                                          // 0x00B8(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCollisionGeometryVisualizationProperties* VizSettings;                                       // 0x00C0(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPhysicsObjectToolPropertySet*          ObjectProps;                                       // 0x00C8(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPreviewGeometry*                       PreviewElements;                                   // 0x00D0(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPreviewMesh*                           PreviewMesh;                                       // 0x00D8(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E0[0x248];                                     // 0x00E0(0x0248)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ExtractCollisionGeometryTool">();
	}
	static class UExtractCollisionGeometryTool* GetDefaultObj()
	{
		return GetDefaultObjImpl<UExtractCollisionGeometryTool>();
	}
};
static_assert(alignof(UExtractCollisionGeometryTool) == 0x000008, "Wrong alignment on UExtractCollisionGeometryTool");
static_assert(sizeof(UExtractCollisionGeometryTool) == 0x000328, "Wrong size on UExtractCollisionGeometryTool");
static_assert(offsetof(UExtractCollisionGeometryTool, OutputTypeProperties) == 0x0000B0, "Member 'UExtractCollisionGeometryTool::OutputTypeProperties' has a wrong offset!");
static_assert(offsetof(UExtractCollisionGeometryTool, Settings) == 0x0000B8, "Member 'UExtractCollisionGeometryTool::Settings' has a wrong offset!");
static_assert(offsetof(UExtractCollisionGeometryTool, VizSettings) == 0x0000C0, "Member 'UExtractCollisionGeometryTool::VizSettings' has a wrong offset!");
static_assert(offsetof(UExtractCollisionGeometryTool, ObjectProps) == 0x0000C8, "Member 'UExtractCollisionGeometryTool::ObjectProps' has a wrong offset!");
static_assert(offsetof(UExtractCollisionGeometryTool, PreviewElements) == 0x0000D0, "Member 'UExtractCollisionGeometryTool::PreviewElements' has a wrong offset!");
static_assert(offsetof(UExtractCollisionGeometryTool, PreviewMesh) == 0x0000D8, "Member 'UExtractCollisionGeometryTool::PreviewMesh' has a wrong offset!");

// Class MeshModelingToolsExp.BakeMeshAttributeMapsResultToolProperties
// 0x0050 (0x00F8 - 0x00A8)
class UBakeMeshAttributeMapsResultToolProperties final : public UInteractiveToolPropertySet
{
public:
	TMap<EBakeMapType, class UTexture2D*>         Result;                                            // 0x00A8(0x0050)(Edit, EditConst, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BakeMeshAttributeMapsResultToolProperties">();
	}
	static class UBakeMeshAttributeMapsResultToolProperties* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBakeMeshAttributeMapsResultToolProperties>();
	}
};
static_assert(alignof(UBakeMeshAttributeMapsResultToolProperties) == 0x000008, "Wrong alignment on UBakeMeshAttributeMapsResultToolProperties");
static_assert(sizeof(UBakeMeshAttributeMapsResultToolProperties) == 0x0000F8, "Wrong size on UBakeMeshAttributeMapsResultToolProperties");
static_assert(offsetof(UBakeMeshAttributeMapsResultToolProperties, Result) == 0x0000A8, "Member 'UBakeMeshAttributeMapsResultToolProperties::Result' has a wrong offset!");

// Class MeshModelingToolsExp.BakeMeshAttributeVertexToolBuilder
// 0x0000 (0x0028 - 0x0028)
class UBakeMeshAttributeVertexToolBuilder final : public UMultiSelectionMeshEditingToolBuilder
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BakeMeshAttributeVertexToolBuilder">();
	}
	static class UBakeMeshAttributeVertexToolBuilder* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBakeMeshAttributeVertexToolBuilder>();
	}
};
static_assert(alignof(UBakeMeshAttributeVertexToolBuilder) == 0x000008, "Wrong alignment on UBakeMeshAttributeVertexToolBuilder");
static_assert(sizeof(UBakeMeshAttributeVertexToolBuilder) == 0x000028, "Wrong size on UBakeMeshAttributeVertexToolBuilder");

// Class MeshModelingToolsExp.OffsetMeshTool
// 0x0020 (0x0420 - 0x0400)
class UOffsetMeshTool final : public UBaseMeshProcessingTool
{
public:
	class UOffsetMeshToolProperties*              OffsetProperties;                                  // 0x0400(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UIterativeOffsetProperties*             IterativeProperties;                               // 0x0408(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImplicitOffsetProperties*              ImplicitProperties;                                // 0x0410(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOffsetWeightMapSetProperties*          WeightMapProperties;                               // 0x0418(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OffsetMeshTool">();
	}
	static class UOffsetMeshTool* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOffsetMeshTool>();
	}
};
static_assert(alignof(UOffsetMeshTool) == 0x000010, "Wrong alignment on UOffsetMeshTool");
static_assert(sizeof(UOffsetMeshTool) == 0x000420, "Wrong size on UOffsetMeshTool");
static_assert(offsetof(UOffsetMeshTool, OffsetProperties) == 0x000400, "Member 'UOffsetMeshTool::OffsetProperties' has a wrong offset!");
static_assert(offsetof(UOffsetMeshTool, IterativeProperties) == 0x000408, "Member 'UOffsetMeshTool::IterativeProperties' has a wrong offset!");
static_assert(offsetof(UOffsetMeshTool, ImplicitProperties) == 0x000410, "Member 'UOffsetMeshTool::ImplicitProperties' has a wrong offset!");
static_assert(offsetof(UOffsetMeshTool, WeightMapProperties) == 0x000418, "Member 'UOffsetMeshTool::WeightMapProperties' has a wrong offset!");

// Class MeshModelingToolsExp.BakeMeshAttributeVertexToolProperties
// 0x0020 (0x00C8 - 0x00A8)
class UBakeMeshAttributeVertexToolProperties final : public UInteractiveToolPropertySet
{
public:
	EBakeVertexOutput                             OutputMode;                                        // 0x00A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OutputType;                                        // 0x00AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OutputTypeR;                                       // 0x00B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OutputTypeG;                                       // 0x00B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OutputTypeB;                                       // 0x00B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OutputTypeA;                                       // 0x00BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBakeVertexChannel                            PreviewMode;                                       // 0x00C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSplitAtNormalSeams;                               // 0x00C4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSplitAtUVSeams;                                   // 0x00C5(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C6[0x2];                                       // 0x00C6(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BakeMeshAttributeVertexToolProperties">();
	}
	static class UBakeMeshAttributeVertexToolProperties* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBakeMeshAttributeVertexToolProperties>();
	}
};
static_assert(alignof(UBakeMeshAttributeVertexToolProperties) == 0x000008, "Wrong alignment on UBakeMeshAttributeVertexToolProperties");
static_assert(sizeof(UBakeMeshAttributeVertexToolProperties) == 0x0000C8, "Wrong size on UBakeMeshAttributeVertexToolProperties");
static_assert(offsetof(UBakeMeshAttributeVertexToolProperties, OutputMode) == 0x0000A8, "Member 'UBakeMeshAttributeVertexToolProperties::OutputMode' has a wrong offset!");
static_assert(offsetof(UBakeMeshAttributeVertexToolProperties, OutputType) == 0x0000AC, "Member 'UBakeMeshAttributeVertexToolProperties::OutputType' has a wrong offset!");
static_assert(offsetof(UBakeMeshAttributeVertexToolProperties, OutputTypeR) == 0x0000B0, "Member 'UBakeMeshAttributeVertexToolProperties::OutputTypeR' has a wrong offset!");
static_assert(offsetof(UBakeMeshAttributeVertexToolProperties, OutputTypeG) == 0x0000B4, "Member 'UBakeMeshAttributeVertexToolProperties::OutputTypeG' has a wrong offset!");
static_assert(offsetof(UBakeMeshAttributeVertexToolProperties, OutputTypeB) == 0x0000B8, "Member 'UBakeMeshAttributeVertexToolProperties::OutputTypeB' has a wrong offset!");
static_assert(offsetof(UBakeMeshAttributeVertexToolProperties, OutputTypeA) == 0x0000BC, "Member 'UBakeMeshAttributeVertexToolProperties::OutputTypeA' has a wrong offset!");
static_assert(offsetof(UBakeMeshAttributeVertexToolProperties, PreviewMode) == 0x0000C0, "Member 'UBakeMeshAttributeVertexToolProperties::PreviewMode' has a wrong offset!");
static_assert(offsetof(UBakeMeshAttributeVertexToolProperties, bSplitAtNormalSeams) == 0x0000C4, "Member 'UBakeMeshAttributeVertexToolProperties::bSplitAtNormalSeams' has a wrong offset!");
static_assert(offsetof(UBakeMeshAttributeVertexToolProperties, bSplitAtUVSeams) == 0x0000C5, "Member 'UBakeMeshAttributeVertexToolProperties::bSplitAtUVSeams' has a wrong offset!");

// Class MeshModelingToolsExp.BakeMeshAttributeVertexTool
// 0x0100 (0x02A8 - 0x01A8)
class UBakeMeshAttributeVertexTool final : public UBakeMeshAttributeTool
{
public:
	uint8                                         Pad_1A8[0x8];                                      // 0x01A8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UBakeInputMeshProperties*               InputMeshSettings;                                 // 0x01B0(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBakeMeshAttributeVertexToolProperties* Settings;                                          // 0x01B8(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPreviewMesh*                           PreviewMesh;                                       // 0x01C0(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstanceDynamic*               PreviewMaterial;                                   // 0x01C8(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstanceDynamic*               PreviewAlphaMaterial;                              // 0x01D0(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1D8[0xD0];                                     // 0x01D8(0x00D0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BakeMeshAttributeVertexTool">();
	}
	static class UBakeMeshAttributeVertexTool* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBakeMeshAttributeVertexTool>();
	}
};
static_assert(alignof(UBakeMeshAttributeVertexTool) == 0x000008, "Wrong alignment on UBakeMeshAttributeVertexTool");
static_assert(sizeof(UBakeMeshAttributeVertexTool) == 0x0002A8, "Wrong size on UBakeMeshAttributeVertexTool");
static_assert(offsetof(UBakeMeshAttributeVertexTool, InputMeshSettings) == 0x0001B0, "Member 'UBakeMeshAttributeVertexTool::InputMeshSettings' has a wrong offset!");
static_assert(offsetof(UBakeMeshAttributeVertexTool, Settings) == 0x0001B8, "Member 'UBakeMeshAttributeVertexTool::Settings' has a wrong offset!");
static_assert(offsetof(UBakeMeshAttributeVertexTool, PreviewMesh) == 0x0001C0, "Member 'UBakeMeshAttributeVertexTool::PreviewMesh' has a wrong offset!");
static_assert(offsetof(UBakeMeshAttributeVertexTool, PreviewMaterial) == 0x0001C8, "Member 'UBakeMeshAttributeVertexTool::PreviewMaterial' has a wrong offset!");
static_assert(offsetof(UBakeMeshAttributeVertexTool, PreviewAlphaMaterial) == 0x0001D0, "Member 'UBakeMeshAttributeVertexTool::PreviewAlphaMaterial' has a wrong offset!");

// Class MeshModelingToolsExp.BakeMultiMeshAttributeMapsToolBuilder
// 0x0000 (0x0028 - 0x0028)
class UBakeMultiMeshAttributeMapsToolBuilder final : public UMultiSelectionMeshEditingToolBuilder
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BakeMultiMeshAttributeMapsToolBuilder">();
	}
	static class UBakeMultiMeshAttributeMapsToolBuilder* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBakeMultiMeshAttributeMapsToolBuilder>();
	}
};
static_assert(alignof(UBakeMultiMeshAttributeMapsToolBuilder) == 0x000008, "Wrong alignment on UBakeMultiMeshAttributeMapsToolBuilder");
static_assert(sizeof(UBakeMultiMeshAttributeMapsToolBuilder) == 0x000028, "Wrong size on UBakeMultiMeshAttributeMapsToolBuilder");

// Class MeshModelingToolsExp.BakeMultiMeshAttributeMapsToolProperties
// 0x0090 (0x0138 - 0x00A8)
class UBakeMultiMeshAttributeMapsToolProperties final : public UInteractiveToolPropertySet
{
public:
	int32                                         MapTypes;                                          // 0x00A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AC[0x4];                                       // 0x00AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 MapPreview;                                        // 0x00B0(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBakeTextureResolution                        Resolution;                                        // 0x00C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBakeTextureBitDepth                          BitDepth;                                          // 0x00C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBakeTextureSamplesPerPixel                   SamplesPerPixel;                                   // 0x00C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CC[0x4];                                       // 0x00CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             SampleFilterMask;                                  // 0x00D0(0x0008)(Edit, ZeroConstructor, NoDestructor, AdvancedDisplay, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         MapPreviewNamesList;                               // 0x00D8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_E8[0x50];                                      // 0x00E8(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	const TArray<class FString> GetMapPreviewNamesFunc();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BakeMultiMeshAttributeMapsToolProperties">();
	}
	static class UBakeMultiMeshAttributeMapsToolProperties* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBakeMultiMeshAttributeMapsToolProperties>();
	}
};
static_assert(alignof(UBakeMultiMeshAttributeMapsToolProperties) == 0x000008, "Wrong alignment on UBakeMultiMeshAttributeMapsToolProperties");
static_assert(sizeof(UBakeMultiMeshAttributeMapsToolProperties) == 0x000138, "Wrong size on UBakeMultiMeshAttributeMapsToolProperties");
static_assert(offsetof(UBakeMultiMeshAttributeMapsToolProperties, MapTypes) == 0x0000A8, "Member 'UBakeMultiMeshAttributeMapsToolProperties::MapTypes' has a wrong offset!");
static_assert(offsetof(UBakeMultiMeshAttributeMapsToolProperties, MapPreview) == 0x0000B0, "Member 'UBakeMultiMeshAttributeMapsToolProperties::MapPreview' has a wrong offset!");
static_assert(offsetof(UBakeMultiMeshAttributeMapsToolProperties, Resolution) == 0x0000C0, "Member 'UBakeMultiMeshAttributeMapsToolProperties::Resolution' has a wrong offset!");
static_assert(offsetof(UBakeMultiMeshAttributeMapsToolProperties, BitDepth) == 0x0000C4, "Member 'UBakeMultiMeshAttributeMapsToolProperties::BitDepth' has a wrong offset!");
static_assert(offsetof(UBakeMultiMeshAttributeMapsToolProperties, SamplesPerPixel) == 0x0000C8, "Member 'UBakeMultiMeshAttributeMapsToolProperties::SamplesPerPixel' has a wrong offset!");
static_assert(offsetof(UBakeMultiMeshAttributeMapsToolProperties, SampleFilterMask) == 0x0000D0, "Member 'UBakeMultiMeshAttributeMapsToolProperties::SampleFilterMask' has a wrong offset!");
static_assert(offsetof(UBakeMultiMeshAttributeMapsToolProperties, MapPreviewNamesList) == 0x0000D8, "Member 'UBakeMultiMeshAttributeMapsToolProperties::MapPreviewNamesList' has a wrong offset!");

// Class MeshModelingToolsExp.BakeMultiMeshInputToolProperties
// 0x0050 (0x00F8 - 0x00A8)
class UBakeMultiMeshInputToolProperties final : public UInteractiveToolPropertySet
{
public:
	class UStaticMesh*                            TargetStaticMesh;                                  // 0x00A8(0x0008)(Edit, ZeroConstructor, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMesh*                          TargetSkeletalMesh;                                // 0x00B0(0x0008)(Edit, ZeroConstructor, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 TargetDynamicMesh;                                 // 0x00B8(0x0008)(Edit, ZeroConstructor, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 TargetUVLayer;                                     // 0x00C0(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FBakeMultiMeshDetailProperties> SourceMeshes;                                      // 0x00D0(0x0010)(Edit, EditFixedSize, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         ProjectionDistance;                                // 0x00E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E4[0x4];                                       // 0x00E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         TargetUVLayerNamesList;                            // 0x00E8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)

public:
	const TArray<class FString> GetTargetUVLayerNamesFunc() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BakeMultiMeshInputToolProperties">();
	}
	static class UBakeMultiMeshInputToolProperties* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBakeMultiMeshInputToolProperties>();
	}
};
static_assert(alignof(UBakeMultiMeshInputToolProperties) == 0x000008, "Wrong alignment on UBakeMultiMeshInputToolProperties");
static_assert(sizeof(UBakeMultiMeshInputToolProperties) == 0x0000F8, "Wrong size on UBakeMultiMeshInputToolProperties");
static_assert(offsetof(UBakeMultiMeshInputToolProperties, TargetStaticMesh) == 0x0000A8, "Member 'UBakeMultiMeshInputToolProperties::TargetStaticMesh' has a wrong offset!");
static_assert(offsetof(UBakeMultiMeshInputToolProperties, TargetSkeletalMesh) == 0x0000B0, "Member 'UBakeMultiMeshInputToolProperties::TargetSkeletalMesh' has a wrong offset!");
static_assert(offsetof(UBakeMultiMeshInputToolProperties, TargetDynamicMesh) == 0x0000B8, "Member 'UBakeMultiMeshInputToolProperties::TargetDynamicMesh' has a wrong offset!");
static_assert(offsetof(UBakeMultiMeshInputToolProperties, TargetUVLayer) == 0x0000C0, "Member 'UBakeMultiMeshInputToolProperties::TargetUVLayer' has a wrong offset!");
static_assert(offsetof(UBakeMultiMeshInputToolProperties, SourceMeshes) == 0x0000D0, "Member 'UBakeMultiMeshInputToolProperties::SourceMeshes' has a wrong offset!");
static_assert(offsetof(UBakeMultiMeshInputToolProperties, ProjectionDistance) == 0x0000E0, "Member 'UBakeMultiMeshInputToolProperties::ProjectionDistance' has a wrong offset!");
static_assert(offsetof(UBakeMultiMeshInputToolProperties, TargetUVLayerNamesList) == 0x0000E8, "Member 'UBakeMultiMeshInputToolProperties::TargetUVLayerNamesList' has a wrong offset!");

// Class MeshModelingToolsExp.BakeMultiMeshAttributeMapsTool
// 0x00A8 (0x03C8 - 0x0320)
class UBakeMultiMeshAttributeMapsTool final : public UBakeMeshAttributeMapsToolBase
{
public:
	class UBakeMultiMeshAttributeMapsToolProperties* Settings;                                          // 0x0320(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBakeMultiMeshInputToolProperties*      InputMeshSettings;                                 // 0x0328(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBakeMeshAttributeMapsResultToolProperties* ResultSettings;                                    // 0x0330(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_338[0x90];                                     // 0x0338(0x0090)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BakeMultiMeshAttributeMapsTool">();
	}
	static class UBakeMultiMeshAttributeMapsTool* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBakeMultiMeshAttributeMapsTool>();
	}
};
static_assert(alignof(UBakeMultiMeshAttributeMapsTool) == 0x000008, "Wrong alignment on UBakeMultiMeshAttributeMapsTool");
static_assert(sizeof(UBakeMultiMeshAttributeMapsTool) == 0x0003C8, "Wrong size on UBakeMultiMeshAttributeMapsTool");
static_assert(offsetof(UBakeMultiMeshAttributeMapsTool, Settings) == 0x000320, "Member 'UBakeMultiMeshAttributeMapsTool::Settings' has a wrong offset!");
static_assert(offsetof(UBakeMultiMeshAttributeMapsTool, InputMeshSettings) == 0x000328, "Member 'UBakeMultiMeshAttributeMapsTool::InputMeshSettings' has a wrong offset!");
static_assert(offsetof(UBakeMultiMeshAttributeMapsTool, ResultSettings) == 0x000330, "Member 'UBakeMultiMeshAttributeMapsTool::ResultSettings' has a wrong offset!");

// Class MeshModelingToolsExp.BakeTransformToolBuilder
// 0x0000 (0x0028 - 0x0028)
class UBakeTransformToolBuilder final : public UMultiSelectionMeshEditingToolBuilder
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BakeTransformToolBuilder">();
	}
	static class UBakeTransformToolBuilder* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBakeTransformToolBuilder>();
	}
};
static_assert(alignof(UBakeTransformToolBuilder) == 0x000008, "Wrong alignment on UBakeTransformToolBuilder");
static_assert(sizeof(UBakeTransformToolBuilder) == 0x000028, "Wrong size on UBakeTransformToolBuilder");

// Class MeshModelingToolsExp.BakeTransformToolProperties
// 0x0008 (0x00B0 - 0x00A8)
class UBakeTransformToolProperties final : public UInteractiveToolPropertySet
{
public:
	bool                                          bApplyToAllLODs;                                   // 0x00A8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBakeRotation;                                     // 0x00A9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBakeScaleMethod                              BakeScale;                                         // 0x00AA(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRecenterPivot;                                    // 0x00AB(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowNoScale;                                     // 0x00AC(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AD[0x3];                                       // 0x00AD(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BakeTransformToolProperties">();
	}
	static class UBakeTransformToolProperties* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBakeTransformToolProperties>();
	}
};
static_assert(alignof(UBakeTransformToolProperties) == 0x000008, "Wrong alignment on UBakeTransformToolProperties");
static_assert(sizeof(UBakeTransformToolProperties) == 0x0000B0, "Wrong size on UBakeTransformToolProperties");
static_assert(offsetof(UBakeTransformToolProperties, bApplyToAllLODs) == 0x0000A8, "Member 'UBakeTransformToolProperties::bApplyToAllLODs' has a wrong offset!");
static_assert(offsetof(UBakeTransformToolProperties, bBakeRotation) == 0x0000A9, "Member 'UBakeTransformToolProperties::bBakeRotation' has a wrong offset!");
static_assert(offsetof(UBakeTransformToolProperties, BakeScale) == 0x0000AA, "Member 'UBakeTransformToolProperties::BakeScale' has a wrong offset!");
static_assert(offsetof(UBakeTransformToolProperties, bRecenterPivot) == 0x0000AB, "Member 'UBakeTransformToolProperties::bRecenterPivot' has a wrong offset!");
static_assert(offsetof(UBakeTransformToolProperties, bAllowNoScale) == 0x0000AC, "Member 'UBakeTransformToolProperties::bAllowNoScale' has a wrong offset!");

// Class MeshModelingToolsExp.BakeTransformTool
// 0x0020 (0x00D8 - 0x00B8)
class UBakeTransformTool final : public UMultiSelectionMeshEditingTool
{
public:
	uint8                                         Pad_B8[0x8];                                       // 0x00B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UBakeTransformToolProperties*           BasicProperties;                                   // 0x00C0(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C8[0x10];                                      // 0x00C8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BakeTransformTool">();
	}
	static class UBakeTransformTool* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBakeTransformTool>();
	}
};
static_assert(alignof(UBakeTransformTool) == 0x000008, "Wrong alignment on UBakeTransformTool");
static_assert(sizeof(UBakeTransformTool) == 0x0000D8, "Wrong size on UBakeTransformTool");
static_assert(offsetof(UBakeTransformTool, BasicProperties) == 0x0000C0, "Member 'UBakeTransformTool::BasicProperties' has a wrong offset!");

// Class MeshModelingToolsExp.ConvertMeshesToolBuilder
// 0x0000 (0x0028 - 0x0028)
class UConvertMeshesToolBuilder final : public UInteractiveToolBuilder
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ConvertMeshesToolBuilder">();
	}
	static class UConvertMeshesToolBuilder* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConvertMeshesToolBuilder>();
	}
};
static_assert(alignof(UConvertMeshesToolBuilder) == 0x000008, "Wrong alignment on UConvertMeshesToolBuilder");
static_assert(sizeof(UConvertMeshesToolBuilder) == 0x000028, "Wrong size on UConvertMeshesToolBuilder");

// Class MeshModelingToolsExp.ConvertMeshesToolProperties
// 0x0008 (0x00B0 - 0x00A8)
class UConvertMeshesToolProperties final : public UInteractiveToolPropertySet
{
public:
	bool                                          bTransferMaterials;                                // 0x00A8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowTransferMaterials;                            // 0x00A9(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTransferCollision;                                // 0x00AA(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AB[0x5];                                       // 0x00AB(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ConvertMeshesToolProperties">();
	}
	static class UConvertMeshesToolProperties* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConvertMeshesToolProperties>();
	}
};
static_assert(alignof(UConvertMeshesToolProperties) == 0x000008, "Wrong alignment on UConvertMeshesToolProperties");
static_assert(sizeof(UConvertMeshesToolProperties) == 0x0000B0, "Wrong size on UConvertMeshesToolProperties");
static_assert(offsetof(UConvertMeshesToolProperties, bTransferMaterials) == 0x0000A8, "Member 'UConvertMeshesToolProperties::bTransferMaterials' has a wrong offset!");
static_assert(offsetof(UConvertMeshesToolProperties, bShowTransferMaterials) == 0x0000A9, "Member 'UConvertMeshesToolProperties::bShowTransferMaterials' has a wrong offset!");
static_assert(offsetof(UConvertMeshesToolProperties, bTransferCollision) == 0x0000AA, "Member 'UConvertMeshesToolProperties::bTransferCollision' has a wrong offset!");

// Class MeshModelingToolsExp.ConvertMeshesTool
// 0x0030 (0x00C8 - 0x0098)
class UConvertMeshesTool final : public UInteractiveTool
{
public:
	uint8                                         Pad_98[0x8];                                       // 0x0098(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UConvertMeshesToolProperties*           BasicProperties;                                   // 0x00A0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCreateMeshObjectTypeProperties*        OutputTypeProperties;                              // 0x00A8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TWeakObjectPtr<class UPrimitiveComponent>> Inputs;                                            // 0x00B0(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C0[0x8];                                       // 0x00C0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ConvertMeshesTool">();
	}
	static class UConvertMeshesTool* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConvertMeshesTool>();
	}
};
static_assert(alignof(UConvertMeshesTool) == 0x000008, "Wrong alignment on UConvertMeshesTool");
static_assert(sizeof(UConvertMeshesTool) == 0x0000C8, "Wrong size on UConvertMeshesTool");
static_assert(offsetof(UConvertMeshesTool, BasicProperties) == 0x0000A0, "Member 'UConvertMeshesTool::BasicProperties' has a wrong offset!");
static_assert(offsetof(UConvertMeshesTool, OutputTypeProperties) == 0x0000A8, "Member 'UConvertMeshesTool::OutputTypeProperties' has a wrong offset!");
static_assert(offsetof(UConvertMeshesTool, Inputs) == 0x0000B0, "Member 'UConvertMeshesTool::Inputs' has a wrong offset!");

// Class MeshModelingToolsExp.ConvertToPolygonsToolBuilder
// 0x0000 (0x0028 - 0x0028)
class UConvertToPolygonsToolBuilder final : public USingleTargetWithSelectionToolBuilder
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ConvertToPolygonsToolBuilder">();
	}
	static class UConvertToPolygonsToolBuilder* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConvertToPolygonsToolBuilder>();
	}
};
static_assert(alignof(UConvertToPolygonsToolBuilder) == 0x000008, "Wrong alignment on UConvertToPolygonsToolBuilder");
static_assert(sizeof(UConvertToPolygonsToolBuilder) == 0x000028, "Wrong size on UConvertToPolygonsToolBuilder");

// Class MeshModelingToolsExp.ConvertToPolygonsToolProperties
// 0x0030 (0x00D8 - 0x00A8)
class UConvertToPolygonsToolProperties final : public UInteractiveToolPropertySet
{
public:
	EConvertToPolygonsMode                        ConversionMode;                                    // 0x00A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AngleTolerance;                                    // 0x00AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseAverageGroupNormal;                            // 0x00B0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B1[0x3];                                       // 0x00B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NumPoints;                                         // 0x00B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSplitExisting;                                    // 0x00B8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNormalWeighted;                                   // 0x00B9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BA[0x2];                                       // 0x00BA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         NormalWeighting;                                   // 0x00BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         QuadAdjacencyWeight;                               // 0x00C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         QuadMetricClamp;                                   // 0x00C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         QuadSearchRounds;                                  // 0x00C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRespectUVSeams;                                   // 0x00CC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRespectHardNormals;                               // 0x00CD(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CE[0x2];                                       // 0x00CE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MinGroupSize;                                      // 0x00D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCalculateNormals;                                 // 0x00D4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowGroupColors;                                  // 0x00D5(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D6[0x2];                                       // 0x00D6(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ConvertToPolygonsToolProperties">();
	}
	static class UConvertToPolygonsToolProperties* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConvertToPolygonsToolProperties>();
	}
};
static_assert(alignof(UConvertToPolygonsToolProperties) == 0x000008, "Wrong alignment on UConvertToPolygonsToolProperties");
static_assert(sizeof(UConvertToPolygonsToolProperties) == 0x0000D8, "Wrong size on UConvertToPolygonsToolProperties");
static_assert(offsetof(UConvertToPolygonsToolProperties, ConversionMode) == 0x0000A8, "Member 'UConvertToPolygonsToolProperties::ConversionMode' has a wrong offset!");
static_assert(offsetof(UConvertToPolygonsToolProperties, AngleTolerance) == 0x0000AC, "Member 'UConvertToPolygonsToolProperties::AngleTolerance' has a wrong offset!");
static_assert(offsetof(UConvertToPolygonsToolProperties, bUseAverageGroupNormal) == 0x0000B0, "Member 'UConvertToPolygonsToolProperties::bUseAverageGroupNormal' has a wrong offset!");
static_assert(offsetof(UConvertToPolygonsToolProperties, NumPoints) == 0x0000B4, "Member 'UConvertToPolygonsToolProperties::NumPoints' has a wrong offset!");
static_assert(offsetof(UConvertToPolygonsToolProperties, bSplitExisting) == 0x0000B8, "Member 'UConvertToPolygonsToolProperties::bSplitExisting' has a wrong offset!");
static_assert(offsetof(UConvertToPolygonsToolProperties, bNormalWeighted) == 0x0000B9, "Member 'UConvertToPolygonsToolProperties::bNormalWeighted' has a wrong offset!");
static_assert(offsetof(UConvertToPolygonsToolProperties, NormalWeighting) == 0x0000BC, "Member 'UConvertToPolygonsToolProperties::NormalWeighting' has a wrong offset!");
static_assert(offsetof(UConvertToPolygonsToolProperties, QuadAdjacencyWeight) == 0x0000C0, "Member 'UConvertToPolygonsToolProperties::QuadAdjacencyWeight' has a wrong offset!");
static_assert(offsetof(UConvertToPolygonsToolProperties, QuadMetricClamp) == 0x0000C4, "Member 'UConvertToPolygonsToolProperties::QuadMetricClamp' has a wrong offset!");
static_assert(offsetof(UConvertToPolygonsToolProperties, QuadSearchRounds) == 0x0000C8, "Member 'UConvertToPolygonsToolProperties::QuadSearchRounds' has a wrong offset!");
static_assert(offsetof(UConvertToPolygonsToolProperties, bRespectUVSeams) == 0x0000CC, "Member 'UConvertToPolygonsToolProperties::bRespectUVSeams' has a wrong offset!");
static_assert(offsetof(UConvertToPolygonsToolProperties, bRespectHardNormals) == 0x0000CD, "Member 'UConvertToPolygonsToolProperties::bRespectHardNormals' has a wrong offset!");
static_assert(offsetof(UConvertToPolygonsToolProperties, MinGroupSize) == 0x0000D0, "Member 'UConvertToPolygonsToolProperties::MinGroupSize' has a wrong offset!");
static_assert(offsetof(UConvertToPolygonsToolProperties, bCalculateNormals) == 0x0000D4, "Member 'UConvertToPolygonsToolProperties::bCalculateNormals' has a wrong offset!");
static_assert(offsetof(UConvertToPolygonsToolProperties, bShowGroupColors) == 0x0000D5, "Member 'UConvertToPolygonsToolProperties::bShowGroupColors' has a wrong offset!");

// Class MeshModelingToolsExp.OutputPolygroupLayerProperties
// 0x0030 (0x00D8 - 0x00A8)
class UOutputPolygroupLayerProperties final : public UInteractiveToolPropertySet
{
public:
	class FName                                   GroupLayer;                                        // 0x00A8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         OptionsList;                                       // 0x00B0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bShowNewLayerName;                                 // 0x00C0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C1[0x7];                                       // 0x00C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 NewLayerName;                                      // 0x00C8(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	TArray<class FString> GetGroupOptionsList();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OutputPolygroupLayerProperties">();
	}
	static class UOutputPolygroupLayerProperties* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOutputPolygroupLayerProperties>();
	}
};
static_assert(alignof(UOutputPolygroupLayerProperties) == 0x000008, "Wrong alignment on UOutputPolygroupLayerProperties");
static_assert(sizeof(UOutputPolygroupLayerProperties) == 0x0000D8, "Wrong size on UOutputPolygroupLayerProperties");
static_assert(offsetof(UOutputPolygroupLayerProperties, GroupLayer) == 0x0000A8, "Member 'UOutputPolygroupLayerProperties::GroupLayer' has a wrong offset!");
static_assert(offsetof(UOutputPolygroupLayerProperties, OptionsList) == 0x0000B0, "Member 'UOutputPolygroupLayerProperties::OptionsList' has a wrong offset!");
static_assert(offsetof(UOutputPolygroupLayerProperties, bShowNewLayerName) == 0x0000C0, "Member 'UOutputPolygroupLayerProperties::bShowNewLayerName' has a wrong offset!");
static_assert(offsetof(UOutputPolygroupLayerProperties, NewLayerName) == 0x0000C8, "Member 'UOutputPolygroupLayerProperties::NewLayerName' has a wrong offset!");

// Class MeshModelingToolsExp.ConvertToPolygonsOperatorFactory
// 0x0010 (0x0038 - 0x0028)
class UConvertToPolygonsOperatorFactory final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UConvertToPolygonsTool*                 ConvertToPolygonsTool;                             // 0x0030(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ConvertToPolygonsOperatorFactory">();
	}
	static class UConvertToPolygonsOperatorFactory* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConvertToPolygonsOperatorFactory>();
	}
};
static_assert(alignof(UConvertToPolygonsOperatorFactory) == 0x000008, "Wrong alignment on UConvertToPolygonsOperatorFactory");
static_assert(sizeof(UConvertToPolygonsOperatorFactory) == 0x000038, "Wrong size on UConvertToPolygonsOperatorFactory");
static_assert(offsetof(UConvertToPolygonsOperatorFactory, ConvertToPolygonsTool) == 0x000030, "Member 'UConvertToPolygonsOperatorFactory::ConvertToPolygonsTool' has a wrong offset!");

// Class MeshModelingToolsExp.ConvertToPolygonsTool
// 0x0098 (0x01B8 - 0x0120)
class UConvertToPolygonsTool final : public USingleTargetWithSelectionTool
{
public:
	class UConvertToPolygonsToolProperties*       Settings;                                          // 0x0120(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPolygroupLayersProperties*             CopyFromLayerProperties;                           // 0x0128(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOutputPolygroupLayerProperties*        OutputProperties;                                  // 0x0130(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMeshOpPreviewWithBackgroundCompute*    PreviewCompute;                                    // 0x0138(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPreviewGeometry*                       PreviewGeometry;                                   // 0x0140(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPreviewMesh*                           UnmodifiedAreaPreviewMesh;                         // 0x0148(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_150[0x68];                                     // 0x0150(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ConvertToPolygonsTool">();
	}
	static class UConvertToPolygonsTool* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConvertToPolygonsTool>();
	}
};
static_assert(alignof(UConvertToPolygonsTool) == 0x000008, "Wrong alignment on UConvertToPolygonsTool");
static_assert(sizeof(UConvertToPolygonsTool) == 0x0001B8, "Wrong size on UConvertToPolygonsTool");
static_assert(offsetof(UConvertToPolygonsTool, Settings) == 0x000120, "Member 'UConvertToPolygonsTool::Settings' has a wrong offset!");
static_assert(offsetof(UConvertToPolygonsTool, CopyFromLayerProperties) == 0x000128, "Member 'UConvertToPolygonsTool::CopyFromLayerProperties' has a wrong offset!");
static_assert(offsetof(UConvertToPolygonsTool, OutputProperties) == 0x000130, "Member 'UConvertToPolygonsTool::OutputProperties' has a wrong offset!");
static_assert(offsetof(UConvertToPolygonsTool, PreviewCompute) == 0x000138, "Member 'UConvertToPolygonsTool::PreviewCompute' has a wrong offset!");
static_assert(offsetof(UConvertToPolygonsTool, PreviewGeometry) == 0x000140, "Member 'UConvertToPolygonsTool::PreviewGeometry' has a wrong offset!");
static_assert(offsetof(UConvertToPolygonsTool, UnmodifiedAreaPreviewMesh) == 0x000148, "Member 'UConvertToPolygonsTool::UnmodifiedAreaPreviewMesh' has a wrong offset!");

// Class MeshModelingToolsExp.CubeGridToolBuilder
// 0x0008 (0x0030 - 0x0028)
class UCubeGridToolBuilder final : public UInteractiveToolWithToolTargetsBuilder
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CubeGridToolBuilder">();
	}
	static class UCubeGridToolBuilder* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCubeGridToolBuilder>();
	}
};
static_assert(alignof(UCubeGridToolBuilder) == 0x000008, "Wrong alignment on UCubeGridToolBuilder");
static_assert(sizeof(UCubeGridToolBuilder) == 0x000030, "Wrong size on UCubeGridToolBuilder");

// Class MeshModelingToolsExp.CubeGridToolProperties
// 0x0100 (0x01A8 - 0x00A8)
class UCubeGridToolProperties final : public UInteractiveToolPropertySet
{
public:
	struct FVector                                GridFrameOrigin;                                   // 0x00A8(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               GridFrameOrientation;                              // 0x00C0(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bShowGizmo;                                        // 0x00D8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D9[0xF];                                       // 0x00D9(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         GridPower;                                         // 0x00E8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E9[0x7];                                       // 0x00E9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        CurrentBlockSize;                                  // 0x00F0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BlocksPerStep;                                     // 0x00F8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPowerOfTwoBlockSizes;                             // 0x00FC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FD[0x3];                                       // 0x00FD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        BlockBaseSize;                                     // 0x0100(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCrosswiseDiagonal;                                // 0x0108(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bKeepSideGroups;                                   // 0x0109(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowSelectionMeasurements;                        // 0x010A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10B[0x5];                                      // 0x010B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        PlaneTolerance;                                    // 0x0110(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHitUnrelatedGeometry;                             // 0x0118(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHitGridGroundPlaneIfCloser;                       // 0x0119(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11A[0x2];                                      // 0x011A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	ECubeGridToolFaceSelectionMode                FaceSelectionMode;                                 // 0x011C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ToggleCornerMode;                                  // 0x0120(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PushPull;                                          // 0x0130(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ResizeGrid;                                        // 0x0140(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_150[0x10];                                     // 0x0150(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 FlipSelection;                                     // 0x0160(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 GridGizmo;                                         // 0x0170(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 QuickShiftGizmo;                                   // 0x0180(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AlignGizmo;                                        // 0x0190(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInCornerMode;                                     // 0x01A0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowedToEditGrid;                                // 0x01A1(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A2[0x6];                                      // 0x01A2(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CubeGridToolProperties">();
	}
	static class UCubeGridToolProperties* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCubeGridToolProperties>();
	}
};
static_assert(alignof(UCubeGridToolProperties) == 0x000008, "Wrong alignment on UCubeGridToolProperties");
static_assert(sizeof(UCubeGridToolProperties) == 0x0001A8, "Wrong size on UCubeGridToolProperties");
static_assert(offsetof(UCubeGridToolProperties, GridFrameOrigin) == 0x0000A8, "Member 'UCubeGridToolProperties::GridFrameOrigin' has a wrong offset!");
static_assert(offsetof(UCubeGridToolProperties, GridFrameOrientation) == 0x0000C0, "Member 'UCubeGridToolProperties::GridFrameOrientation' has a wrong offset!");
static_assert(offsetof(UCubeGridToolProperties, bShowGizmo) == 0x0000D8, "Member 'UCubeGridToolProperties::bShowGizmo' has a wrong offset!");
static_assert(offsetof(UCubeGridToolProperties, GridPower) == 0x0000E8, "Member 'UCubeGridToolProperties::GridPower' has a wrong offset!");
static_assert(offsetof(UCubeGridToolProperties, CurrentBlockSize) == 0x0000F0, "Member 'UCubeGridToolProperties::CurrentBlockSize' has a wrong offset!");
static_assert(offsetof(UCubeGridToolProperties, BlocksPerStep) == 0x0000F8, "Member 'UCubeGridToolProperties::BlocksPerStep' has a wrong offset!");
static_assert(offsetof(UCubeGridToolProperties, bPowerOfTwoBlockSizes) == 0x0000FC, "Member 'UCubeGridToolProperties::bPowerOfTwoBlockSizes' has a wrong offset!");
static_assert(offsetof(UCubeGridToolProperties, BlockBaseSize) == 0x000100, "Member 'UCubeGridToolProperties::BlockBaseSize' has a wrong offset!");
static_assert(offsetof(UCubeGridToolProperties, bCrosswiseDiagonal) == 0x000108, "Member 'UCubeGridToolProperties::bCrosswiseDiagonal' has a wrong offset!");
static_assert(offsetof(UCubeGridToolProperties, bKeepSideGroups) == 0x000109, "Member 'UCubeGridToolProperties::bKeepSideGroups' has a wrong offset!");
static_assert(offsetof(UCubeGridToolProperties, bShowSelectionMeasurements) == 0x00010A, "Member 'UCubeGridToolProperties::bShowSelectionMeasurements' has a wrong offset!");
static_assert(offsetof(UCubeGridToolProperties, PlaneTolerance) == 0x000110, "Member 'UCubeGridToolProperties::PlaneTolerance' has a wrong offset!");
static_assert(offsetof(UCubeGridToolProperties, bHitUnrelatedGeometry) == 0x000118, "Member 'UCubeGridToolProperties::bHitUnrelatedGeometry' has a wrong offset!");
static_assert(offsetof(UCubeGridToolProperties, bHitGridGroundPlaneIfCloser) == 0x000119, "Member 'UCubeGridToolProperties::bHitGridGroundPlaneIfCloser' has a wrong offset!");
static_assert(offsetof(UCubeGridToolProperties, FaceSelectionMode) == 0x00011C, "Member 'UCubeGridToolProperties::FaceSelectionMode' has a wrong offset!");
static_assert(offsetof(UCubeGridToolProperties, ToggleCornerMode) == 0x000120, "Member 'UCubeGridToolProperties::ToggleCornerMode' has a wrong offset!");
static_assert(offsetof(UCubeGridToolProperties, PushPull) == 0x000130, "Member 'UCubeGridToolProperties::PushPull' has a wrong offset!");
static_assert(offsetof(UCubeGridToolProperties, ResizeGrid) == 0x000140, "Member 'UCubeGridToolProperties::ResizeGrid' has a wrong offset!");
static_assert(offsetof(UCubeGridToolProperties, FlipSelection) == 0x000160, "Member 'UCubeGridToolProperties::FlipSelection' has a wrong offset!");
static_assert(offsetof(UCubeGridToolProperties, GridGizmo) == 0x000170, "Member 'UCubeGridToolProperties::GridGizmo' has a wrong offset!");
static_assert(offsetof(UCubeGridToolProperties, QuickShiftGizmo) == 0x000180, "Member 'UCubeGridToolProperties::QuickShiftGizmo' has a wrong offset!");
static_assert(offsetof(UCubeGridToolProperties, AlignGizmo) == 0x000190, "Member 'UCubeGridToolProperties::AlignGizmo' has a wrong offset!");
static_assert(offsetof(UCubeGridToolProperties, bInCornerMode) == 0x0001A0, "Member 'UCubeGridToolProperties::bInCornerMode' has a wrong offset!");
static_assert(offsetof(UCubeGridToolProperties, bAllowedToEditGrid) == 0x0001A1, "Member 'UCubeGridToolProperties::bAllowedToEditGrid' has a wrong offset!");

// Class MeshModelingToolsExp.CubeGridToolActions
// 0x0010 (0x00B8 - 0x00A8)
class UCubeGridToolActions final : public UInteractiveToolPropertySet
{
public:
	uint8                                         Pad_A8[0x8];                                       // 0x00A8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 GridSourceActor;                                   // 0x00B0(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void AcceptAndStartNew();
	void CornerMode();
	void Flip();
	void Pull();
	void Push();
	void ResetGridFromActor();
	void SlideBack();
	void SlideForward();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CubeGridToolActions">();
	}
	static class UCubeGridToolActions* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCubeGridToolActions>();
	}
};
static_assert(alignof(UCubeGridToolActions) == 0x000008, "Wrong alignment on UCubeGridToolActions");
static_assert(sizeof(UCubeGridToolActions) == 0x0000B8, "Wrong size on UCubeGridToolActions");
static_assert(offsetof(UCubeGridToolActions, GridSourceActor) == 0x0000B0, "Member 'UCubeGridToolActions::GridSourceActor' has a wrong offset!");

// Class MeshModelingToolsExp.CubeGridTool
// 0x0588 (0x0620 - 0x0098)
class alignas(0x10) UCubeGridTool final : public UInteractiveTool
{
public:
	uint8                                         Pad_98[0x28];                                      // 0x0098(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	class UCombinedTransformGizmo*                GridGizmo;                                         // 0x00C0(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDragAlignmentMechanic*                 GridGizmoAlignmentMechanic;                        // 0x00C8(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTransformProxy*                        GridGizmoTransformProxy;                           // 0x00D0(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPreviewGeometry*                       LineSets;                                          // 0x00D8(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UClickDragInputBehavior*                ClickDragBehavior;                                 // 0x00E0(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMouseHoverBehavior*                    HoverBehavior;                                     // 0x00E8(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ULocalSingleClickInputBehavior*         CtrlMiddleClickBehavior;                           // 0x00F0(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ULocalClickDragInputBehavior*           MiddleClickDragBehavior;                           // 0x00F8(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCubeGridToolProperties*                Settings;                                          // 0x0100(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCubeGridToolActions*                   ToolActions;                                       // 0x0108(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNewMeshMaterialProperties*             MaterialProperties;                                // 0x0110(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCreateMeshObjectTypeProperties*        OutputTypeProperties;                              // 0x0118(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UToolTarget*                            Target;                                            // 0x0120(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_128[0x180];                                    // 0x0128(0x0180)(Fixing Size After Last Property [ Dumper-7 ])
	class UMeshOpPreviewWithBackgroundCompute*    Preview;                                           // 0x02A8(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B0[0x370];                                    // 0x02B0(0x0370)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CubeGridTool">();
	}
	static class UCubeGridTool* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCubeGridTool>();
	}
};
static_assert(alignof(UCubeGridTool) == 0x000010, "Wrong alignment on UCubeGridTool");
static_assert(sizeof(UCubeGridTool) == 0x000620, "Wrong size on UCubeGridTool");
static_assert(offsetof(UCubeGridTool, GridGizmo) == 0x0000C0, "Member 'UCubeGridTool::GridGizmo' has a wrong offset!");
static_assert(offsetof(UCubeGridTool, GridGizmoAlignmentMechanic) == 0x0000C8, "Member 'UCubeGridTool::GridGizmoAlignmentMechanic' has a wrong offset!");
static_assert(offsetof(UCubeGridTool, GridGizmoTransformProxy) == 0x0000D0, "Member 'UCubeGridTool::GridGizmoTransformProxy' has a wrong offset!");
static_assert(offsetof(UCubeGridTool, LineSets) == 0x0000D8, "Member 'UCubeGridTool::LineSets' has a wrong offset!");
static_assert(offsetof(UCubeGridTool, ClickDragBehavior) == 0x0000E0, "Member 'UCubeGridTool::ClickDragBehavior' has a wrong offset!");
static_assert(offsetof(UCubeGridTool, HoverBehavior) == 0x0000E8, "Member 'UCubeGridTool::HoverBehavior' has a wrong offset!");
static_assert(offsetof(UCubeGridTool, CtrlMiddleClickBehavior) == 0x0000F0, "Member 'UCubeGridTool::CtrlMiddleClickBehavior' has a wrong offset!");
static_assert(offsetof(UCubeGridTool, MiddleClickDragBehavior) == 0x0000F8, "Member 'UCubeGridTool::MiddleClickDragBehavior' has a wrong offset!");
static_assert(offsetof(UCubeGridTool, Settings) == 0x000100, "Member 'UCubeGridTool::Settings' has a wrong offset!");
static_assert(offsetof(UCubeGridTool, ToolActions) == 0x000108, "Member 'UCubeGridTool::ToolActions' has a wrong offset!");
static_assert(offsetof(UCubeGridTool, MaterialProperties) == 0x000110, "Member 'UCubeGridTool::MaterialProperties' has a wrong offset!");
static_assert(offsetof(UCubeGridTool, OutputTypeProperties) == 0x000118, "Member 'UCubeGridTool::OutputTypeProperties' has a wrong offset!");
static_assert(offsetof(UCubeGridTool, Target) == 0x000120, "Member 'UCubeGridTool::Target' has a wrong offset!");
static_assert(offsetof(UCubeGridTool, Preview) == 0x0002A8, "Member 'UCubeGridTool::Preview' has a wrong offset!");

// Class MeshModelingToolsExp.DeformMeshPolygonsToolBuilder
// 0x0000 (0x0030 - 0x0030)
class UDeformMeshPolygonsToolBuilder final : public UMeshSurfacePointMeshEditingToolBuilder
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DeformMeshPolygonsToolBuilder">();
	}
	static class UDeformMeshPolygonsToolBuilder* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDeformMeshPolygonsToolBuilder>();
	}
};
static_assert(alignof(UDeformMeshPolygonsToolBuilder) == 0x000008, "Wrong alignment on UDeformMeshPolygonsToolBuilder");
static_assert(sizeof(UDeformMeshPolygonsToolBuilder) == 0x000030, "Wrong size on UDeformMeshPolygonsToolBuilder");

// Class MeshModelingToolsExp.DeformMeshPolygonsTransformProperties
// 0x0020 (0x00C8 - 0x00A8)
class UDeformMeshPolygonsTransformProperties final : public UInteractiveToolPropertySet
{
public:
	EGroupTopologyDeformationStrategy             DeformationStrategy;                               // 0x00A8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EQuickTransformerMode                         TransformMode;                                     // 0x00A9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSelectFaces;                                      // 0x00AA(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSelectEdges;                                      // 0x00AB(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSelectVertices;                                   // 0x00AC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowWireframe;                                    // 0x00AD(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AE[0x2];                                       // 0x00AE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	EWeightScheme                                 SelectedWeightScheme;                              // 0x00B0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B4[0x4];                                       // 0x00B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        HandleWeight;                                      // 0x00B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPostFixHandles;                                   // 0x00C0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C1[0x7];                                       // 0x00C1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DeformMeshPolygonsTransformProperties">();
	}
	static class UDeformMeshPolygonsTransformProperties* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDeformMeshPolygonsTransformProperties>();
	}
};
static_assert(alignof(UDeformMeshPolygonsTransformProperties) == 0x000008, "Wrong alignment on UDeformMeshPolygonsTransformProperties");
static_assert(sizeof(UDeformMeshPolygonsTransformProperties) == 0x0000C8, "Wrong size on UDeformMeshPolygonsTransformProperties");
static_assert(offsetof(UDeformMeshPolygonsTransformProperties, DeformationStrategy) == 0x0000A8, "Member 'UDeformMeshPolygonsTransformProperties::DeformationStrategy' has a wrong offset!");
static_assert(offsetof(UDeformMeshPolygonsTransformProperties, TransformMode) == 0x0000A9, "Member 'UDeformMeshPolygonsTransformProperties::TransformMode' has a wrong offset!");
static_assert(offsetof(UDeformMeshPolygonsTransformProperties, bSelectFaces) == 0x0000AA, "Member 'UDeformMeshPolygonsTransformProperties::bSelectFaces' has a wrong offset!");
static_assert(offsetof(UDeformMeshPolygonsTransformProperties, bSelectEdges) == 0x0000AB, "Member 'UDeformMeshPolygonsTransformProperties::bSelectEdges' has a wrong offset!");
static_assert(offsetof(UDeformMeshPolygonsTransformProperties, bSelectVertices) == 0x0000AC, "Member 'UDeformMeshPolygonsTransformProperties::bSelectVertices' has a wrong offset!");
static_assert(offsetof(UDeformMeshPolygonsTransformProperties, bShowWireframe) == 0x0000AD, "Member 'UDeformMeshPolygonsTransformProperties::bShowWireframe' has a wrong offset!");
static_assert(offsetof(UDeformMeshPolygonsTransformProperties, SelectedWeightScheme) == 0x0000B0, "Member 'UDeformMeshPolygonsTransformProperties::SelectedWeightScheme' has a wrong offset!");
static_assert(offsetof(UDeformMeshPolygonsTransformProperties, HandleWeight) == 0x0000B8, "Member 'UDeformMeshPolygonsTransformProperties::HandleWeight' has a wrong offset!");
static_assert(offsetof(UDeformMeshPolygonsTransformProperties, bPostFixHandles) == 0x0000C0, "Member 'UDeformMeshPolygonsTransformProperties::bPostFixHandles' has a wrong offset!");

// Class MeshModelingToolsExp.DeformMeshPolygonsTool
// 0x1700 (0x1800 - 0x0100)
class alignas(0x10) UDeformMeshPolygonsTool final : public UMeshSurfacePointTool
{
public:
	uint8                                         Pad_100[0x10];                                     // 0x0100(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class AInternalToolFrameworkActor*            PreviewMeshActor;                                  // 0x0110(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDynamicMeshComponent*                  DynamicMeshComponent;                              // 0x0118(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDeformMeshPolygonsTransformProperties* TransformProps;                                    // 0x0120(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_128[0x16D8];                                   // 0x0128(0x16D8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DeformMeshPolygonsTool">();
	}
	static class UDeformMeshPolygonsTool* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDeformMeshPolygonsTool>();
	}
};
static_assert(alignof(UDeformMeshPolygonsTool) == 0x000010, "Wrong alignment on UDeformMeshPolygonsTool");
static_assert(sizeof(UDeformMeshPolygonsTool) == 0x001800, "Wrong size on UDeformMeshPolygonsTool");
static_assert(offsetof(UDeformMeshPolygonsTool, PreviewMeshActor) == 0x000110, "Member 'UDeformMeshPolygonsTool::PreviewMeshActor' has a wrong offset!");
static_assert(offsetof(UDeformMeshPolygonsTool, DynamicMeshComponent) == 0x000118, "Member 'UDeformMeshPolygonsTool::DynamicMeshComponent' has a wrong offset!");
static_assert(offsetof(UDeformMeshPolygonsTool, TransformProps) == 0x000120, "Member 'UDeformMeshPolygonsTool::TransformProps' has a wrong offset!");

// Class MeshModelingToolsExp.DisplaceMeshCommonProperties
// 0x0038 (0x00E0 - 0x00A8)
class UDisplaceMeshCommonProperties final : public UInteractiveToolPropertySet
{
public:
	EDisplaceMeshToolDisplaceType                 DisplacementType;                                  // 0x00A8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A9[0x3];                                       // 0x00A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DisplaceIntensity;                                 // 0x00AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RandomSeed;                                        // 0x00B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDisplaceMeshToolSubdivisionType              SubdivisionType;                                   // 0x00B4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B5[0x3];                                       // 0x00B5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Subdivisions;                                      // 0x00B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   WeightMap;                                         // 0x00BC(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C4[0x4];                                       // 0x00C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         WeightMapsList;                                    // 0x00C8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bInvertWeightMap;                                  // 0x00D8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowWireframe;                                    // 0x00D9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisableSizeWarning;                               // 0x00DA(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DB[0x5];                                       // 0x00DB(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	TArray<class FString> GetWeightMapsFunc();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DisplaceMeshCommonProperties">();
	}
	static class UDisplaceMeshCommonProperties* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDisplaceMeshCommonProperties>();
	}
};
static_assert(alignof(UDisplaceMeshCommonProperties) == 0x000008, "Wrong alignment on UDisplaceMeshCommonProperties");
static_assert(sizeof(UDisplaceMeshCommonProperties) == 0x0000E0, "Wrong size on UDisplaceMeshCommonProperties");
static_assert(offsetof(UDisplaceMeshCommonProperties, DisplacementType) == 0x0000A8, "Member 'UDisplaceMeshCommonProperties::DisplacementType' has a wrong offset!");
static_assert(offsetof(UDisplaceMeshCommonProperties, DisplaceIntensity) == 0x0000AC, "Member 'UDisplaceMeshCommonProperties::DisplaceIntensity' has a wrong offset!");
static_assert(offsetof(UDisplaceMeshCommonProperties, RandomSeed) == 0x0000B0, "Member 'UDisplaceMeshCommonProperties::RandomSeed' has a wrong offset!");
static_assert(offsetof(UDisplaceMeshCommonProperties, SubdivisionType) == 0x0000B4, "Member 'UDisplaceMeshCommonProperties::SubdivisionType' has a wrong offset!");
static_assert(offsetof(UDisplaceMeshCommonProperties, Subdivisions) == 0x0000B8, "Member 'UDisplaceMeshCommonProperties::Subdivisions' has a wrong offset!");
static_assert(offsetof(UDisplaceMeshCommonProperties, WeightMap) == 0x0000BC, "Member 'UDisplaceMeshCommonProperties::WeightMap' has a wrong offset!");
static_assert(offsetof(UDisplaceMeshCommonProperties, WeightMapsList) == 0x0000C8, "Member 'UDisplaceMeshCommonProperties::WeightMapsList' has a wrong offset!");
static_assert(offsetof(UDisplaceMeshCommonProperties, bInvertWeightMap) == 0x0000D8, "Member 'UDisplaceMeshCommonProperties::bInvertWeightMap' has a wrong offset!");
static_assert(offsetof(UDisplaceMeshCommonProperties, bShowWireframe) == 0x0000D9, "Member 'UDisplaceMeshCommonProperties::bShowWireframe' has a wrong offset!");
static_assert(offsetof(UDisplaceMeshCommonProperties, bDisableSizeWarning) == 0x0000DA, "Member 'UDisplaceMeshCommonProperties::bDisableSizeWarning' has a wrong offset!");

// Class MeshModelingToolsExp.DisplaceMeshTextureMapProperties
// 0x0048 (0x00F0 - 0x00A8)
class UDisplaceMeshTextureMapProperties final : public UInteractiveToolPropertySet
{
public:
	class UTexture2D*                             DisplacementMap;                                   // 0x00A8(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDisplaceMeshToolChannelType                  Channel;                                           // 0x00B0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B1[0x3];                                       // 0x00B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DisplacementMapBaseValue;                          // 0x00B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              UVScale;                                           // 0x00B8(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              UVOffset;                                          // 0x00C8(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bApplyAdjustmentCurve;                             // 0x00D8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D9[0x7];                                       // 0x00D9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            AdjustmentCurve;                                   // 0x00E0(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRecalcNormals;                                    // 0x00E8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E9[0x7];                                       // 0x00E9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DisplaceMeshTextureMapProperties">();
	}
	static class UDisplaceMeshTextureMapProperties* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDisplaceMeshTextureMapProperties>();
	}
};
static_assert(alignof(UDisplaceMeshTextureMapProperties) == 0x000008, "Wrong alignment on UDisplaceMeshTextureMapProperties");
static_assert(sizeof(UDisplaceMeshTextureMapProperties) == 0x0000F0, "Wrong size on UDisplaceMeshTextureMapProperties");
static_assert(offsetof(UDisplaceMeshTextureMapProperties, DisplacementMap) == 0x0000A8, "Member 'UDisplaceMeshTextureMapProperties::DisplacementMap' has a wrong offset!");
static_assert(offsetof(UDisplaceMeshTextureMapProperties, Channel) == 0x0000B0, "Member 'UDisplaceMeshTextureMapProperties::Channel' has a wrong offset!");
static_assert(offsetof(UDisplaceMeshTextureMapProperties, DisplacementMapBaseValue) == 0x0000B4, "Member 'UDisplaceMeshTextureMapProperties::DisplacementMapBaseValue' has a wrong offset!");
static_assert(offsetof(UDisplaceMeshTextureMapProperties, UVScale) == 0x0000B8, "Member 'UDisplaceMeshTextureMapProperties::UVScale' has a wrong offset!");
static_assert(offsetof(UDisplaceMeshTextureMapProperties, UVOffset) == 0x0000C8, "Member 'UDisplaceMeshTextureMapProperties::UVOffset' has a wrong offset!");
static_assert(offsetof(UDisplaceMeshTextureMapProperties, bApplyAdjustmentCurve) == 0x0000D8, "Member 'UDisplaceMeshTextureMapProperties::bApplyAdjustmentCurve' has a wrong offset!");
static_assert(offsetof(UDisplaceMeshTextureMapProperties, AdjustmentCurve) == 0x0000E0, "Member 'UDisplaceMeshTextureMapProperties::AdjustmentCurve' has a wrong offset!");
static_assert(offsetof(UDisplaceMeshTextureMapProperties, bRecalcNormals) == 0x0000E8, "Member 'UDisplaceMeshTextureMapProperties::bRecalcNormals' has a wrong offset!");

// Class MeshModelingToolsExp.DisplaceMeshPerlinNoiseProperties
// 0x0010 (0x00B8 - 0x00A8)
class UDisplaceMeshPerlinNoiseProperties final : public UInteractiveToolPropertySet
{
public:
	TArray<struct FPerlinLayerProperties>         PerlinLayerProperties;                             // 0x00A8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DisplaceMeshPerlinNoiseProperties">();
	}
	static class UDisplaceMeshPerlinNoiseProperties* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDisplaceMeshPerlinNoiseProperties>();
	}
};
static_assert(alignof(UDisplaceMeshPerlinNoiseProperties) == 0x000008, "Wrong alignment on UDisplaceMeshPerlinNoiseProperties");
static_assert(sizeof(UDisplaceMeshPerlinNoiseProperties) == 0x0000B8, "Wrong size on UDisplaceMeshPerlinNoiseProperties");
static_assert(offsetof(UDisplaceMeshPerlinNoiseProperties, PerlinLayerProperties) == 0x0000A8, "Member 'UDisplaceMeshPerlinNoiseProperties::PerlinLayerProperties' has a wrong offset!");

// Class MeshModelingToolsExp.DisplaceMeshSineWaveProperties
// 0x0020 (0x00C8 - 0x00A8)
class UDisplaceMeshSineWaveProperties final : public UInteractiveToolPropertySet
{
public:
	float                                         SineWaveFrequency;                                 // 0x00A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SineWavePhaseShift;                                // 0x00AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SineWaveDirection;                                 // 0x00B0(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DisplaceMeshSineWaveProperties">();
	}
	static class UDisplaceMeshSineWaveProperties* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDisplaceMeshSineWaveProperties>();
	}
};
static_assert(alignof(UDisplaceMeshSineWaveProperties) == 0x000008, "Wrong alignment on UDisplaceMeshSineWaveProperties");
static_assert(sizeof(UDisplaceMeshSineWaveProperties) == 0x0000C8, "Wrong size on UDisplaceMeshSineWaveProperties");
static_assert(offsetof(UDisplaceMeshSineWaveProperties, SineWaveFrequency) == 0x0000A8, "Member 'UDisplaceMeshSineWaveProperties::SineWaveFrequency' has a wrong offset!");
static_assert(offsetof(UDisplaceMeshSineWaveProperties, SineWavePhaseShift) == 0x0000AC, "Member 'UDisplaceMeshSineWaveProperties::SineWavePhaseShift' has a wrong offset!");
static_assert(offsetof(UDisplaceMeshSineWaveProperties, SineWaveDirection) == 0x0000B0, "Member 'UDisplaceMeshSineWaveProperties::SineWaveDirection' has a wrong offset!");

// Class MeshModelingToolsExp.DisplaceMeshToolBuilder
// 0x0000 (0x0028 - 0x0028)
class UDisplaceMeshToolBuilder final : public USingleSelectionMeshEditingToolBuilder
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DisplaceMeshToolBuilder">();
	}
	static class UDisplaceMeshToolBuilder* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDisplaceMeshToolBuilder>();
	}
};
static_assert(alignof(UDisplaceMeshToolBuilder) == 0x000008, "Wrong alignment on UDisplaceMeshToolBuilder");
static_assert(sizeof(UDisplaceMeshToolBuilder) == 0x000028, "Wrong size on UDisplaceMeshToolBuilder");

// Class MeshModelingToolsExp.DrawPolyPathToolBuilder
// 0x0000 (0x0028 - 0x0028)
class UDrawPolyPathToolBuilder final : public UInteractiveToolBuilder
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DrawPolyPathToolBuilder">();
	}
	static class UDrawPolyPathToolBuilder* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDrawPolyPathToolBuilder>();
	}
};
static_assert(alignof(UDrawPolyPathToolBuilder) == 0x000008, "Wrong alignment on UDrawPolyPathToolBuilder");
static_assert(sizeof(UDrawPolyPathToolBuilder) == 0x000028, "Wrong size on UDrawPolyPathToolBuilder");

// Class MeshModelingToolsExp.DrawPolyPathProperties
// 0x0028 (0x00D0 - 0x00A8)
class UDrawPolyPathProperties final : public UInteractiveToolPropertySet
{
public:
	EDrawPolyPathWidthMode                        WidthMode;                                         // 0x00A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Width;                                             // 0x00AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRoundedCorners;                                   // 0x00B0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B1[0x3];                                       // 0x00B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	EDrawPolyPathRadiusMode                       RadiusMode;                                        // 0x00B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CornerRadius;                                      // 0x00B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RadialSlices;                                      // 0x00BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSinglePolyGroup;                                  // 0x00C0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C1[0x3];                                       // 0x00C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	EDrawPolyPathExtrudeMode                      ExtrudeMode;                                       // 0x00C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExtrudeHeight;                                     // 0x00C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RampStartRatio;                                    // 0x00CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DrawPolyPathProperties">();
	}
	static class UDrawPolyPathProperties* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDrawPolyPathProperties>();
	}
};
static_assert(alignof(UDrawPolyPathProperties) == 0x000008, "Wrong alignment on UDrawPolyPathProperties");
static_assert(sizeof(UDrawPolyPathProperties) == 0x0000D0, "Wrong size on UDrawPolyPathProperties");
static_assert(offsetof(UDrawPolyPathProperties, WidthMode) == 0x0000A8, "Member 'UDrawPolyPathProperties::WidthMode' has a wrong offset!");
static_assert(offsetof(UDrawPolyPathProperties, Width) == 0x0000AC, "Member 'UDrawPolyPathProperties::Width' has a wrong offset!");
static_assert(offsetof(UDrawPolyPathProperties, bRoundedCorners) == 0x0000B0, "Member 'UDrawPolyPathProperties::bRoundedCorners' has a wrong offset!");
static_assert(offsetof(UDrawPolyPathProperties, RadiusMode) == 0x0000B4, "Member 'UDrawPolyPathProperties::RadiusMode' has a wrong offset!");
static_assert(offsetof(UDrawPolyPathProperties, CornerRadius) == 0x0000B8, "Member 'UDrawPolyPathProperties::CornerRadius' has a wrong offset!");
static_assert(offsetof(UDrawPolyPathProperties, RadialSlices) == 0x0000BC, "Member 'UDrawPolyPathProperties::RadialSlices' has a wrong offset!");
static_assert(offsetof(UDrawPolyPathProperties, bSinglePolyGroup) == 0x0000C0, "Member 'UDrawPolyPathProperties::bSinglePolyGroup' has a wrong offset!");
static_assert(offsetof(UDrawPolyPathProperties, ExtrudeMode) == 0x0000C4, "Member 'UDrawPolyPathProperties::ExtrudeMode' has a wrong offset!");
static_assert(offsetof(UDrawPolyPathProperties, ExtrudeHeight) == 0x0000C8, "Member 'UDrawPolyPathProperties::ExtrudeHeight' has a wrong offset!");
static_assert(offsetof(UDrawPolyPathProperties, RampStartRatio) == 0x0000CC, "Member 'UDrawPolyPathProperties::RampStartRatio' has a wrong offset!");

// Class MeshModelingToolsExp.DrawPolyPathExtrudeProperties
// 0x0008 (0x00B0 - 0x00A8)
class UDrawPolyPathExtrudeProperties final : public UInteractiveToolPropertySet
{
public:
	EDrawPolyPathExtrudeDirection                 Direction;                                         // 0x00A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AC[0x4];                                       // 0x00AC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DrawPolyPathExtrudeProperties">();
	}
	static class UDrawPolyPathExtrudeProperties* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDrawPolyPathExtrudeProperties>();
	}
};
static_assert(alignof(UDrawPolyPathExtrudeProperties) == 0x000008, "Wrong alignment on UDrawPolyPathExtrudeProperties");
static_assert(sizeof(UDrawPolyPathExtrudeProperties) == 0x0000B0, "Wrong size on UDrawPolyPathExtrudeProperties");
static_assert(offsetof(UDrawPolyPathExtrudeProperties, Direction) == 0x0000A8, "Member 'UDrawPolyPathExtrudeProperties::Direction' has a wrong offset!");

// Class MeshModelingToolsExp.DrawPolyPathTool
// 0x01E8 (0x0280 - 0x0098)
class alignas(0x10) UDrawPolyPathTool final : public UInteractiveTool
{
public:
	uint8                                         Pad_98[0x18];                                      // 0x0098(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UCreateMeshObjectTypeProperties*        OutputTypeProperties;                              // 0x00B0(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDrawPolyPathProperties*                TransformProps;                                    // 0x00B8(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDrawPolyPathExtrudeProperties*         ExtrudeProperties;                                 // 0x00C0(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNewMeshMaterialProperties*             MaterialProperties;                                // 0x00C8(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D0[0xC0];                                      // 0x00D0(0x00C0)(Fixing Size After Last Property [ Dumper-7 ])
	class UConstructionPlaneMechanic*             PlaneMechanic;                                     // 0x0190(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_198[0xC0];                                     // 0x0198(0x00C0)(Fixing Size After Last Property [ Dumper-7 ])
	class UPolyEditPreviewMesh*                   EditPreview;                                       // 0x0258(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPlaneDistanceFromHitMechanic*          ExtrudeHeightMechanic;                             // 0x0260(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USpatialCurveDistanceMechanic*          CurveDistMechanic;                                 // 0x0268(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCollectSurfacePathMechanic*            SurfacePathMechanic;                               // 0x0270(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_278[0x8];                                      // 0x0278(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DrawPolyPathTool">();
	}
	static class UDrawPolyPathTool* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDrawPolyPathTool>();
	}
};
static_assert(alignof(UDrawPolyPathTool) == 0x000010, "Wrong alignment on UDrawPolyPathTool");
static_assert(sizeof(UDrawPolyPathTool) == 0x000280, "Wrong size on UDrawPolyPathTool");
static_assert(offsetof(UDrawPolyPathTool, OutputTypeProperties) == 0x0000B0, "Member 'UDrawPolyPathTool::OutputTypeProperties' has a wrong offset!");
static_assert(offsetof(UDrawPolyPathTool, TransformProps) == 0x0000B8, "Member 'UDrawPolyPathTool::TransformProps' has a wrong offset!");
static_assert(offsetof(UDrawPolyPathTool, ExtrudeProperties) == 0x0000C0, "Member 'UDrawPolyPathTool::ExtrudeProperties' has a wrong offset!");
static_assert(offsetof(UDrawPolyPathTool, MaterialProperties) == 0x0000C8, "Member 'UDrawPolyPathTool::MaterialProperties' has a wrong offset!");
static_assert(offsetof(UDrawPolyPathTool, PlaneMechanic) == 0x000190, "Member 'UDrawPolyPathTool::PlaneMechanic' has a wrong offset!");
static_assert(offsetof(UDrawPolyPathTool, EditPreview) == 0x000258, "Member 'UDrawPolyPathTool::EditPreview' has a wrong offset!");
static_assert(offsetof(UDrawPolyPathTool, ExtrudeHeightMechanic) == 0x000260, "Member 'UDrawPolyPathTool::ExtrudeHeightMechanic' has a wrong offset!");
static_assert(offsetof(UDrawPolyPathTool, CurveDistMechanic) == 0x000268, "Member 'UDrawPolyPathTool::CurveDistMechanic' has a wrong offset!");
static_assert(offsetof(UDrawPolyPathTool, SurfacePathMechanic) == 0x000270, "Member 'UDrawPolyPathTool::SurfacePathMechanic' has a wrong offset!");

// Class MeshModelingToolsExp.DynamicMeshSculptToolBuilder
// 0x0008 (0x0038 - 0x0030)
class UDynamicMeshSculptToolBuilder final : public UMeshSurfacePointMeshEditingToolBuilder
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DynamicMeshSculptToolBuilder">();
	}
	static class UDynamicMeshSculptToolBuilder* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDynamicMeshSculptToolBuilder>();
	}
};
static_assert(alignof(UDynamicMeshSculptToolBuilder) == 0x000008, "Wrong alignment on UDynamicMeshSculptToolBuilder");
static_assert(sizeof(UDynamicMeshSculptToolBuilder) == 0x000038, "Wrong size on UDynamicMeshSculptToolBuilder");

// Class MeshModelingToolsExp.DynamicMeshBrushProperties
// 0x0020 (0x00C8 - 0x00A8)
class UDynamicMeshBrushProperties final : public UInteractiveToolPropertySet
{
public:
	struct FBrushToolRadius                       BrushSize;                                         // 0x00A8(0x0014)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	float                                         BrushFalloffAmount;                                // 0x00BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Depth;                                             // 0x00C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHitBackFaces;                                     // 0x00C4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C5[0x3];                                       // 0x00C5(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DynamicMeshBrushProperties">();
	}
	static class UDynamicMeshBrushProperties* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDynamicMeshBrushProperties>();
	}
};
static_assert(alignof(UDynamicMeshBrushProperties) == 0x000008, "Wrong alignment on UDynamicMeshBrushProperties");
static_assert(sizeof(UDynamicMeshBrushProperties) == 0x0000C8, "Wrong size on UDynamicMeshBrushProperties");
static_assert(offsetof(UDynamicMeshBrushProperties, BrushSize) == 0x0000A8, "Member 'UDynamicMeshBrushProperties::BrushSize' has a wrong offset!");
static_assert(offsetof(UDynamicMeshBrushProperties, BrushFalloffAmount) == 0x0000BC, "Member 'UDynamicMeshBrushProperties::BrushFalloffAmount' has a wrong offset!");
static_assert(offsetof(UDynamicMeshBrushProperties, Depth) == 0x0000C0, "Member 'UDynamicMeshBrushProperties::Depth' has a wrong offset!");
static_assert(offsetof(UDynamicMeshBrushProperties, bHitBackFaces) == 0x0000C4, "Member 'UDynamicMeshBrushProperties::bHitBackFaces' has a wrong offset!");

// Class MeshModelingToolsExp.DynamicMeshBrushSculptProperties
// 0x0018 (0x00C0 - 0x00A8)
class UDynamicMeshBrushSculptProperties final : public UInteractiveToolPropertySet
{
public:
	bool                                          bIsRemeshingEnabled;                               // 0x00A8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDynamicMeshSculptBrushType                   PrimaryBrushType;                                  // 0x00A9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AA[0x2];                                       // 0x00AA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PrimaryBrushSpeed;                                 // 0x00AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPreserveUVFlow;                                   // 0x00B0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFreezeTarget;                                     // 0x00B1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B2[0x2];                                       // 0x00B2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SmoothBrushSpeed;                                  // 0x00B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDetailPreservingSmooth;                           // 0x00B8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B9[0x7];                                       // 0x00B9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DynamicMeshBrushSculptProperties">();
	}
	static class UDynamicMeshBrushSculptProperties* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDynamicMeshBrushSculptProperties>();
	}
};
static_assert(alignof(UDynamicMeshBrushSculptProperties) == 0x000008, "Wrong alignment on UDynamicMeshBrushSculptProperties");
static_assert(sizeof(UDynamicMeshBrushSculptProperties) == 0x0000C0, "Wrong size on UDynamicMeshBrushSculptProperties");
static_assert(offsetof(UDynamicMeshBrushSculptProperties, bIsRemeshingEnabled) == 0x0000A8, "Member 'UDynamicMeshBrushSculptProperties::bIsRemeshingEnabled' has a wrong offset!");
static_assert(offsetof(UDynamicMeshBrushSculptProperties, PrimaryBrushType) == 0x0000A9, "Member 'UDynamicMeshBrushSculptProperties::PrimaryBrushType' has a wrong offset!");
static_assert(offsetof(UDynamicMeshBrushSculptProperties, PrimaryBrushSpeed) == 0x0000AC, "Member 'UDynamicMeshBrushSculptProperties::PrimaryBrushSpeed' has a wrong offset!");
static_assert(offsetof(UDynamicMeshBrushSculptProperties, bPreserveUVFlow) == 0x0000B0, "Member 'UDynamicMeshBrushSculptProperties::bPreserveUVFlow' has a wrong offset!");
static_assert(offsetof(UDynamicMeshBrushSculptProperties, bFreezeTarget) == 0x0000B1, "Member 'UDynamicMeshBrushSculptProperties::bFreezeTarget' has a wrong offset!");
static_assert(offsetof(UDynamicMeshBrushSculptProperties, SmoothBrushSpeed) == 0x0000B4, "Member 'UDynamicMeshBrushSculptProperties::SmoothBrushSpeed' has a wrong offset!");
static_assert(offsetof(UDynamicMeshBrushSculptProperties, bDetailPreservingSmooth) == 0x0000B8, "Member 'UDynamicMeshBrushSculptProperties::bDetailPreservingSmooth' has a wrong offset!");

// Class MeshModelingToolsExp.DynamicSculptToolActions
// 0x0008 (0x00B0 - 0x00A8)
class UDynamicSculptToolActions final : public UInteractiveToolPropertySet
{
public:
	uint8                                         Pad_A8[0x8];                                       // 0x00A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DiscardAttributes();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DynamicSculptToolActions">();
	}
	static class UDynamicSculptToolActions* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDynamicSculptToolActions>();
	}
};
static_assert(alignof(UDynamicSculptToolActions) == 0x000008, "Wrong alignment on UDynamicSculptToolActions");
static_assert(sizeof(UDynamicSculptToolActions) == 0x0000B0, "Wrong size on UDynamicSculptToolActions");

// Class MeshModelingToolsExp.BrushRemeshProperties
// 0x0010 (0x00C8 - 0x00B8)
class UBrushRemeshProperties final : public URemeshProperties
{
public:
	bool                                          bEnableRemeshing;                                  // 0x00B8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B9[0x3];                                       // 0x00B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         TriangleSize;                                      // 0x00BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PreserveDetail;                                    // 0x00C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Iterations;                                        // 0x00C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrushRemeshProperties">();
	}
	static class UBrushRemeshProperties* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrushRemeshProperties>();
	}
};
static_assert(alignof(UBrushRemeshProperties) == 0x000008, "Wrong alignment on UBrushRemeshProperties");
static_assert(sizeof(UBrushRemeshProperties) == 0x0000C8, "Wrong size on UBrushRemeshProperties");
static_assert(offsetof(UBrushRemeshProperties, bEnableRemeshing) == 0x0000B8, "Member 'UBrushRemeshProperties::bEnableRemeshing' has a wrong offset!");
static_assert(offsetof(UBrushRemeshProperties, TriangleSize) == 0x0000BC, "Member 'UBrushRemeshProperties::TriangleSize' has a wrong offset!");
static_assert(offsetof(UBrushRemeshProperties, PreserveDetail) == 0x0000C0, "Member 'UBrushRemeshProperties::PreserveDetail' has a wrong offset!");
static_assert(offsetof(UBrushRemeshProperties, Iterations) == 0x0000C4, "Member 'UBrushRemeshProperties::Iterations' has a wrong offset!");

// Class MeshModelingToolsExp.FixedPlaneBrushProperties
// 0x0048 (0x00F0 - 0x00A8)
class UFixedPlaneBrushProperties final : public UInteractiveToolPropertySet
{
public:
	bool                                          bPropertySetEnabled;                               // 0x00A8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowGizmo;                                        // 0x00A9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AA[0x6];                                       // 0x00AA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Position;                                          // 0x00B0(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C8[0x8];                                       // 0x00C8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FQuat                                  Rotation;                                          // 0x00D0(0x0020)(Edit, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FixedPlaneBrushProperties">();
	}
	static class UFixedPlaneBrushProperties* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFixedPlaneBrushProperties>();
	}
};
static_assert(alignof(UFixedPlaneBrushProperties) == 0x000010, "Wrong alignment on UFixedPlaneBrushProperties");
static_assert(sizeof(UFixedPlaneBrushProperties) == 0x0000F0, "Wrong size on UFixedPlaneBrushProperties");
static_assert(offsetof(UFixedPlaneBrushProperties, bPropertySetEnabled) == 0x0000A8, "Member 'UFixedPlaneBrushProperties::bPropertySetEnabled' has a wrong offset!");
static_assert(offsetof(UFixedPlaneBrushProperties, bShowGizmo) == 0x0000A9, "Member 'UFixedPlaneBrushProperties::bShowGizmo' has a wrong offset!");
static_assert(offsetof(UFixedPlaneBrushProperties, Position) == 0x0000B0, "Member 'UFixedPlaneBrushProperties::Position' has a wrong offset!");
static_assert(offsetof(UFixedPlaneBrushProperties, Rotation) == 0x0000D0, "Member 'UFixedPlaneBrushProperties::Rotation' has a wrong offset!");

// Class MeshModelingToolsExp.DynamicMeshSculptTool
// 0x0F20 (0x1020 - 0x0100)
class alignas(0x10) UDynamicMeshSculptTool final : public UMeshSurfacePointTool
{
public:
	class UDynamicMeshBrushProperties*            BrushProperties;                                   // 0x0100(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDynamicMeshBrushSculptProperties*      SculptProperties;                                  // 0x0108(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USculptMaxBrushProperties*              SculptMaxBrushProperties;                          // 0x0110(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UKelvinBrushProperties*                 KelvinBrushProperties;                             // 0x0118(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBrushRemeshProperties*                 RemeshProperties;                                  // 0x0120(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFixedPlaneBrushProperties*             GizmoProperties;                                   // 0x0128(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMeshEditingViewProperties*             ViewProperties;                                    // 0x0130(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDynamicSculptToolActions*              SculptToolActions;                                 // 0x0138(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_140[0x60];                                     // 0x0140(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	class UBrushStampIndicator*                   BrushIndicator;                                    // 0x01A0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInstanceDynamic*               BrushIndicatorMaterial;                            // 0x01A8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPreviewMesh*                           BrushIndicatorMesh;                                // 0x01B0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AInternalToolFrameworkActor*            PreviewMeshActor;                                  // 0x01B8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UOctreeDynamicMeshComponent*            DynamicMeshComponent;                              // 0x01C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInstanceDynamic*               ActiveOverrideMaterial;                            // 0x01C8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1D0[0xE38];                                    // 0x01D0(0x0E38)(Fixing Size After Last Property [ Dumper-7 ])
	class UCombinedTransformGizmo*                PlaneTransformGizmo;                               // 0x1008(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTransformProxy*                        PlaneTransformProxy;                               // 0x1010(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1018[0x8];                                     // 0x1018(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DynamicMeshSculptTool">();
	}
	static class UDynamicMeshSculptTool* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDynamicMeshSculptTool>();
	}
};
static_assert(alignof(UDynamicMeshSculptTool) == 0x000010, "Wrong alignment on UDynamicMeshSculptTool");
static_assert(sizeof(UDynamicMeshSculptTool) == 0x001020, "Wrong size on UDynamicMeshSculptTool");
static_assert(offsetof(UDynamicMeshSculptTool, BrushProperties) == 0x000100, "Member 'UDynamicMeshSculptTool::BrushProperties' has a wrong offset!");
static_assert(offsetof(UDynamicMeshSculptTool, SculptProperties) == 0x000108, "Member 'UDynamicMeshSculptTool::SculptProperties' has a wrong offset!");
static_assert(offsetof(UDynamicMeshSculptTool, SculptMaxBrushProperties) == 0x000110, "Member 'UDynamicMeshSculptTool::SculptMaxBrushProperties' has a wrong offset!");
static_assert(offsetof(UDynamicMeshSculptTool, KelvinBrushProperties) == 0x000118, "Member 'UDynamicMeshSculptTool::KelvinBrushProperties' has a wrong offset!");
static_assert(offsetof(UDynamicMeshSculptTool, RemeshProperties) == 0x000120, "Member 'UDynamicMeshSculptTool::RemeshProperties' has a wrong offset!");
static_assert(offsetof(UDynamicMeshSculptTool, GizmoProperties) == 0x000128, "Member 'UDynamicMeshSculptTool::GizmoProperties' has a wrong offset!");
static_assert(offsetof(UDynamicMeshSculptTool, ViewProperties) == 0x000130, "Member 'UDynamicMeshSculptTool::ViewProperties' has a wrong offset!");
static_assert(offsetof(UDynamicMeshSculptTool, SculptToolActions) == 0x000138, "Member 'UDynamicMeshSculptTool::SculptToolActions' has a wrong offset!");
static_assert(offsetof(UDynamicMeshSculptTool, BrushIndicator) == 0x0001A0, "Member 'UDynamicMeshSculptTool::BrushIndicator' has a wrong offset!");
static_assert(offsetof(UDynamicMeshSculptTool, BrushIndicatorMaterial) == 0x0001A8, "Member 'UDynamicMeshSculptTool::BrushIndicatorMaterial' has a wrong offset!");
static_assert(offsetof(UDynamicMeshSculptTool, BrushIndicatorMesh) == 0x0001B0, "Member 'UDynamicMeshSculptTool::BrushIndicatorMesh' has a wrong offset!");
static_assert(offsetof(UDynamicMeshSculptTool, PreviewMeshActor) == 0x0001B8, "Member 'UDynamicMeshSculptTool::PreviewMeshActor' has a wrong offset!");
static_assert(offsetof(UDynamicMeshSculptTool, DynamicMeshComponent) == 0x0001C0, "Member 'UDynamicMeshSculptTool::DynamicMeshComponent' has a wrong offset!");
static_assert(offsetof(UDynamicMeshSculptTool, ActiveOverrideMaterial) == 0x0001C8, "Member 'UDynamicMeshSculptTool::ActiveOverrideMaterial' has a wrong offset!");
static_assert(offsetof(UDynamicMeshSculptTool, PlaneTransformGizmo) == 0x001008, "Member 'UDynamicMeshSculptTool::PlaneTransformGizmo' has a wrong offset!");
static_assert(offsetof(UDynamicMeshSculptTool, PlaneTransformProxy) == 0x001010, "Member 'UDynamicMeshSculptTool::PlaneTransformProxy' has a wrong offset!");

// Class MeshModelingToolsExp.EditNormalsToolBuilder
// 0x0000 (0x0028 - 0x0028)
class UEditNormalsToolBuilder final : public UMultiSelectionMeshEditingToolBuilder
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EditNormalsToolBuilder">();
	}
	static class UEditNormalsToolBuilder* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEditNormalsToolBuilder>();
	}
};
static_assert(alignof(UEditNormalsToolBuilder) == 0x000008, "Wrong alignment on UEditNormalsToolBuilder");
static_assert(sizeof(UEditNormalsToolBuilder) == 0x000028, "Wrong size on UEditNormalsToolBuilder");

// Class MeshModelingToolsExp.EditNormalsToolProperties
// 0x0010 (0x00B8 - 0x00A8)
class UEditNormalsToolProperties final : public UInteractiveToolPropertySet
{
public:
	bool                                          bRecomputeNormals;                                 // 0x00A8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ENormalCalculationMethod                      NormalCalculationMethod;                           // 0x00A9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFixInconsistentNormals;                           // 0x00AA(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInvertNormals;                                    // 0x00AB(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESplitNormalMethod                            SplitNormalMethod;                                 // 0x00AC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AD[0x3];                                       // 0x00AD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SharpEdgeAngleThreshold;                           // 0x00B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowSharpVertices;                               // 0x00B4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bToolHasSelection;                                 // 0x00B5(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B6[0x2];                                       // 0x00B6(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EditNormalsToolProperties">();
	}
	static class UEditNormalsToolProperties* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEditNormalsToolProperties>();
	}
};
static_assert(alignof(UEditNormalsToolProperties) == 0x000008, "Wrong alignment on UEditNormalsToolProperties");
static_assert(sizeof(UEditNormalsToolProperties) == 0x0000B8, "Wrong size on UEditNormalsToolProperties");
static_assert(offsetof(UEditNormalsToolProperties, bRecomputeNormals) == 0x0000A8, "Member 'UEditNormalsToolProperties::bRecomputeNormals' has a wrong offset!");
static_assert(offsetof(UEditNormalsToolProperties, NormalCalculationMethod) == 0x0000A9, "Member 'UEditNormalsToolProperties::NormalCalculationMethod' has a wrong offset!");
static_assert(offsetof(UEditNormalsToolProperties, bFixInconsistentNormals) == 0x0000AA, "Member 'UEditNormalsToolProperties::bFixInconsistentNormals' has a wrong offset!");
static_assert(offsetof(UEditNormalsToolProperties, bInvertNormals) == 0x0000AB, "Member 'UEditNormalsToolProperties::bInvertNormals' has a wrong offset!");
static_assert(offsetof(UEditNormalsToolProperties, SplitNormalMethod) == 0x0000AC, "Member 'UEditNormalsToolProperties::SplitNormalMethod' has a wrong offset!");
static_assert(offsetof(UEditNormalsToolProperties, SharpEdgeAngleThreshold) == 0x0000B0, "Member 'UEditNormalsToolProperties::SharpEdgeAngleThreshold' has a wrong offset!");
static_assert(offsetof(UEditNormalsToolProperties, bAllowSharpVertices) == 0x0000B4, "Member 'UEditNormalsToolProperties::bAllowSharpVertices' has a wrong offset!");
static_assert(offsetof(UEditNormalsToolProperties, bToolHasSelection) == 0x0000B5, "Member 'UEditNormalsToolProperties::bToolHasSelection' has a wrong offset!");

// Class MeshModelingToolsExp.EditNormalsOperatorFactory
// 0x0018 (0x0040 - 0x0028)
class UEditNormalsOperatorFactory final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UEditNormalsTool*                       Tool;                                              // 0x0030(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EditNormalsOperatorFactory">();
	}
	static class UEditNormalsOperatorFactory* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEditNormalsOperatorFactory>();
	}
};
static_assert(alignof(UEditNormalsOperatorFactory) == 0x000008, "Wrong alignment on UEditNormalsOperatorFactory");
static_assert(sizeof(UEditNormalsOperatorFactory) == 0x000040, "Wrong size on UEditNormalsOperatorFactory");
static_assert(offsetof(UEditNormalsOperatorFactory, Tool) == 0x000030, "Member 'UEditNormalsOperatorFactory::Tool' has a wrong offset!");

// Class MeshModelingToolsExp.EditNormalsTool
// 0x0208 (0x02C0 - 0x00B8)
class alignas(0x10) UEditNormalsTool final : public UMultiSelectionMeshEditingTool
{
public:
	uint8                                         Pad_B8[0x8];                                       // 0x00B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UEditNormalsToolProperties*             BasicProperties;                                   // 0x00C0(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPolygroupLayersProperties*             PolygroupLayerProperties;                          // 0x00C8(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UMeshOpPreviewWithBackgroundCompute*> Previews;                                          // 0x00D0(0x0010)(ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	uint8                                         Pad_E0[0x70];                                      // 0x00E0(0x0070)(Fixing Size After Last Property [ Dumper-7 ])
	class UGeometrySelectionVisualizationProperties* GeometrySelectionVizProperties;                    // 0x0150(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPreviewGeometry*                       GeometrySelectionViz;                              // 0x0158(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_160[0x160];                                    // 0x0160(0x0160)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EditNormalsTool">();
	}
	static class UEditNormalsTool* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEditNormalsTool>();
	}
};
static_assert(alignof(UEditNormalsTool) == 0x000010, "Wrong alignment on UEditNormalsTool");
static_assert(sizeof(UEditNormalsTool) == 0x0002C0, "Wrong size on UEditNormalsTool");
static_assert(offsetof(UEditNormalsTool, BasicProperties) == 0x0000C0, "Member 'UEditNormalsTool::BasicProperties' has a wrong offset!");
static_assert(offsetof(UEditNormalsTool, PolygroupLayerProperties) == 0x0000C8, "Member 'UEditNormalsTool::PolygroupLayerProperties' has a wrong offset!");
static_assert(offsetof(UEditNormalsTool, Previews) == 0x0000D0, "Member 'UEditNormalsTool::Previews' has a wrong offset!");
static_assert(offsetof(UEditNormalsTool, GeometrySelectionVizProperties) == 0x000150, "Member 'UEditNormalsTool::GeometrySelectionVizProperties' has a wrong offset!");
static_assert(offsetof(UEditNormalsTool, GeometrySelectionViz) == 0x000158, "Member 'UEditNormalsTool::GeometrySelectionViz' has a wrong offset!");

// Class MeshModelingToolsExp.EditPivotToolBuilder
// 0x0000 (0x0028 - 0x0028)
class UEditPivotToolBuilder final : public UMultiSelectionMeshEditingToolBuilder
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EditPivotToolBuilder">();
	}
	static class UEditPivotToolBuilder* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEditPivotToolBuilder>();
	}
};
static_assert(alignof(UEditPivotToolBuilder) == 0x000008, "Wrong alignment on UEditPivotToolBuilder");
static_assert(sizeof(UEditPivotToolBuilder) == 0x000028, "Wrong size on UEditPivotToolBuilder");

// Class MeshModelingToolsExp.EditPivotToolActionPropertySet
// 0x0010 (0x00B8 - 0x00A8)
class UEditPivotToolActionPropertySet final : public UInteractiveToolPropertySet
{
public:
	uint8                                         Pad_A8[0x8];                                       // 0x00A8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bUseWorldBox;                                      // 0x00B0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B1[0x7];                                       // 0x00B1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Back();
	void Bottom();
	void Center();
	void Front();
	void Left();
	void Right();
	void Top();
	void WorldOrigin();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EditPivotToolActionPropertySet">();
	}
	static class UEditPivotToolActionPropertySet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEditPivotToolActionPropertySet>();
	}
};
static_assert(alignof(UEditPivotToolActionPropertySet) == 0x000008, "Wrong alignment on UEditPivotToolActionPropertySet");
static_assert(sizeof(UEditPivotToolActionPropertySet) == 0x0000B8, "Wrong size on UEditPivotToolActionPropertySet");
static_assert(offsetof(UEditPivotToolActionPropertySet, bUseWorldBox) == 0x0000B0, "Member 'UEditPivotToolActionPropertySet::bUseWorldBox' has a wrong offset!");

// Class MeshModelingToolsExp.EditUVIslandsToolBuilder
// 0x0000 (0x0030 - 0x0030)
class UEditUVIslandsToolBuilder final : public UMeshSurfacePointMeshEditingToolBuilder
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EditUVIslandsToolBuilder">();
	}
	static class UEditUVIslandsToolBuilder* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEditUVIslandsToolBuilder>();
	}
};
static_assert(alignof(UEditUVIslandsToolBuilder) == 0x000008, "Wrong alignment on UEditUVIslandsToolBuilder");
static_assert(sizeof(UEditUVIslandsToolBuilder) == 0x000030, "Wrong size on UEditUVIslandsToolBuilder");

// Class MeshModelingToolsExp.EditUVIslandsTool
// 0x03E0 (0x04E0 - 0x0100)
class alignas(0x10) UEditUVIslandsTool final : public UMeshSurfacePointTool
{
public:
	uint8                                         Pad_100[0x8];                                      // 0x0100(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UExistingMeshMaterialProperties*        MaterialSettings;                                  // 0x0108(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*               CheckerMaterial;                                   // 0x0110(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AInternalToolFrameworkActor*            PreviewMeshActor;                                  // 0x0118(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDynamicMeshComponent*                  DynamicMeshComponent;                              // 0x0120(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPolygonSelectionMechanic*              SelectionMechanic;                                 // 0x0128(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_130[0x8];                                      // 0x0130(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UCombinedTransformGizmo*                TransformGizmo;                                    // 0x0138(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTransformProxy*                        TransformProxy;                                    // 0x0140(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_148[0x398];                                    // 0x0148(0x0398)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EditUVIslandsTool">();
	}
	static class UEditUVIslandsTool* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEditUVIslandsTool>();
	}
};
static_assert(alignof(UEditUVIslandsTool) == 0x000010, "Wrong alignment on UEditUVIslandsTool");
static_assert(sizeof(UEditUVIslandsTool) == 0x0004E0, "Wrong size on UEditUVIslandsTool");
static_assert(offsetof(UEditUVIslandsTool, MaterialSettings) == 0x000108, "Member 'UEditUVIslandsTool::MaterialSettings' has a wrong offset!");
static_assert(offsetof(UEditUVIslandsTool, CheckerMaterial) == 0x000110, "Member 'UEditUVIslandsTool::CheckerMaterial' has a wrong offset!");
static_assert(offsetof(UEditUVIslandsTool, PreviewMeshActor) == 0x000118, "Member 'UEditUVIslandsTool::PreviewMeshActor' has a wrong offset!");
static_assert(offsetof(UEditUVIslandsTool, DynamicMeshComponent) == 0x000120, "Member 'UEditUVIslandsTool::DynamicMeshComponent' has a wrong offset!");
static_assert(offsetof(UEditUVIslandsTool, SelectionMechanic) == 0x000128, "Member 'UEditUVIslandsTool::SelectionMechanic' has a wrong offset!");
static_assert(offsetof(UEditUVIslandsTool, TransformGizmo) == 0x000138, "Member 'UEditUVIslandsTool::TransformGizmo' has a wrong offset!");
static_assert(offsetof(UEditUVIslandsTool, TransformProxy) == 0x000140, "Member 'UEditUVIslandsTool::TransformProxy' has a wrong offset!");

// Class MeshModelingToolsExp.HoleFillToolBuilder
// 0x0000 (0x0028 - 0x0028)
class UHoleFillToolBuilder final : public USingleSelectionMeshEditingToolBuilder
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HoleFillToolBuilder">();
	}
	static class UHoleFillToolBuilder* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHoleFillToolBuilder>();
	}
};
static_assert(alignof(UHoleFillToolBuilder) == 0x000008, "Wrong alignment on UHoleFillToolBuilder");
static_assert(sizeof(UHoleFillToolBuilder) == 0x000028, "Wrong size on UHoleFillToolBuilder");

// Class MeshModelingToolsExp.HoleFillToolProperties
// 0x0008 (0x00B0 - 0x00A8)
class UHoleFillToolProperties final : public UInteractiveToolPropertySet
{
public:
	EHoleFillOpFillType                           FillType;                                          // 0x00A8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRemoveIsolatedTriangles;                          // 0x00A9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bQuickFillSmallHoles;                              // 0x00AA(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AB[0x5];                                       // 0x00AB(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HoleFillToolProperties">();
	}
	static class UHoleFillToolProperties* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHoleFillToolProperties>();
	}
};
static_assert(alignof(UHoleFillToolProperties) == 0x000008, "Wrong alignment on UHoleFillToolProperties");
static_assert(sizeof(UHoleFillToolProperties) == 0x0000B0, "Wrong size on UHoleFillToolProperties");
static_assert(offsetof(UHoleFillToolProperties, FillType) == 0x0000A8, "Member 'UHoleFillToolProperties::FillType' has a wrong offset!");
static_assert(offsetof(UHoleFillToolProperties, bRemoveIsolatedTriangles) == 0x0000A9, "Member 'UHoleFillToolProperties::bRemoveIsolatedTriangles' has a wrong offset!");
static_assert(offsetof(UHoleFillToolProperties, bQuickFillSmallHoles) == 0x0000AA, "Member 'UHoleFillToolProperties::bQuickFillSmallHoles' has a wrong offset!");

// Class MeshModelingToolsExp.HoleFillToolActions
// 0x0008 (0x00B0 - 0x00A8)
class UHoleFillToolActions final : public UInteractiveToolPropertySet
{
public:
	uint8                                         Pad_A8[0x8];                                       // 0x00A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Clear();
	void SelectAll();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HoleFillToolActions">();
	}
	static class UHoleFillToolActions* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHoleFillToolActions>();
	}
};
static_assert(alignof(UHoleFillToolActions) == 0x000008, "Wrong alignment on UHoleFillToolActions");
static_assert(sizeof(UHoleFillToolActions) == 0x0000B0, "Wrong size on UHoleFillToolActions");

// Class MeshModelingToolsExp.HoleFillStatisticsProperties
// 0x0050 (0x00F8 - 0x00A8)
class UHoleFillStatisticsProperties final : public UInteractiveToolPropertySet
{
public:
	class FString                                 InitialHoles;                                      // 0x00A8(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SelectedHoles;                                     // 0x00B8(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SuccessfulFills;                                   // 0x00C8(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 FailedFills;                                       // 0x00D8(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 RemainingHoles;                                    // 0x00E8(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HoleFillStatisticsProperties">();
	}
	static class UHoleFillStatisticsProperties* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHoleFillStatisticsProperties>();
	}
};
static_assert(alignof(UHoleFillStatisticsProperties) == 0x000008, "Wrong alignment on UHoleFillStatisticsProperties");
static_assert(sizeof(UHoleFillStatisticsProperties) == 0x0000F8, "Wrong size on UHoleFillStatisticsProperties");
static_assert(offsetof(UHoleFillStatisticsProperties, InitialHoles) == 0x0000A8, "Member 'UHoleFillStatisticsProperties::InitialHoles' has a wrong offset!");
static_assert(offsetof(UHoleFillStatisticsProperties, SelectedHoles) == 0x0000B8, "Member 'UHoleFillStatisticsProperties::SelectedHoles' has a wrong offset!");
static_assert(offsetof(UHoleFillStatisticsProperties, SuccessfulFills) == 0x0000C8, "Member 'UHoleFillStatisticsProperties::SuccessfulFills' has a wrong offset!");
static_assert(offsetof(UHoleFillStatisticsProperties, FailedFills) == 0x0000D8, "Member 'UHoleFillStatisticsProperties::FailedFills' has a wrong offset!");
static_assert(offsetof(UHoleFillStatisticsProperties, RemainingHoles) == 0x0000E8, "Member 'UHoleFillStatisticsProperties::RemainingHoles' has a wrong offset!");

// Class MeshModelingToolsExp.HoleFillOperatorFactory
// 0x0010 (0x0038 - 0x0028)
class UHoleFillOperatorFactory final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UHoleFillTool*                          FillTool;                                          // 0x0030(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HoleFillOperatorFactory">();
	}
	static class UHoleFillOperatorFactory* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHoleFillOperatorFactory>();
	}
};
static_assert(alignof(UHoleFillOperatorFactory) == 0x000008, "Wrong alignment on UHoleFillOperatorFactory");
static_assert(sizeof(UHoleFillOperatorFactory) == 0x000038, "Wrong size on UHoleFillOperatorFactory");
static_assert(offsetof(UHoleFillOperatorFactory, FillTool) == 0x000030, "Member 'UHoleFillOperatorFactory::FillTool' has a wrong offset!");

// Class MeshModelingToolsExp.HoleFillTool
// 0x0190 (0x0240 - 0x00B0)
class alignas(0x10) UHoleFillTool final : public USingleSelectionMeshEditingTool
{
public:
	class USmoothHoleFillProperties*              SmoothHoleFillProperties;                          // 0x00B0(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHoleFillToolProperties*                Properties;                                        // 0x00B8(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHoleFillToolActions*                   Actions;                                           // 0x00C0(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHoleFillStatisticsProperties*          Statistics;                                        // 0x00C8(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMeshOpPreviewWithBackgroundCompute*    Preview;                                           // 0x00D0(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoundarySelectionMechanic*             SelectionMechanic;                                 // 0x00D8(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E0[0x160];                                     // 0x00E0(0x0160)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HoleFillTool">();
	}
	static class UHoleFillTool* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHoleFillTool>();
	}
};
static_assert(alignof(UHoleFillTool) == 0x000010, "Wrong alignment on UHoleFillTool");
static_assert(sizeof(UHoleFillTool) == 0x000240, "Wrong size on UHoleFillTool");
static_assert(offsetof(UHoleFillTool, SmoothHoleFillProperties) == 0x0000B0, "Member 'UHoleFillTool::SmoothHoleFillProperties' has a wrong offset!");
static_assert(offsetof(UHoleFillTool, Properties) == 0x0000B8, "Member 'UHoleFillTool::Properties' has a wrong offset!");
static_assert(offsetof(UHoleFillTool, Actions) == 0x0000C0, "Member 'UHoleFillTool::Actions' has a wrong offset!");
static_assert(offsetof(UHoleFillTool, Statistics) == 0x0000C8, "Member 'UHoleFillTool::Statistics' has a wrong offset!");
static_assert(offsetof(UHoleFillTool, Preview) == 0x0000D0, "Member 'UHoleFillTool::Preview' has a wrong offset!");
static_assert(offsetof(UHoleFillTool, SelectionMechanic) == 0x0000D8, "Member 'UHoleFillTool::SelectionMechanic' has a wrong offset!");

// Class MeshModelingToolsExp.LatticeDeformerToolProperties
// 0x0020 (0x00C8 - 0x00A8)
class ULatticeDeformerToolProperties final : public UInteractiveToolPropertySet
{
public:
	uint8                                         Pad_A8[0x8];                                       // 0x00A8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         XAxisResolution;                                   // 0x00B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         YAxisResolution;                                   // 0x00B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ZAxisResolution;                                   // 0x00B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Padding;                                           // 0x00BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELatticeInterpolationType                     InterpolationType;                                 // 0x00C0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDeformNormals;                                    // 0x00C1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanChangeResolution;                              // 0x00C2(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EToolContextCoordinateSystem                  GizmoCoordinateSystem;                             // 0x00C3(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSetPivotMode;                                     // 0x00C4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSoftDeformation;                                  // 0x00C5(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C6[0x2];                                       // 0x00C6(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClearConstraints();
	void Constrain();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LatticeDeformerToolProperties">();
	}
	static class ULatticeDeformerToolProperties* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULatticeDeformerToolProperties>();
	}
};
static_assert(alignof(ULatticeDeformerToolProperties) == 0x000008, "Wrong alignment on ULatticeDeformerToolProperties");
static_assert(sizeof(ULatticeDeformerToolProperties) == 0x0000C8, "Wrong size on ULatticeDeformerToolProperties");
static_assert(offsetof(ULatticeDeformerToolProperties, XAxisResolution) == 0x0000B0, "Member 'ULatticeDeformerToolProperties::XAxisResolution' has a wrong offset!");
static_assert(offsetof(ULatticeDeformerToolProperties, YAxisResolution) == 0x0000B4, "Member 'ULatticeDeformerToolProperties::YAxisResolution' has a wrong offset!");
static_assert(offsetof(ULatticeDeformerToolProperties, ZAxisResolution) == 0x0000B8, "Member 'ULatticeDeformerToolProperties::ZAxisResolution' has a wrong offset!");
static_assert(offsetof(ULatticeDeformerToolProperties, Padding) == 0x0000BC, "Member 'ULatticeDeformerToolProperties::Padding' has a wrong offset!");
static_assert(offsetof(ULatticeDeformerToolProperties, InterpolationType) == 0x0000C0, "Member 'ULatticeDeformerToolProperties::InterpolationType' has a wrong offset!");
static_assert(offsetof(ULatticeDeformerToolProperties, bDeformNormals) == 0x0000C1, "Member 'ULatticeDeformerToolProperties::bDeformNormals' has a wrong offset!");
static_assert(offsetof(ULatticeDeformerToolProperties, bCanChangeResolution) == 0x0000C2, "Member 'ULatticeDeformerToolProperties::bCanChangeResolution' has a wrong offset!");
static_assert(offsetof(ULatticeDeformerToolProperties, GizmoCoordinateSystem) == 0x0000C3, "Member 'ULatticeDeformerToolProperties::GizmoCoordinateSystem' has a wrong offset!");
static_assert(offsetof(ULatticeDeformerToolProperties, bSetPivotMode) == 0x0000C4, "Member 'ULatticeDeformerToolProperties::bSetPivotMode' has a wrong offset!");
static_assert(offsetof(ULatticeDeformerToolProperties, bSoftDeformation) == 0x0000C5, "Member 'ULatticeDeformerToolProperties::bSoftDeformation' has a wrong offset!");

// Class MeshModelingToolsExp.LatticeDeformerOperatorFactory
// 0x0010 (0x0038 - 0x0028)
class ULatticeDeformerOperatorFactory final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class ULatticeDeformerTool*                   LatticeDeformerTool;                               // 0x0030(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LatticeDeformerOperatorFactory">();
	}
	static class ULatticeDeformerOperatorFactory* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULatticeDeformerOperatorFactory>();
	}
};
static_assert(alignof(ULatticeDeformerOperatorFactory) == 0x000008, "Wrong alignment on ULatticeDeformerOperatorFactory");
static_assert(sizeof(ULatticeDeformerOperatorFactory) == 0x000038, "Wrong size on ULatticeDeformerOperatorFactory");
static_assert(offsetof(ULatticeDeformerOperatorFactory, LatticeDeformerTool) == 0x000030, "Member 'ULatticeDeformerOperatorFactory::LatticeDeformerTool' has a wrong offset!");

// Class MeshModelingToolsExp.LatticeDeformerTool
// 0x00B0 (0x0160 - 0x00B0)
class ULatticeDeformerTool final : public USingleSelectionMeshEditingTool
{
public:
	uint8                                         Pad_B0[0x28];                                      // 0x00B0(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	class ULatticeControlPointsMechanic*          ControlPointsMechanic;                             // 0x00D8(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ULatticeDeformerToolProperties*         Settings;                                          // 0x00E0(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMeshOpPreviewWithBackgroundCompute*    Preview;                                           // 0x00E8(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bLatticeDeformed;                                  // 0x00F0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_F1[0x6F];                                      // 0x00F1(0x006F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LatticeDeformerTool">();
	}
	static class ULatticeDeformerTool* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULatticeDeformerTool>();
	}
};
static_assert(alignof(ULatticeDeformerTool) == 0x000008, "Wrong alignment on ULatticeDeformerTool");
static_assert(sizeof(ULatticeDeformerTool) == 0x000160, "Wrong size on ULatticeDeformerTool");
static_assert(offsetof(ULatticeDeformerTool, ControlPointsMechanic) == 0x0000D8, "Member 'ULatticeDeformerTool::ControlPointsMechanic' has a wrong offset!");
static_assert(offsetof(ULatticeDeformerTool, Settings) == 0x0000E0, "Member 'ULatticeDeformerTool::Settings' has a wrong offset!");
static_assert(offsetof(ULatticeDeformerTool, Preview) == 0x0000E8, "Member 'ULatticeDeformerTool::Preview' has a wrong offset!");
static_assert(offsetof(ULatticeDeformerTool, bLatticeDeformed) == 0x0000F0, "Member 'ULatticeDeformerTool::bLatticeDeformed' has a wrong offset!");

// Class MeshModelingToolsExp.MeshAttributePaintBrushOperationProperties
// 0x0008 (0x00B0 - 0x00A8)
class UMeshAttributePaintBrushOperationProperties final : public UInteractiveToolPropertySet
{
public:
	EBrushActionMode                              BrushAction;                                       // 0x00A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AC[0x4];                                       // 0x00AC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MeshAttributePaintBrushOperationProperties">();
	}
	static class UMeshAttributePaintBrushOperationProperties* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMeshAttributePaintBrushOperationProperties>();
	}
};
static_assert(alignof(UMeshAttributePaintBrushOperationProperties) == 0x000008, "Wrong alignment on UMeshAttributePaintBrushOperationProperties");
static_assert(sizeof(UMeshAttributePaintBrushOperationProperties) == 0x0000B0, "Wrong size on UMeshAttributePaintBrushOperationProperties");
static_assert(offsetof(UMeshAttributePaintBrushOperationProperties, BrushAction) == 0x0000A8, "Member 'UMeshAttributePaintBrushOperationProperties::BrushAction' has a wrong offset!");

// Class MeshModelingToolsExp.MeshAttributePaintEditActions
// 0x0008 (0x00B0 - 0x00A8)
class UMeshAttributePaintEditActions final : public UInteractiveToolPropertySet
{
public:
	uint8                                         Pad_A8[0x8];                                       // 0x00A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MeshAttributePaintEditActions">();
	}
	static class UMeshAttributePaintEditActions* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMeshAttributePaintEditActions>();
	}
};
static_assert(alignof(UMeshAttributePaintEditActions) == 0x000008, "Wrong alignment on UMeshAttributePaintEditActions");
static_assert(sizeof(UMeshAttributePaintEditActions) == 0x0000B0, "Wrong size on UMeshAttributePaintEditActions");

// Class MeshModelingToolsExp.MeshBoundaryToolBase
// 0x00F0 (0x01A0 - 0x00B0)
class alignas(0x10) UMeshBoundaryToolBase : public USingleSelectionMeshEditingTool
{
public:
	uint8                                         Pad_B0[0xE0];                                      // 0x00B0(0x00E0)(Fixing Size After Last Property [ Dumper-7 ])
	class UPolygonSelectionMechanic*              SelectionMechanic;                                 // 0x0190(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_198[0x8];                                      // 0x0198(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MeshBoundaryToolBase">();
	}
	static class UMeshBoundaryToolBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMeshBoundaryToolBase>();
	}
};
static_assert(alignof(UMeshBoundaryToolBase) == 0x000010, "Wrong alignment on UMeshBoundaryToolBase");
static_assert(sizeof(UMeshBoundaryToolBase) == 0x0001A0, "Wrong size on UMeshBoundaryToolBase");
static_assert(offsetof(UMeshBoundaryToolBase, SelectionMechanic) == 0x000190, "Member 'UMeshBoundaryToolBase::SelectionMechanic' has a wrong offset!");

// Class MeshModelingToolsExp.GroupPaintBrushFilterProperties
// 0x0030 (0x00D8 - 0x00A8)
class UGroupPaintBrushFilterProperties final : public UInteractiveToolPropertySet
{
public:
	EMeshGroupPaintBrushType                      PrimaryBrushType;                                  // 0x00A8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMeshGroupPaintInteractionType                SubToolType;                                       // 0x00A9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AA[0x2];                                       // 0x00AA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BrushSize;                                         // 0x00AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMeshGroupPaintBrushAreaType                  BrushAreaMode;                                     // 0x00B0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHitBackFaces;                                     // 0x00B1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B2[0x2];                                       // 0x00B2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SetGroup;                                          // 0x00B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOnlySetUngrouped;                                 // 0x00B8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B9[0x3];                                       // 0x00B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         EraseGroup;                                        // 0x00BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOnlyEraseCurrent;                                 // 0x00C0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C1[0x3];                                       // 0x00C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AngleThreshold;                                    // 0x00C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUVSeams;                                          // 0x00C8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNormalSeams;                                      // 0x00C9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMeshGroupPaintVisibilityType                 VisibilityFilter;                                  // 0x00CA(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CB[0x1];                                       // 0x00CB(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MinTriVertCount;                                   // 0x00CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowHitGroup;                                     // 0x00D0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowAllGroups;                                    // 0x00D1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D2[0x6];                                       // 0x00D2(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GroupPaintBrushFilterProperties">();
	}
	static class UGroupPaintBrushFilterProperties* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGroupPaintBrushFilterProperties>();
	}
};
static_assert(alignof(UGroupPaintBrushFilterProperties) == 0x000008, "Wrong alignment on UGroupPaintBrushFilterProperties");
static_assert(sizeof(UGroupPaintBrushFilterProperties) == 0x0000D8, "Wrong size on UGroupPaintBrushFilterProperties");
static_assert(offsetof(UGroupPaintBrushFilterProperties, PrimaryBrushType) == 0x0000A8, "Member 'UGroupPaintBrushFilterProperties::PrimaryBrushType' has a wrong offset!");
static_assert(offsetof(UGroupPaintBrushFilterProperties, SubToolType) == 0x0000A9, "Member 'UGroupPaintBrushFilterProperties::SubToolType' has a wrong offset!");
static_assert(offsetof(UGroupPaintBrushFilterProperties, BrushSize) == 0x0000AC, "Member 'UGroupPaintBrushFilterProperties::BrushSize' has a wrong offset!");
static_assert(offsetof(UGroupPaintBrushFilterProperties, BrushAreaMode) == 0x0000B0, "Member 'UGroupPaintBrushFilterProperties::BrushAreaMode' has a wrong offset!");
static_assert(offsetof(UGroupPaintBrushFilterProperties, bHitBackFaces) == 0x0000B1, "Member 'UGroupPaintBrushFilterProperties::bHitBackFaces' has a wrong offset!");
static_assert(offsetof(UGroupPaintBrushFilterProperties, SetGroup) == 0x0000B4, "Member 'UGroupPaintBrushFilterProperties::SetGroup' has a wrong offset!");
static_assert(offsetof(UGroupPaintBrushFilterProperties, bOnlySetUngrouped) == 0x0000B8, "Member 'UGroupPaintBrushFilterProperties::bOnlySetUngrouped' has a wrong offset!");
static_assert(offsetof(UGroupPaintBrushFilterProperties, EraseGroup) == 0x0000BC, "Member 'UGroupPaintBrushFilterProperties::EraseGroup' has a wrong offset!");
static_assert(offsetof(UGroupPaintBrushFilterProperties, bOnlyEraseCurrent) == 0x0000C0, "Member 'UGroupPaintBrushFilterProperties::bOnlyEraseCurrent' has a wrong offset!");
static_assert(offsetof(UGroupPaintBrushFilterProperties, AngleThreshold) == 0x0000C4, "Member 'UGroupPaintBrushFilterProperties::AngleThreshold' has a wrong offset!");
static_assert(offsetof(UGroupPaintBrushFilterProperties, bUVSeams) == 0x0000C8, "Member 'UGroupPaintBrushFilterProperties::bUVSeams' has a wrong offset!");
static_assert(offsetof(UGroupPaintBrushFilterProperties, bNormalSeams) == 0x0000C9, "Member 'UGroupPaintBrushFilterProperties::bNormalSeams' has a wrong offset!");
static_assert(offsetof(UGroupPaintBrushFilterProperties, VisibilityFilter) == 0x0000CA, "Member 'UGroupPaintBrushFilterProperties::VisibilityFilter' has a wrong offset!");
static_assert(offsetof(UGroupPaintBrushFilterProperties, MinTriVertCount) == 0x0000CC, "Member 'UGroupPaintBrushFilterProperties::MinTriVertCount' has a wrong offset!");
static_assert(offsetof(UGroupPaintBrushFilterProperties, bShowHitGroup) == 0x0000D0, "Member 'UGroupPaintBrushFilterProperties::bShowHitGroup' has a wrong offset!");
static_assert(offsetof(UGroupPaintBrushFilterProperties, bShowAllGroups) == 0x0000D1, "Member 'UGroupPaintBrushFilterProperties::bShowAllGroups' has a wrong offset!");

// Class MeshModelingToolsExp.MeshGroupPaintToolFreezeActions
// 0x0000 (0x00B0 - 0x00B0)
class UMeshGroupPaintToolFreezeActions final : public UMeshGroupPaintToolActionPropertySet
{
public:
	void ClearAll();
	void ClearCurrent();
	void FloodFillCurrent();
	void FreezeCurrent();
	void FreezeOthers();
	void GrowCurrent();
	void ShrinkCurrent();
	void UnfreezeAll();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MeshGroupPaintToolFreezeActions">();
	}
	static class UMeshGroupPaintToolFreezeActions* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMeshGroupPaintToolFreezeActions>();
	}
};
static_assert(alignof(UMeshGroupPaintToolFreezeActions) == 0x000008, "Wrong alignment on UMeshGroupPaintToolFreezeActions");
static_assert(sizeof(UMeshGroupPaintToolFreezeActions) == 0x0000B0, "Wrong size on UMeshGroupPaintToolFreezeActions");

// Class MeshModelingToolsExp.MeshGroupPaintTool
// 0x0440 (0x0FE0 - 0x0BA0)
class UMeshGroupPaintTool final : public UMeshSculptToolBase
{
public:
	class UPolygroupLayersProperties*             PolygroupLayerProperties;                          // 0x0BA0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGroupPaintBrushFilterProperties*       FilterProperties;                                  // 0x0BA8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGroupPaintBrushOpProps*                PaintBrushOpProperties;                            // 0x0BB0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGroupEraseBrushOpProps*                EraseBrushOpProperties;                            // 0x0BB8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMeshGroupPaintToolFreezeActions*       FreezeActions;                                     // 0x0BC0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BC8[0x8];                                      // 0x0BC8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UPolyLassoMarqueeMechanic*              PolyLassoMechanic;                                 // 0x0BD0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AInternalToolFrameworkActor*            PreviewMeshActor;                                  // 0x0BD8(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDynamicMeshComponent*                  DynamicMeshComponent;                              // 0x0BE0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMeshElementsVisualizer*                MeshElementsDisplay;                               // 0x0BE8(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_BF0[0x3F0];                                    // 0x0BF0(0x03F0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MeshGroupPaintTool">();
	}
	static class UMeshGroupPaintTool* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMeshGroupPaintTool>();
	}
};
static_assert(alignof(UMeshGroupPaintTool) == 0x000010, "Wrong alignment on UMeshGroupPaintTool");
static_assert(sizeof(UMeshGroupPaintTool) == 0x000FE0, "Wrong size on UMeshGroupPaintTool");
static_assert(offsetof(UMeshGroupPaintTool, PolygroupLayerProperties) == 0x000BA0, "Member 'UMeshGroupPaintTool::PolygroupLayerProperties' has a wrong offset!");
static_assert(offsetof(UMeshGroupPaintTool, FilterProperties) == 0x000BA8, "Member 'UMeshGroupPaintTool::FilterProperties' has a wrong offset!");
static_assert(offsetof(UMeshGroupPaintTool, PaintBrushOpProperties) == 0x000BB0, "Member 'UMeshGroupPaintTool::PaintBrushOpProperties' has a wrong offset!");
static_assert(offsetof(UMeshGroupPaintTool, EraseBrushOpProperties) == 0x000BB8, "Member 'UMeshGroupPaintTool::EraseBrushOpProperties' has a wrong offset!");
static_assert(offsetof(UMeshGroupPaintTool, FreezeActions) == 0x000BC0, "Member 'UMeshGroupPaintTool::FreezeActions' has a wrong offset!");
static_assert(offsetof(UMeshGroupPaintTool, PolyLassoMechanic) == 0x000BD0, "Member 'UMeshGroupPaintTool::PolyLassoMechanic' has a wrong offset!");
static_assert(offsetof(UMeshGroupPaintTool, PreviewMeshActor) == 0x000BD8, "Member 'UMeshGroupPaintTool::PreviewMeshActor' has a wrong offset!");
static_assert(offsetof(UMeshGroupPaintTool, DynamicMeshComponent) == 0x000BE0, "Member 'UMeshGroupPaintTool::DynamicMeshComponent' has a wrong offset!");
static_assert(offsetof(UMeshGroupPaintTool, MeshElementsDisplay) == 0x000BE8, "Member 'UMeshGroupPaintTool::MeshElementsDisplay' has a wrong offset!");

// Class MeshModelingToolsExp.MeshInspectorProperties
// 0x0018 (0x00C0 - 0x00A8)
class UMeshInspectorProperties final : public UInteractiveToolPropertySet
{
public:
	bool                                          bWireframe;                                        // 0x00A8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBoundaryEdges;                                    // 0x00A9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBowtieVertices;                                   // 0x00AA(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPolygonBorders;                                   // 0x00AB(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUVSeams;                                          // 0x00AC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUVBowties;                                        // 0x00AD(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMissingUVs;                                       // 0x00AE(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNormalSeams;                                      // 0x00AF(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTangentSeams;                                     // 0x00B0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNormalVectors;                                    // 0x00B1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTangentVectors;                                   // 0x00B2(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDrawHiddenEdgesAndSeams;                          // 0x00B3(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NormalLength;                                      // 0x00B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TangentLength;                                     // 0x00B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMeshInspectorToolDrawIndexMode               ShowIndices;                                       // 0x00BC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BD[0x3];                                       // 0x00BD(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MeshInspectorProperties">();
	}
	static class UMeshInspectorProperties* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMeshInspectorProperties>();
	}
};
static_assert(alignof(UMeshInspectorProperties) == 0x000008, "Wrong alignment on UMeshInspectorProperties");
static_assert(sizeof(UMeshInspectorProperties) == 0x0000C0, "Wrong size on UMeshInspectorProperties");
static_assert(offsetof(UMeshInspectorProperties, bWireframe) == 0x0000A8, "Member 'UMeshInspectorProperties::bWireframe' has a wrong offset!");
static_assert(offsetof(UMeshInspectorProperties, bBoundaryEdges) == 0x0000A9, "Member 'UMeshInspectorProperties::bBoundaryEdges' has a wrong offset!");
static_assert(offsetof(UMeshInspectorProperties, bBowtieVertices) == 0x0000AA, "Member 'UMeshInspectorProperties::bBowtieVertices' has a wrong offset!");
static_assert(offsetof(UMeshInspectorProperties, bPolygonBorders) == 0x0000AB, "Member 'UMeshInspectorProperties::bPolygonBorders' has a wrong offset!");
static_assert(offsetof(UMeshInspectorProperties, bUVSeams) == 0x0000AC, "Member 'UMeshInspectorProperties::bUVSeams' has a wrong offset!");
static_assert(offsetof(UMeshInspectorProperties, bUVBowties) == 0x0000AD, "Member 'UMeshInspectorProperties::bUVBowties' has a wrong offset!");
static_assert(offsetof(UMeshInspectorProperties, bMissingUVs) == 0x0000AE, "Member 'UMeshInspectorProperties::bMissingUVs' has a wrong offset!");
static_assert(offsetof(UMeshInspectorProperties, bNormalSeams) == 0x0000AF, "Member 'UMeshInspectorProperties::bNormalSeams' has a wrong offset!");
static_assert(offsetof(UMeshInspectorProperties, bTangentSeams) == 0x0000B0, "Member 'UMeshInspectorProperties::bTangentSeams' has a wrong offset!");
static_assert(offsetof(UMeshInspectorProperties, bNormalVectors) == 0x0000B1, "Member 'UMeshInspectorProperties::bNormalVectors' has a wrong offset!");
static_assert(offsetof(UMeshInspectorProperties, bTangentVectors) == 0x0000B2, "Member 'UMeshInspectorProperties::bTangentVectors' has a wrong offset!");
static_assert(offsetof(UMeshInspectorProperties, bDrawHiddenEdgesAndSeams) == 0x0000B3, "Member 'UMeshInspectorProperties::bDrawHiddenEdgesAndSeams' has a wrong offset!");
static_assert(offsetof(UMeshInspectorProperties, NormalLength) == 0x0000B4, "Member 'UMeshInspectorProperties::NormalLength' has a wrong offset!");
static_assert(offsetof(UMeshInspectorProperties, TangentLength) == 0x0000B8, "Member 'UMeshInspectorProperties::TangentLength' has a wrong offset!");
static_assert(offsetof(UMeshInspectorProperties, ShowIndices) == 0x0000BC, "Member 'UMeshInspectorProperties::ShowIndices' has a wrong offset!");

// Class MeshModelingToolsExp.MeshInspectorTool
// 0x01A0 (0x0250 - 0x00B0)
class alignas(0x10) UMeshInspectorTool final : public USingleSelectionMeshEditingTool
{
public:
	uint8                                         Pad_B0[0x8];                                       // 0x00B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UMeshInspectorProperties*               Settings;                                          // 0x00B8(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPolygroupLayersProperties*             PolygroupLayerProperties;                          // 0x00C0(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMeshInspectorMaterialProperties*       MaterialSettings;                                  // 0x00C8(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D0[0x8];                                       // 0x00D0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UPreviewMesh*                           PreviewMesh;                                       // 0x00D8(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ULineSetComponent*                      DrawnLineSet;                                      // 0x00E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     DefaultMaterial;                                   // 0x00E8(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_F0[0x160];                                     // 0x00F0(0x0160)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MeshInspectorTool">();
	}
	static class UMeshInspectorTool* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMeshInspectorTool>();
	}
};
static_assert(alignof(UMeshInspectorTool) == 0x000010, "Wrong alignment on UMeshInspectorTool");
static_assert(sizeof(UMeshInspectorTool) == 0x000250, "Wrong size on UMeshInspectorTool");
static_assert(offsetof(UMeshInspectorTool, Settings) == 0x0000B8, "Member 'UMeshInspectorTool::Settings' has a wrong offset!");
static_assert(offsetof(UMeshInspectorTool, PolygroupLayerProperties) == 0x0000C0, "Member 'UMeshInspectorTool::PolygroupLayerProperties' has a wrong offset!");
static_assert(offsetof(UMeshInspectorTool, MaterialSettings) == 0x0000C8, "Member 'UMeshInspectorTool::MaterialSettings' has a wrong offset!");
static_assert(offsetof(UMeshInspectorTool, PreviewMesh) == 0x0000D8, "Member 'UMeshInspectorTool::PreviewMesh' has a wrong offset!");
static_assert(offsetof(UMeshInspectorTool, DrawnLineSet) == 0x0000E0, "Member 'UMeshInspectorTool::DrawnLineSet' has a wrong offset!");
static_assert(offsetof(UMeshInspectorTool, DefaultMaterial) == 0x0000E8, "Member 'UMeshInspectorTool::DefaultMaterial' has a wrong offset!");

// Class MeshModelingToolsExp.MeshSelectionMeshEditActions
// 0x0000 (0x00B0 - 0x00B0)
class UMeshSelectionMeshEditActions final : public UMeshSelectionToolActionPropertySet
{
public:
	void CreatePolygroup();
	void Delete();
	void Disconnect();
	void Duplicate();
	void FlipNormals();
	void Separate();
	void SmoothBorder();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MeshSelectionMeshEditActions">();
	}
	static class UMeshSelectionMeshEditActions* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMeshSelectionMeshEditActions>();
	}
};
static_assert(alignof(UMeshSelectionMeshEditActions) == 0x000008, "Wrong alignment on UMeshSelectionMeshEditActions");
static_assert(sizeof(UMeshSelectionMeshEditActions) == 0x0000B0, "Wrong size on UMeshSelectionMeshEditActions");

// Class MeshModelingToolsExp.MeshSelectionTool
// 0x0448 (0x0728 - 0x02E0)
class UMeshSelectionTool final : public UDynamicMeshBrushTool
{
public:
	uint8                                         Pad_2E0[0x8];                                      // 0x02E0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UMeshSelectionToolProperties*           SelectionProps;                                    // 0x02E8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMeshSelectionEditActions*              SelectionActions;                                  // 0x02F0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMeshSelectionToolActionPropertySet*    EditActions;                                       // 0x02F8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMeshStatisticsProperties*              MeshStatisticsProperties;                          // 0x0300(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMeshElementsVisualizer*                MeshElementsDisplay;                               // 0x0308(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMeshUVChannelProperties*               UVChannelProperties;                               // 0x0310(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPolygroupLayersProperties*             PolygroupLayerProperties;                          // 0x0318(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_320[0x58];                                     // 0x0320(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	class UMeshSelectionSet*                      Selection;                                         // 0x0378(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class AActor*>                         SpawnedActors;                                     // 0x0380(0x0010)(ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	uint8                                         Pad_390[0x398];                                    // 0x0390(0x0398)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MeshSelectionTool">();
	}
	static class UMeshSelectionTool* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMeshSelectionTool>();
	}
};
static_assert(alignof(UMeshSelectionTool) == 0x000008, "Wrong alignment on UMeshSelectionTool");
static_assert(sizeof(UMeshSelectionTool) == 0x000728, "Wrong size on UMeshSelectionTool");
static_assert(offsetof(UMeshSelectionTool, SelectionProps) == 0x0002E8, "Member 'UMeshSelectionTool::SelectionProps' has a wrong offset!");
static_assert(offsetof(UMeshSelectionTool, SelectionActions) == 0x0002F0, "Member 'UMeshSelectionTool::SelectionActions' has a wrong offset!");
static_assert(offsetof(UMeshSelectionTool, EditActions) == 0x0002F8, "Member 'UMeshSelectionTool::EditActions' has a wrong offset!");
static_assert(offsetof(UMeshSelectionTool, MeshStatisticsProperties) == 0x000300, "Member 'UMeshSelectionTool::MeshStatisticsProperties' has a wrong offset!");
static_assert(offsetof(UMeshSelectionTool, MeshElementsDisplay) == 0x000308, "Member 'UMeshSelectionTool::MeshElementsDisplay' has a wrong offset!");
static_assert(offsetof(UMeshSelectionTool, UVChannelProperties) == 0x000310, "Member 'UMeshSelectionTool::UVChannelProperties' has a wrong offset!");
static_assert(offsetof(UMeshSelectionTool, PolygroupLayerProperties) == 0x000318, "Member 'UMeshSelectionTool::PolygroupLayerProperties' has a wrong offset!");
static_assert(offsetof(UMeshSelectionTool, Selection) == 0x000378, "Member 'UMeshSelectionTool::Selection' has a wrong offset!");
static_assert(offsetof(UMeshSelectionTool, SpawnedActors) == 0x000380, "Member 'UMeshSelectionTool::SpawnedActors' has a wrong offset!");

// Class MeshModelingToolsExp.MeshSpaceDeformerToolProperties
// 0x0028 (0x00D0 - 0x00A8)
class UMeshSpaceDeformerToolProperties final : public UInteractiveToolPropertySet
{
public:
	ENonlinearOperationType                       SelectedOperationType;                             // 0x00A8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A9[0x3];                                       // 0x00A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         UpperBoundsInterval;                               // 0x00AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LowerBoundsInterval;                               // 0x00B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BendDegrees;                                       // 0x00B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TwistDegrees;                                      // 0x00B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFlareProfileType                             FlareProfileType;                                  // 0x00BC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BD[0x3];                                       // 0x00BD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FlarePercentY;                                     // 0x00C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLockXAndYFlaring;                                 // 0x00C4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C5[0x3];                                       // 0x00C5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FlarePercentX;                                     // 0x00C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLockBottom;                                       // 0x00CC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowOriginalMesh;                                 // 0x00CD(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDrawVisualization;                                // 0x00CE(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAlignToNormalOnCtrlClick;                         // 0x00CF(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MeshSpaceDeformerToolProperties">();
	}
	static class UMeshSpaceDeformerToolProperties* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMeshSpaceDeformerToolProperties>();
	}
};
static_assert(alignof(UMeshSpaceDeformerToolProperties) == 0x000008, "Wrong alignment on UMeshSpaceDeformerToolProperties");
static_assert(sizeof(UMeshSpaceDeformerToolProperties) == 0x0000D0, "Wrong size on UMeshSpaceDeformerToolProperties");
static_assert(offsetof(UMeshSpaceDeformerToolProperties, SelectedOperationType) == 0x0000A8, "Member 'UMeshSpaceDeformerToolProperties::SelectedOperationType' has a wrong offset!");
static_assert(offsetof(UMeshSpaceDeformerToolProperties, UpperBoundsInterval) == 0x0000AC, "Member 'UMeshSpaceDeformerToolProperties::UpperBoundsInterval' has a wrong offset!");
static_assert(offsetof(UMeshSpaceDeformerToolProperties, LowerBoundsInterval) == 0x0000B0, "Member 'UMeshSpaceDeformerToolProperties::LowerBoundsInterval' has a wrong offset!");
static_assert(offsetof(UMeshSpaceDeformerToolProperties, BendDegrees) == 0x0000B4, "Member 'UMeshSpaceDeformerToolProperties::BendDegrees' has a wrong offset!");
static_assert(offsetof(UMeshSpaceDeformerToolProperties, TwistDegrees) == 0x0000B8, "Member 'UMeshSpaceDeformerToolProperties::TwistDegrees' has a wrong offset!");
static_assert(offsetof(UMeshSpaceDeformerToolProperties, FlareProfileType) == 0x0000BC, "Member 'UMeshSpaceDeformerToolProperties::FlareProfileType' has a wrong offset!");
static_assert(offsetof(UMeshSpaceDeformerToolProperties, FlarePercentY) == 0x0000C0, "Member 'UMeshSpaceDeformerToolProperties::FlarePercentY' has a wrong offset!");
static_assert(offsetof(UMeshSpaceDeformerToolProperties, bLockXAndYFlaring) == 0x0000C4, "Member 'UMeshSpaceDeformerToolProperties::bLockXAndYFlaring' has a wrong offset!");
static_assert(offsetof(UMeshSpaceDeformerToolProperties, FlarePercentX) == 0x0000C8, "Member 'UMeshSpaceDeformerToolProperties::FlarePercentX' has a wrong offset!");
static_assert(offsetof(UMeshSpaceDeformerToolProperties, bLockBottom) == 0x0000CC, "Member 'UMeshSpaceDeformerToolProperties::bLockBottom' has a wrong offset!");
static_assert(offsetof(UMeshSpaceDeformerToolProperties, bShowOriginalMesh) == 0x0000CD, "Member 'UMeshSpaceDeformerToolProperties::bShowOriginalMesh' has a wrong offset!");
static_assert(offsetof(UMeshSpaceDeformerToolProperties, bDrawVisualization) == 0x0000CE, "Member 'UMeshSpaceDeformerToolProperties::bDrawVisualization' has a wrong offset!");
static_assert(offsetof(UMeshSpaceDeformerToolProperties, bAlignToNormalOnCtrlClick) == 0x0000CF, "Member 'UMeshSpaceDeformerToolProperties::bAlignToNormalOnCtrlClick' has a wrong offset!");

// Class MeshModelingToolsExp.MeshSpaceDeformerToolActionPropertySet
// 0x0008 (0x00B0 - 0x00A8)
class UMeshSpaceDeformerToolActionPropertySet final : public UInteractiveToolPropertySet
{
public:
	uint8                                         Pad_A8[0x8];                                       // 0x00A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ShiftToCenter();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MeshSpaceDeformerToolActionPropertySet">();
	}
	static class UMeshSpaceDeformerToolActionPropertySet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMeshSpaceDeformerToolActionPropertySet>();
	}
};
static_assert(alignof(UMeshSpaceDeformerToolActionPropertySet) == 0x000008, "Wrong alignment on UMeshSpaceDeformerToolActionPropertySet");
static_assert(sizeof(UMeshSpaceDeformerToolActionPropertySet) == 0x0000B0, "Wrong size on UMeshSpaceDeformerToolActionPropertySet");

// Class MeshModelingToolsExp.SpaceDeformerOperatorFactory
// 0x0010 (0x0038 - 0x0028)
class USpaceDeformerOperatorFactory final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UMeshSpaceDeformerTool*                 SpaceDeformerTool;                                 // 0x0030(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpaceDeformerOperatorFactory">();
	}
	static class USpaceDeformerOperatorFactory* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpaceDeformerOperatorFactory>();
	}
};
static_assert(alignof(USpaceDeformerOperatorFactory) == 0x000008, "Wrong alignment on USpaceDeformerOperatorFactory");
static_assert(sizeof(USpaceDeformerOperatorFactory) == 0x000038, "Wrong size on USpaceDeformerOperatorFactory");
static_assert(offsetof(USpaceDeformerOperatorFactory, SpaceDeformerTool) == 0x000030, "Member 'USpaceDeformerOperatorFactory::SpaceDeformerTool' has a wrong offset!");

// Class MeshModelingToolsExp.MeshSpaceDeformerTool
// 0x0210 (0x02C0 - 0x00B0)
class alignas(0x10) UMeshSpaceDeformerTool final : public USingleSelectionMeshEditingTool
{
public:
	uint8                                         Pad_B0[0x8];                                       // 0x00B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UMeshSpaceDeformerToolProperties*       Settings;                                          // 0x00B8(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMeshSpaceDeformerToolActionPropertySet* ToolActions;                                       // 0x00C0(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGizmoTransformChangeStateTarget*       StateTarget;                                       // 0x00C8(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDragAlignmentMechanic*                 DragAlignmentMechanic;                             // 0x00D0(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMeshOpPreviewWithBackgroundCompute*    Preview;                                           // 0x00D8(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E0[0x10];                                      // 0x00E0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UPreviewMesh*                           OriginalMeshPreview;                               // 0x00F0(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UIntervalGizmo*                         IntervalGizmo;                                     // 0x00F8(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCombinedTransformGizmo*                TransformGizmo;                                    // 0x0100(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTransformProxy*                        TransformProxy;                                    // 0x0108(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGizmoLocalFloatParameterSource*        UpIntervalSource;                                  // 0x0110(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGizmoLocalFloatParameterSource*        DownIntervalSource;                                // 0x0118(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGizmoLocalFloatParameterSource*        ForwardIntervalSource;                             // 0x0120(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_128[0x198];                                    // 0x0128(0x0198)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MeshSpaceDeformerTool">();
	}
	static class UMeshSpaceDeformerTool* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMeshSpaceDeformerTool>();
	}
};
static_assert(alignof(UMeshSpaceDeformerTool) == 0x000010, "Wrong alignment on UMeshSpaceDeformerTool");
static_assert(sizeof(UMeshSpaceDeformerTool) == 0x0002C0, "Wrong size on UMeshSpaceDeformerTool");
static_assert(offsetof(UMeshSpaceDeformerTool, Settings) == 0x0000B8, "Member 'UMeshSpaceDeformerTool::Settings' has a wrong offset!");
static_assert(offsetof(UMeshSpaceDeformerTool, ToolActions) == 0x0000C0, "Member 'UMeshSpaceDeformerTool::ToolActions' has a wrong offset!");
static_assert(offsetof(UMeshSpaceDeformerTool, StateTarget) == 0x0000C8, "Member 'UMeshSpaceDeformerTool::StateTarget' has a wrong offset!");
static_assert(offsetof(UMeshSpaceDeformerTool, DragAlignmentMechanic) == 0x0000D0, "Member 'UMeshSpaceDeformerTool::DragAlignmentMechanic' has a wrong offset!");
static_assert(offsetof(UMeshSpaceDeformerTool, Preview) == 0x0000D8, "Member 'UMeshSpaceDeformerTool::Preview' has a wrong offset!");
static_assert(offsetof(UMeshSpaceDeformerTool, OriginalMeshPreview) == 0x0000F0, "Member 'UMeshSpaceDeformerTool::OriginalMeshPreview' has a wrong offset!");
static_assert(offsetof(UMeshSpaceDeformerTool, IntervalGizmo) == 0x0000F8, "Member 'UMeshSpaceDeformerTool::IntervalGizmo' has a wrong offset!");
static_assert(offsetof(UMeshSpaceDeformerTool, TransformGizmo) == 0x000100, "Member 'UMeshSpaceDeformerTool::TransformGizmo' has a wrong offset!");
static_assert(offsetof(UMeshSpaceDeformerTool, TransformProxy) == 0x000108, "Member 'UMeshSpaceDeformerTool::TransformProxy' has a wrong offset!");
static_assert(offsetof(UMeshSpaceDeformerTool, UpIntervalSource) == 0x000110, "Member 'UMeshSpaceDeformerTool::UpIntervalSource' has a wrong offset!");
static_assert(offsetof(UMeshSpaceDeformerTool, DownIntervalSource) == 0x000118, "Member 'UMeshSpaceDeformerTool::DownIntervalSource' has a wrong offset!");
static_assert(offsetof(UMeshSpaceDeformerTool, ForwardIntervalSource) == 0x000120, "Member 'UMeshSpaceDeformerTool::ForwardIntervalSource' has a wrong offset!");

// Class MeshModelingToolsExp.MeshVertexPaintToolBuilder
// 0x0000 (0x0030 - 0x0030)
class UMeshVertexPaintToolBuilder final : public UMeshSurfacePointMeshEditingToolBuilder
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MeshVertexPaintToolBuilder">();
	}
	static class UMeshVertexPaintToolBuilder* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMeshVertexPaintToolBuilder>();
	}
};
static_assert(alignof(UMeshVertexPaintToolBuilder) == 0x000008, "Wrong alignment on UMeshVertexPaintToolBuilder");
static_assert(sizeof(UMeshVertexPaintToolBuilder) == 0x000030, "Wrong size on UMeshVertexPaintToolBuilder");

// Class MeshModelingToolsExp.VertexPaintBrushFilterProperties
// 0x0018 (0x00C0 - 0x00A8)
class UVertexPaintBrushFilterProperties final : public UInteractiveToolPropertySet
{
public:
	EMeshVertexPaintBrushAreaType                 BrushAreaMode;                                     // 0x00A8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A9[0x3];                                       // 0x00A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AngleThreshold;                                    // 0x00AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUVSeams;                                          // 0x00B0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNormalSeams;                                      // 0x00B1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMeshVertexPaintVisibilityType                VisibilityFilter;                                  // 0x00B2(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B3[0x1];                                       // 0x00B3(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MinTriVertCount;                                   // 0x00B4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMeshVertexPaintMaterialMode                  MaterialMode;                                      // 0x00B8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowHitColor;                                     // 0x00B9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMeshVertexPaintInteractionType               CurrentSubToolType;                                // 0x00BA(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BB[0x5];                                       // 0x00BB(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VertexPaintBrushFilterProperties">();
	}
	static class UVertexPaintBrushFilterProperties* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVertexPaintBrushFilterProperties>();
	}
};
static_assert(alignof(UVertexPaintBrushFilterProperties) == 0x000008, "Wrong alignment on UVertexPaintBrushFilterProperties");
static_assert(sizeof(UVertexPaintBrushFilterProperties) == 0x0000C0, "Wrong size on UVertexPaintBrushFilterProperties");
static_assert(offsetof(UVertexPaintBrushFilterProperties, BrushAreaMode) == 0x0000A8, "Member 'UVertexPaintBrushFilterProperties::BrushAreaMode' has a wrong offset!");
static_assert(offsetof(UVertexPaintBrushFilterProperties, AngleThreshold) == 0x0000AC, "Member 'UVertexPaintBrushFilterProperties::AngleThreshold' has a wrong offset!");
static_assert(offsetof(UVertexPaintBrushFilterProperties, bUVSeams) == 0x0000B0, "Member 'UVertexPaintBrushFilterProperties::bUVSeams' has a wrong offset!");
static_assert(offsetof(UVertexPaintBrushFilterProperties, bNormalSeams) == 0x0000B1, "Member 'UVertexPaintBrushFilterProperties::bNormalSeams' has a wrong offset!");
static_assert(offsetof(UVertexPaintBrushFilterProperties, VisibilityFilter) == 0x0000B2, "Member 'UVertexPaintBrushFilterProperties::VisibilityFilter' has a wrong offset!");
static_assert(offsetof(UVertexPaintBrushFilterProperties, MinTriVertCount) == 0x0000B4, "Member 'UVertexPaintBrushFilterProperties::MinTriVertCount' has a wrong offset!");
static_assert(offsetof(UVertexPaintBrushFilterProperties, MaterialMode) == 0x0000B8, "Member 'UVertexPaintBrushFilterProperties::MaterialMode' has a wrong offset!");
static_assert(offsetof(UVertexPaintBrushFilterProperties, bShowHitColor) == 0x0000B9, "Member 'UVertexPaintBrushFilterProperties::bShowHitColor' has a wrong offset!");
static_assert(offsetof(UVertexPaintBrushFilterProperties, CurrentSubToolType) == 0x0000BA, "Member 'UVertexPaintBrushFilterProperties::CurrentSubToolType' has a wrong offset!");

// Class MeshModelingToolsExp.MeshVertexPaintToolQuickActions
// 0x0000 (0x00B0 - 0x00B0)
class UMeshVertexPaintToolQuickActions final : public UMeshVertexPaintToolActionPropertySet
{
public:
	void EraseAll();
	void FillBlack();
	void FillWhite();
	void PaintAll();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MeshVertexPaintToolQuickActions">();
	}
	static class UMeshVertexPaintToolQuickActions* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMeshVertexPaintToolQuickActions>();
	}
};
static_assert(alignof(UMeshVertexPaintToolQuickActions) == 0x000008, "Wrong alignment on UMeshVertexPaintToolQuickActions");
static_assert(sizeof(UMeshVertexPaintToolQuickActions) == 0x0000B0, "Wrong size on UMeshVertexPaintToolQuickActions");

// Class MeshModelingToolsExp.MeshVertexPaintTool
// 0x05A0 (0x1140 - 0x0BA0)
class UMeshVertexPaintTool final : public UMeshSculptToolBase
{
public:
	uint8                                         Pad_BA0[0x8];                                      // 0x0BA0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UPolygroupLayersProperties*             PolygroupLayerProperties;                          // 0x0BA8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVertexPaintBasicProperties*            BasicProperties;                                   // 0x0BB0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVertexPaintBrushFilterProperties*      FilterProperties;                                  // 0x0BB8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVertexColorPaintBrushOpProps*          PaintBrushOpProperties;                            // 0x0BC0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UVertexColorPaintBrushOpProps*          EraseBrushOpProperties;                            // 0x0BC8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMeshVertexPaintToolQuickActions*       QuickActions;                                      // 0x0BD0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMeshVertexPaintToolUtilityActions*     UtilityActions;                                    // 0x0BD8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BE0[0x8];                                      // 0x0BE0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UPolyLassoMarqueeMechanic*              PolyLassoMechanic;                                 // 0x0BE8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AInternalToolFrameworkActor*            PreviewMeshActor;                                  // 0x0BF0(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDynamicMeshComponent*                  DynamicMeshComponent;                              // 0x0BF8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMeshElementsVisualizer*                MeshElementsDisplay;                               // 0x0C00(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C08[0x538];                                    // 0x0C08(0x0538)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MeshVertexPaintTool">();
	}
	static class UMeshVertexPaintTool* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMeshVertexPaintTool>();
	}
};
static_assert(alignof(UMeshVertexPaintTool) == 0x000010, "Wrong alignment on UMeshVertexPaintTool");
static_assert(sizeof(UMeshVertexPaintTool) == 0x001140, "Wrong size on UMeshVertexPaintTool");
static_assert(offsetof(UMeshVertexPaintTool, PolygroupLayerProperties) == 0x000BA8, "Member 'UMeshVertexPaintTool::PolygroupLayerProperties' has a wrong offset!");
static_assert(offsetof(UMeshVertexPaintTool, BasicProperties) == 0x000BB0, "Member 'UMeshVertexPaintTool::BasicProperties' has a wrong offset!");
static_assert(offsetof(UMeshVertexPaintTool, FilterProperties) == 0x000BB8, "Member 'UMeshVertexPaintTool::FilterProperties' has a wrong offset!");
static_assert(offsetof(UMeshVertexPaintTool, PaintBrushOpProperties) == 0x000BC0, "Member 'UMeshVertexPaintTool::PaintBrushOpProperties' has a wrong offset!");
static_assert(offsetof(UMeshVertexPaintTool, EraseBrushOpProperties) == 0x000BC8, "Member 'UMeshVertexPaintTool::EraseBrushOpProperties' has a wrong offset!");
static_assert(offsetof(UMeshVertexPaintTool, QuickActions) == 0x000BD0, "Member 'UMeshVertexPaintTool::QuickActions' has a wrong offset!");
static_assert(offsetof(UMeshVertexPaintTool, UtilityActions) == 0x000BD8, "Member 'UMeshVertexPaintTool::UtilityActions' has a wrong offset!");
static_assert(offsetof(UMeshVertexPaintTool, PolyLassoMechanic) == 0x000BE8, "Member 'UMeshVertexPaintTool::PolyLassoMechanic' has a wrong offset!");
static_assert(offsetof(UMeshVertexPaintTool, PreviewMeshActor) == 0x000BF0, "Member 'UMeshVertexPaintTool::PreviewMeshActor' has a wrong offset!");
static_assert(offsetof(UMeshVertexPaintTool, DynamicMeshComponent) == 0x000BF8, "Member 'UMeshVertexPaintTool::DynamicMeshComponent' has a wrong offset!");
static_assert(offsetof(UMeshVertexPaintTool, MeshElementsDisplay) == 0x000C00, "Member 'UMeshVertexPaintTool::MeshElementsDisplay' has a wrong offset!");

// Class MeshModelingToolsExp.VertexBrushSculptProperties
// 0x0010 (0x00B8 - 0x00A8)
class UVertexBrushSculptProperties final : public UInteractiveToolPropertySet
{
public:
	EMeshVertexSculptBrushType                    PrimaryBrushType;                                  // 0x00A8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMeshSculptFalloffType                        PrimaryFalloffType;                                // 0x00A9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMeshVertexSculptBrushFilterType              BrushFilter;                                       // 0x00AA(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFreezeTarget;                                     // 0x00AB(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UMeshVertexSculptTool>   Tool;                                              // 0x00AC(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B4[0x4];                                       // 0x00B4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VertexBrushSculptProperties">();
	}
	static class UVertexBrushSculptProperties* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVertexBrushSculptProperties>();
	}
};
static_assert(alignof(UVertexBrushSculptProperties) == 0x000008, "Wrong alignment on UVertexBrushSculptProperties");
static_assert(sizeof(UVertexBrushSculptProperties) == 0x0000B8, "Wrong size on UVertexBrushSculptProperties");
static_assert(offsetof(UVertexBrushSculptProperties, PrimaryBrushType) == 0x0000A8, "Member 'UVertexBrushSculptProperties::PrimaryBrushType' has a wrong offset!");
static_assert(offsetof(UVertexBrushSculptProperties, PrimaryFalloffType) == 0x0000A9, "Member 'UVertexBrushSculptProperties::PrimaryFalloffType' has a wrong offset!");
static_assert(offsetof(UVertexBrushSculptProperties, BrushFilter) == 0x0000AA, "Member 'UVertexBrushSculptProperties::BrushFilter' has a wrong offset!");
static_assert(offsetof(UVertexBrushSculptProperties, bFreezeTarget) == 0x0000AB, "Member 'UVertexBrushSculptProperties::bFreezeTarget' has a wrong offset!");
static_assert(offsetof(UVertexBrushSculptProperties, Tool) == 0x0000AC, "Member 'UVertexBrushSculptProperties::Tool' has a wrong offset!");

// Class MeshModelingToolsExp.MeshSymmetryProperties
// 0x0008 (0x00B0 - 0x00A8)
class UMeshSymmetryProperties final : public UInteractiveToolPropertySet
{
public:
	bool                                          bEnableSymmetry;                                   // 0x00A8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSymmetryCanBeEnabled;                             // 0x00A9(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AA[0x6];                                       // 0x00AA(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MeshSymmetryProperties">();
	}
	static class UMeshSymmetryProperties* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMeshSymmetryProperties>();
	}
};
static_assert(alignof(UMeshSymmetryProperties) == 0x000008, "Wrong alignment on UMeshSymmetryProperties");
static_assert(sizeof(UMeshSymmetryProperties) == 0x0000B0, "Wrong size on UMeshSymmetryProperties");
static_assert(offsetof(UMeshSymmetryProperties, bEnableSymmetry) == 0x0000A8, "Member 'UMeshSymmetryProperties::bEnableSymmetry' has a wrong offset!");
static_assert(offsetof(UMeshSymmetryProperties, bSymmetryCanBeEnabled) == 0x0000A9, "Member 'UMeshSymmetryProperties::bSymmetryCanBeEnabled' has a wrong offset!");

// Class MeshModelingToolsExp.MirrorToolBuilder
// 0x0000 (0x0028 - 0x0028)
class UMirrorToolBuilder final : public UMultiSelectionMeshEditingToolBuilder
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MirrorToolBuilder">();
	}
	static class UMirrorToolBuilder* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMirrorToolBuilder>();
	}
};
static_assert(alignof(UMirrorToolBuilder) == 0x000008, "Wrong alignment on UMirrorToolBuilder");
static_assert(sizeof(UMirrorToolBuilder) == 0x000028, "Wrong size on UMirrorToolBuilder");

// Class MeshModelingToolsExp.MirrorOperatorFactory
// 0x0018 (0x0040 - 0x0028)
class UMirrorOperatorFactory final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UMirrorTool*                            MirrorTool;                                        // 0x0030(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MirrorOperatorFactory">();
	}
	static class UMirrorOperatorFactory* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMirrorOperatorFactory>();
	}
};
static_assert(alignof(UMirrorOperatorFactory) == 0x000008, "Wrong alignment on UMirrorOperatorFactory");
static_assert(sizeof(UMirrorOperatorFactory) == 0x000040, "Wrong size on UMirrorOperatorFactory");
static_assert(offsetof(UMirrorOperatorFactory, MirrorTool) == 0x000030, "Member 'UMirrorOperatorFactory::MirrorTool' has a wrong offset!");

// Class MeshModelingToolsExp.MirrorTool
// 0x00C0 (0x0178 - 0x00B8)
class UMirrorTool final : public UMultiSelectionMeshEditingTool
{
public:
	uint8                                         Pad_B8[0x8];                                       // 0x00B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UMirrorToolProperties*                  Settings;                                          // 0x00C0(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCreateMeshObjectTypeProperties*        OutputTypeProperties;                              // 0x00C8(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOnAcceptHandleSourcesProperties*       HandleSourcesProperties;                           // 0x00D0(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMirrorToolActionPropertySet*           ToolActions;                                       // 0x00D8(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UDynamicMeshReplacementChangeTarget*> MeshesToMirror;                                    // 0x00E0(0x0010)(ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<class UMeshOpPreviewWithBackgroundCompute*> Previews;                                          // 0x00F0(0x0010)(ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	uint8                                         Pad_100[0x30];                                     // 0x0100(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class UConstructionPlaneMechanic*             PlaneMechanic;                                     // 0x0130(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_138[0x40];                                     // 0x0138(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MirrorTool">();
	}
	static class UMirrorTool* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMirrorTool>();
	}
};
static_assert(alignof(UMirrorTool) == 0x000008, "Wrong alignment on UMirrorTool");
static_assert(sizeof(UMirrorTool) == 0x000178, "Wrong size on UMirrorTool");
static_assert(offsetof(UMirrorTool, Settings) == 0x0000C0, "Member 'UMirrorTool::Settings' has a wrong offset!");
static_assert(offsetof(UMirrorTool, OutputTypeProperties) == 0x0000C8, "Member 'UMirrorTool::OutputTypeProperties' has a wrong offset!");
static_assert(offsetof(UMirrorTool, HandleSourcesProperties) == 0x0000D0, "Member 'UMirrorTool::HandleSourcesProperties' has a wrong offset!");
static_assert(offsetof(UMirrorTool, ToolActions) == 0x0000D8, "Member 'UMirrorTool::ToolActions' has a wrong offset!");
static_assert(offsetof(UMirrorTool, MeshesToMirror) == 0x0000E0, "Member 'UMirrorTool::MeshesToMirror' has a wrong offset!");
static_assert(offsetof(UMirrorTool, Previews) == 0x0000F0, "Member 'UMirrorTool::Previews' has a wrong offset!");
static_assert(offsetof(UMirrorTool, PlaneMechanic) == 0x000130, "Member 'UMirrorTool::PlaneMechanic' has a wrong offset!");

// Class MeshModelingToolsExp.OffsetWeightMapSetProperties
// 0x0008 (0x00D0 - 0x00C8)
class UOffsetWeightMapSetProperties final : public UWeightMapSetProperties
{
public:
	float                                         MinDistance;                                       // 0x00C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CC[0x4];                                       // 0x00CC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OffsetWeightMapSetProperties">();
	}
	static class UOffsetWeightMapSetProperties* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOffsetWeightMapSetProperties>();
	}
};
static_assert(alignof(UOffsetWeightMapSetProperties) == 0x000008, "Wrong alignment on UOffsetWeightMapSetProperties");
static_assert(sizeof(UOffsetWeightMapSetProperties) == 0x0000D0, "Wrong size on UOffsetWeightMapSetProperties");
static_assert(offsetof(UOffsetWeightMapSetProperties, MinDistance) == 0x0000C8, "Member 'UOffsetWeightMapSetProperties::MinDistance' has a wrong offset!");

// Class MeshModelingToolsExp.ImplicitOffsetProperties
// 0x0008 (0x00B0 - 0x00A8)
class UImplicitOffsetProperties final : public UInteractiveToolPropertySet
{
public:
	float                                         Smoothness;                                        // 0x00A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPreserveUVs;                                      // 0x00AC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AD[0x3];                                       // 0x00AD(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ImplicitOffsetProperties">();
	}
	static class UImplicitOffsetProperties* GetDefaultObj()
	{
		return GetDefaultObjImpl<UImplicitOffsetProperties>();
	}
};
static_assert(alignof(UImplicitOffsetProperties) == 0x000008, "Wrong alignment on UImplicitOffsetProperties");
static_assert(sizeof(UImplicitOffsetProperties) == 0x0000B0, "Wrong size on UImplicitOffsetProperties");
static_assert(offsetof(UImplicitOffsetProperties, Smoothness) == 0x0000A8, "Member 'UImplicitOffsetProperties::Smoothness' has a wrong offset!");
static_assert(offsetof(UImplicitOffsetProperties, bPreserveUVs) == 0x0000AC, "Member 'UImplicitOffsetProperties::bPreserveUVs' has a wrong offset!");

// Class MeshModelingToolsExp.OffsetMeshToolBuilder
// 0x0000 (0x0028 - 0x0028)
class UOffsetMeshToolBuilder final : public UBaseMeshProcessingToolBuilder
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OffsetMeshToolBuilder">();
	}
	static class UOffsetMeshToolBuilder* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOffsetMeshToolBuilder>();
	}
};
static_assert(alignof(UOffsetMeshToolBuilder) == 0x000008, "Wrong alignment on UOffsetMeshToolBuilder");
static_assert(sizeof(UOffsetMeshToolBuilder) == 0x000028, "Wrong size on UOffsetMeshToolBuilder");

// Class MeshModelingToolsExp.CollisionGeometryVisualizationProperties
// 0x0030 (0x00D8 - 0x00A8)
class UCollisionGeometryVisualizationProperties final : public UInteractiveToolPropertySet
{
public:
	bool                                          bShowCollision;                                    // 0x00A8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowSolid;                                        // 0x00A9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AA[0x2];                                       // 0x00AA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LineThickness;                                     // 0x00AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowHidden;                                       // 0x00B0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRandomColors;                                     // 0x00B1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B2[0x2];                                       // 0x00B2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FColor                                 Color;                                             // 0x00B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     LineMaterial;                                      // 0x00B8(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     LineMaterialShowingHidden;                         // 0x00C0(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     TriangleMaterial;                                  // 0x00C8(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableShowCollision;                              // 0x00D0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableShowSolid;                                  // 0x00D1(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D2[0x6];                                       // 0x00D2(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CollisionGeometryVisualizationProperties">();
	}
	static class UCollisionGeometryVisualizationProperties* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCollisionGeometryVisualizationProperties>();
	}
};
static_assert(alignof(UCollisionGeometryVisualizationProperties) == 0x000008, "Wrong alignment on UCollisionGeometryVisualizationProperties");
static_assert(sizeof(UCollisionGeometryVisualizationProperties) == 0x0000D8, "Wrong size on UCollisionGeometryVisualizationProperties");
static_assert(offsetof(UCollisionGeometryVisualizationProperties, bShowCollision) == 0x0000A8, "Member 'UCollisionGeometryVisualizationProperties::bShowCollision' has a wrong offset!");
static_assert(offsetof(UCollisionGeometryVisualizationProperties, bShowSolid) == 0x0000A9, "Member 'UCollisionGeometryVisualizationProperties::bShowSolid' has a wrong offset!");
static_assert(offsetof(UCollisionGeometryVisualizationProperties, LineThickness) == 0x0000AC, "Member 'UCollisionGeometryVisualizationProperties::LineThickness' has a wrong offset!");
static_assert(offsetof(UCollisionGeometryVisualizationProperties, bShowHidden) == 0x0000B0, "Member 'UCollisionGeometryVisualizationProperties::bShowHidden' has a wrong offset!");
static_assert(offsetof(UCollisionGeometryVisualizationProperties, bRandomColors) == 0x0000B1, "Member 'UCollisionGeometryVisualizationProperties::bRandomColors' has a wrong offset!");
static_assert(offsetof(UCollisionGeometryVisualizationProperties, Color) == 0x0000B4, "Member 'UCollisionGeometryVisualizationProperties::Color' has a wrong offset!");
static_assert(offsetof(UCollisionGeometryVisualizationProperties, LineMaterial) == 0x0000B8, "Member 'UCollisionGeometryVisualizationProperties::LineMaterial' has a wrong offset!");
static_assert(offsetof(UCollisionGeometryVisualizationProperties, LineMaterialShowingHidden) == 0x0000C0, "Member 'UCollisionGeometryVisualizationProperties::LineMaterialShowingHidden' has a wrong offset!");
static_assert(offsetof(UCollisionGeometryVisualizationProperties, TriangleMaterial) == 0x0000C8, "Member 'UCollisionGeometryVisualizationProperties::TriangleMaterial' has a wrong offset!");
static_assert(offsetof(UCollisionGeometryVisualizationProperties, bEnableShowCollision) == 0x0000D0, "Member 'UCollisionGeometryVisualizationProperties::bEnableShowCollision' has a wrong offset!");
static_assert(offsetof(UCollisionGeometryVisualizationProperties, bEnableShowSolid) == 0x0000D1, "Member 'UCollisionGeometryVisualizationProperties::bEnableShowSolid' has a wrong offset!");

// Class MeshModelingToolsExp.ExtractCollisionToolProperties
// 0x0008 (0x00B0 - 0x00A8)
class UExtractCollisionToolProperties final : public UInteractiveToolPropertySet
{
public:
	EExtractCollisionOutputType                   CollisionType;                                     // 0x00A8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOutputSeparateMeshes;                             // 0x00A9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowPreview;                                      // 0x00AA(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowInputMesh;                                    // 0x00AB(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWeldEdges;                                        // 0x00AC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AD[0x3];                                       // 0x00AD(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ExtractCollisionToolProperties">();
	}
	static class UExtractCollisionToolProperties* GetDefaultObj()
	{
		return GetDefaultObjImpl<UExtractCollisionToolProperties>();
	}
};
static_assert(alignof(UExtractCollisionToolProperties) == 0x000008, "Wrong alignment on UExtractCollisionToolProperties");
static_assert(sizeof(UExtractCollisionToolProperties) == 0x0000B0, "Wrong size on UExtractCollisionToolProperties");
static_assert(offsetof(UExtractCollisionToolProperties, CollisionType) == 0x0000A8, "Member 'UExtractCollisionToolProperties::CollisionType' has a wrong offset!");
static_assert(offsetof(UExtractCollisionToolProperties, bOutputSeparateMeshes) == 0x0000A9, "Member 'UExtractCollisionToolProperties::bOutputSeparateMeshes' has a wrong offset!");
static_assert(offsetof(UExtractCollisionToolProperties, bShowPreview) == 0x0000AA, "Member 'UExtractCollisionToolProperties::bShowPreview' has a wrong offset!");
static_assert(offsetof(UExtractCollisionToolProperties, bShowInputMesh) == 0x0000AB, "Member 'UExtractCollisionToolProperties::bShowInputMesh' has a wrong offset!");
static_assert(offsetof(UExtractCollisionToolProperties, bWeldEdges) == 0x0000AC, "Member 'UExtractCollisionToolProperties::bWeldEdges' has a wrong offset!");

// Class MeshModelingToolsExp.PhysicsInspectorToolBuilder
// 0x0000 (0x0028 - 0x0028)
class UPhysicsInspectorToolBuilder final : public UMultiSelectionMeshEditingToolBuilder
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PhysicsInspectorToolBuilder">();
	}
	static class UPhysicsInspectorToolBuilder* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPhysicsInspectorToolBuilder>();
	}
};
static_assert(alignof(UPhysicsInspectorToolBuilder) == 0x000008, "Wrong alignment on UPhysicsInspectorToolBuilder");
static_assert(sizeof(UPhysicsInspectorToolBuilder) == 0x000028, "Wrong size on UPhysicsInspectorToolBuilder");

// Class MeshModelingToolsExp.SetCollisionGeometryToolBuilder
// 0x0000 (0x0028 - 0x0028)
class USetCollisionGeometryToolBuilder final : public UMultiSelectionMeshEditingToolBuilder
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SetCollisionGeometryToolBuilder">();
	}
	static class USetCollisionGeometryToolBuilder* GetDefaultObj()
	{
		return GetDefaultObjImpl<USetCollisionGeometryToolBuilder>();
	}
};
static_assert(alignof(USetCollisionGeometryToolBuilder) == 0x000008, "Wrong alignment on USetCollisionGeometryToolBuilder");
static_assert(sizeof(USetCollisionGeometryToolBuilder) == 0x000028, "Wrong size on USetCollisionGeometryToolBuilder");

// Class MeshModelingToolsExp.SetCollisionGeometryTool
// 0x02C8 (0x0380 - 0x00B8)
class alignas(0x10) USetCollisionGeometryTool final : public UMultiSelectionMeshEditingTool
{
public:
	uint8                                         Pad_B8[0x10];                                      // 0x00B8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class USetCollisionGeometryToolProperties*    Settings;                                          // 0x00C8(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPolygroupLayersProperties*             PolygroupLayerProperties;                          // 0x00D0(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCollisionGeometryVisualizationProperties* VizSettings;                                       // 0x00D8(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPhysicsObjectToolPropertySet*          CollisionProps;                                    // 0x00E0(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E8[0x8];                                       // 0x00E8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UPreviewGeometry*                       PreviewGeom;                                       // 0x00F0(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_F8[0x278];                                     // 0x00F8(0x0278)(Fixing Size After Last Property [ Dumper-7 ])
	class UGeometrySelectionVisualizationProperties* GeometrySelectionVizProperties;                    // 0x0370(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPreviewGeometry*                       GeometrySelectionViz;                              // 0x0378(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SetCollisionGeometryTool">();
	}
	static class USetCollisionGeometryTool* GetDefaultObj()
	{
		return GetDefaultObjImpl<USetCollisionGeometryTool>();
	}
};
static_assert(alignof(USetCollisionGeometryTool) == 0x000010, "Wrong alignment on USetCollisionGeometryTool");
static_assert(sizeof(USetCollisionGeometryTool) == 0x000380, "Wrong size on USetCollisionGeometryTool");
static_assert(offsetof(USetCollisionGeometryTool, Settings) == 0x0000C8, "Member 'USetCollisionGeometryTool::Settings' has a wrong offset!");
static_assert(offsetof(USetCollisionGeometryTool, PolygroupLayerProperties) == 0x0000D0, "Member 'USetCollisionGeometryTool::PolygroupLayerProperties' has a wrong offset!");
static_assert(offsetof(USetCollisionGeometryTool, VizSettings) == 0x0000D8, "Member 'USetCollisionGeometryTool::VizSettings' has a wrong offset!");
static_assert(offsetof(USetCollisionGeometryTool, CollisionProps) == 0x0000E0, "Member 'USetCollisionGeometryTool::CollisionProps' has a wrong offset!");
static_assert(offsetof(USetCollisionGeometryTool, PreviewGeom) == 0x0000F0, "Member 'USetCollisionGeometryTool::PreviewGeom' has a wrong offset!");
static_assert(offsetof(USetCollisionGeometryTool, GeometrySelectionVizProperties) == 0x000370, "Member 'USetCollisionGeometryTool::GeometrySelectionVizProperties' has a wrong offset!");
static_assert(offsetof(USetCollisionGeometryTool, GeometrySelectionViz) == 0x000378, "Member 'USetCollisionGeometryTool::GeometrySelectionViz' has a wrong offset!");

// Class MeshModelingToolsExp.SimpleCollisionEditorToolActionProperties
// 0x0008 (0x00B0 - 0x00A8)
class USimpleCollisionEditorToolActionProperties final : public UInteractiveToolPropertySet
{
public:
	uint8                                         Pad_A8[0x8];                                       // 0x00A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddBox();
	void AddCapsule();
	void AddSphere();
	void Delete();
	void DeleteAll();
	void Duplicate();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SimpleCollisionEditorToolActionProperties">();
	}
	static class USimpleCollisionEditorToolActionProperties* GetDefaultObj()
	{
		return GetDefaultObjImpl<USimpleCollisionEditorToolActionProperties>();
	}
};
static_assert(alignof(USimpleCollisionEditorToolActionProperties) == 0x000008, "Wrong alignment on USimpleCollisionEditorToolActionProperties");
static_assert(sizeof(USimpleCollisionEditorToolActionProperties) == 0x0000B0, "Wrong size on USimpleCollisionEditorToolActionProperties");

// Class MeshModelingToolsExp.PlaneCutToolBuilder
// 0x0000 (0x0028 - 0x0028)
class UPlaneCutToolBuilder final : public UMultiSelectionMeshEditingToolBuilder
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlaneCutToolBuilder">();
	}
	static class UPlaneCutToolBuilder* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlaneCutToolBuilder>();
	}
};
static_assert(alignof(UPlaneCutToolBuilder) == 0x000008, "Wrong alignment on UPlaneCutToolBuilder");
static_assert(sizeof(UPlaneCutToolBuilder) == 0x000028, "Wrong size on UPlaneCutToolBuilder");

// Class MeshModelingToolsExp.PlaneCutToolProperties
// 0x0010 (0x00B8 - 0x00A8)
class UPlaneCutToolProperties final : public UInteractiveToolPropertySet
{
public:
	bool                                          bKeepBothHalves;                                   // 0x00A8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A9[0x3];                                       // 0x00A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SpacingBetweenHalves;                              // 0x00AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bExportSeparatedPiecesAsNewMeshAssets;             // 0x00B0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowPreview;                                      // 0x00B1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFillCutHole;                                      // 0x00B2(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFillSpans;                                        // 0x00B3(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSimplifyAlongCut;                                 // 0x00B4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B5[0x3];                                       // 0x00B5(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlaneCutToolProperties">();
	}
	static class UPlaneCutToolProperties* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlaneCutToolProperties>();
	}
};
static_assert(alignof(UPlaneCutToolProperties) == 0x000008, "Wrong alignment on UPlaneCutToolProperties");
static_assert(sizeof(UPlaneCutToolProperties) == 0x0000B8, "Wrong size on UPlaneCutToolProperties");
static_assert(offsetof(UPlaneCutToolProperties, bKeepBothHalves) == 0x0000A8, "Member 'UPlaneCutToolProperties::bKeepBothHalves' has a wrong offset!");
static_assert(offsetof(UPlaneCutToolProperties, SpacingBetweenHalves) == 0x0000AC, "Member 'UPlaneCutToolProperties::SpacingBetweenHalves' has a wrong offset!");
static_assert(offsetof(UPlaneCutToolProperties, bExportSeparatedPiecesAsNewMeshAssets) == 0x0000B0, "Member 'UPlaneCutToolProperties::bExportSeparatedPiecesAsNewMeshAssets' has a wrong offset!");
static_assert(offsetof(UPlaneCutToolProperties, bShowPreview) == 0x0000B1, "Member 'UPlaneCutToolProperties::bShowPreview' has a wrong offset!");
static_assert(offsetof(UPlaneCutToolProperties, bFillCutHole) == 0x0000B2, "Member 'UPlaneCutToolProperties::bFillCutHole' has a wrong offset!");
static_assert(offsetof(UPlaneCutToolProperties, bFillSpans) == 0x0000B3, "Member 'UPlaneCutToolProperties::bFillSpans' has a wrong offset!");
static_assert(offsetof(UPlaneCutToolProperties, bSimplifyAlongCut) == 0x0000B4, "Member 'UPlaneCutToolProperties::bSimplifyAlongCut' has a wrong offset!");

// Class MeshModelingToolsExp.PlaneCutOperatorFactory
// 0x0018 (0x0040 - 0x0028)
class UPlaneCutOperatorFactory final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UPlaneCutTool*                          CutTool;                                           // 0x0030(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlaneCutOperatorFactory">();
	}
	static class UPlaneCutOperatorFactory* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlaneCutOperatorFactory>();
	}
};
static_assert(alignof(UPlaneCutOperatorFactory) == 0x000008, "Wrong alignment on UPlaneCutOperatorFactory");
static_assert(sizeof(UPlaneCutOperatorFactory) == 0x000040, "Wrong size on UPlaneCutOperatorFactory");
static_assert(offsetof(UPlaneCutOperatorFactory, CutTool) == 0x000030, "Member 'UPlaneCutOperatorFactory::CutTool' has a wrong offset!");

// Class MeshModelingToolsExp.PlaneCutTool
// 0x00D8 (0x0190 - 0x00B8)
class alignas(0x10) UPlaneCutTool final : public UMultiSelectionMeshEditingTool
{
public:
	class UPlaneCutToolProperties*                BasicProperties;                                   // 0x00B8(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UMeshOpPreviewWithBackgroundCompute*> Previews;                                          // 0x00C0(0x0010)(ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<class UDynamicMeshReplacementChangeTarget*> MeshesToCut;                                       // 0x00D0(0x0010)(ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	class UConstructionPlaneMechanic*             PlaneMechanic;                                     // 0x00E0(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E8[0xA8];                                      // 0x00E8(0x00A8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Cut();
	void FlipPlane();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlaneCutTool">();
	}
	static class UPlaneCutTool* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlaneCutTool>();
	}
};
static_assert(alignof(UPlaneCutTool) == 0x000010, "Wrong alignment on UPlaneCutTool");
static_assert(sizeof(UPlaneCutTool) == 0x000190, "Wrong size on UPlaneCutTool");
static_assert(offsetof(UPlaneCutTool, BasicProperties) == 0x0000B8, "Member 'UPlaneCutTool::BasicProperties' has a wrong offset!");
static_assert(offsetof(UPlaneCutTool, Previews) == 0x0000C0, "Member 'UPlaneCutTool::Previews' has a wrong offset!");
static_assert(offsetof(UPlaneCutTool, MeshesToCut) == 0x0000D0, "Member 'UPlaneCutTool::MeshesToCut' has a wrong offset!");
static_assert(offsetof(UPlaneCutTool, PlaneMechanic) == 0x0000E0, "Member 'UPlaneCutTool::PlaneMechanic' has a wrong offset!");

// Class MeshModelingToolsExp.ProjectToTargetToolBuilder
// 0x0000 (0x0028 - 0x0028)
class UProjectToTargetToolBuilder final : public UMultiSelectionMeshEditingToolBuilder
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProjectToTargetToolBuilder">();
	}
	static class UProjectToTargetToolBuilder* GetDefaultObj()
	{
		return GetDefaultObjImpl<UProjectToTargetToolBuilder>();
	}
};
static_assert(alignof(UProjectToTargetToolBuilder) == 0x000008, "Wrong alignment on UProjectToTargetToolBuilder");
static_assert(sizeof(UProjectToTargetToolBuilder) == 0x000028, "Wrong size on UProjectToTargetToolBuilder");

// Class MeshModelingToolsExp.RemeshMeshToolProperties
// 0x0028 (0x00E0 - 0x00B8)
class URemeshMeshToolProperties : public URemeshProperties
{
public:
	int32                                         TargetTriangleCount;                               // 0x00B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERemeshSmoothingType                          SmoothingType;                                     // 0x00BC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDiscardAttributes;                                // 0x00BD(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowGroupColors;                                  // 0x00BE(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERemeshType                                   RemeshType;                                        // 0x00BF(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RemeshIterations;                                  // 0x00C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxRemeshIterations;                               // 0x00C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ExtraProjectionIterations;                         // 0x00C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseTargetEdgeLength;                              // 0x00CC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CD[0x3];                                       // 0x00CD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TargetEdgeLength;                                  // 0x00D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bReproject;                                        // 0x00D4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bReprojectConstraints;                             // 0x00D5(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D6[0x2];                                       // 0x00D6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BoundaryCornerAngleThreshold;                      // 0x00D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DC[0x4];                                       // 0x00DC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RemeshMeshToolProperties">();
	}
	static class URemeshMeshToolProperties* GetDefaultObj()
	{
		return GetDefaultObjImpl<URemeshMeshToolProperties>();
	}
};
static_assert(alignof(URemeshMeshToolProperties) == 0x000008, "Wrong alignment on URemeshMeshToolProperties");
static_assert(sizeof(URemeshMeshToolProperties) == 0x0000E0, "Wrong size on URemeshMeshToolProperties");
static_assert(offsetof(URemeshMeshToolProperties, TargetTriangleCount) == 0x0000B8, "Member 'URemeshMeshToolProperties::TargetTriangleCount' has a wrong offset!");
static_assert(offsetof(URemeshMeshToolProperties, SmoothingType) == 0x0000BC, "Member 'URemeshMeshToolProperties::SmoothingType' has a wrong offset!");
static_assert(offsetof(URemeshMeshToolProperties, bDiscardAttributes) == 0x0000BD, "Member 'URemeshMeshToolProperties::bDiscardAttributes' has a wrong offset!");
static_assert(offsetof(URemeshMeshToolProperties, bShowGroupColors) == 0x0000BE, "Member 'URemeshMeshToolProperties::bShowGroupColors' has a wrong offset!");
static_assert(offsetof(URemeshMeshToolProperties, RemeshType) == 0x0000BF, "Member 'URemeshMeshToolProperties::RemeshType' has a wrong offset!");
static_assert(offsetof(URemeshMeshToolProperties, RemeshIterations) == 0x0000C0, "Member 'URemeshMeshToolProperties::RemeshIterations' has a wrong offset!");
static_assert(offsetof(URemeshMeshToolProperties, MaxRemeshIterations) == 0x0000C4, "Member 'URemeshMeshToolProperties::MaxRemeshIterations' has a wrong offset!");
static_assert(offsetof(URemeshMeshToolProperties, ExtraProjectionIterations) == 0x0000C8, "Member 'URemeshMeshToolProperties::ExtraProjectionIterations' has a wrong offset!");
static_assert(offsetof(URemeshMeshToolProperties, bUseTargetEdgeLength) == 0x0000CC, "Member 'URemeshMeshToolProperties::bUseTargetEdgeLength' has a wrong offset!");
static_assert(offsetof(URemeshMeshToolProperties, TargetEdgeLength) == 0x0000D0, "Member 'URemeshMeshToolProperties::TargetEdgeLength' has a wrong offset!");
static_assert(offsetof(URemeshMeshToolProperties, bReproject) == 0x0000D4, "Member 'URemeshMeshToolProperties::bReproject' has a wrong offset!");
static_assert(offsetof(URemeshMeshToolProperties, bReprojectConstraints) == 0x0000D5, "Member 'URemeshMeshToolProperties::bReprojectConstraints' has a wrong offset!");
static_assert(offsetof(URemeshMeshToolProperties, BoundaryCornerAngleThreshold) == 0x0000D8, "Member 'URemeshMeshToolProperties::BoundaryCornerAngleThreshold' has a wrong offset!");

// Class MeshModelingToolsExp.ProjectToTargetToolProperties
// 0x0020 (0x0100 - 0x00E0)
class UProjectToTargetToolProperties final : public URemeshMeshToolProperties
{
public:
	bool                                          bWorldSpace;                                       // 0x00E0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bParallel;                                         // 0x00E1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E2[0x2];                                       // 0x00E2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         FaceProjectionPassesPerRemeshIteration;            // 0x00E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SurfaceProjectionSpeed;                            // 0x00E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NormalAlignmentSpeed;                              // 0x00EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSmoothInFillAreas;                                // 0x00F0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F1[0x3];                                       // 0x00F1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FillAreaDistanceMultiplier;                        // 0x00F4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FillAreaSmoothMultiplier;                          // 0x00F8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FC[0x4];                                       // 0x00FC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProjectToTargetToolProperties">();
	}
	static class UProjectToTargetToolProperties* GetDefaultObj()
	{
		return GetDefaultObjImpl<UProjectToTargetToolProperties>();
	}
};
static_assert(alignof(UProjectToTargetToolProperties) == 0x000008, "Wrong alignment on UProjectToTargetToolProperties");
static_assert(sizeof(UProjectToTargetToolProperties) == 0x000100, "Wrong size on UProjectToTargetToolProperties");
static_assert(offsetof(UProjectToTargetToolProperties, bWorldSpace) == 0x0000E0, "Member 'UProjectToTargetToolProperties::bWorldSpace' has a wrong offset!");
static_assert(offsetof(UProjectToTargetToolProperties, bParallel) == 0x0000E1, "Member 'UProjectToTargetToolProperties::bParallel' has a wrong offset!");
static_assert(offsetof(UProjectToTargetToolProperties, FaceProjectionPassesPerRemeshIteration) == 0x0000E4, "Member 'UProjectToTargetToolProperties::FaceProjectionPassesPerRemeshIteration' has a wrong offset!");
static_assert(offsetof(UProjectToTargetToolProperties, SurfaceProjectionSpeed) == 0x0000E8, "Member 'UProjectToTargetToolProperties::SurfaceProjectionSpeed' has a wrong offset!");
static_assert(offsetof(UProjectToTargetToolProperties, NormalAlignmentSpeed) == 0x0000EC, "Member 'UProjectToTargetToolProperties::NormalAlignmentSpeed' has a wrong offset!");
static_assert(offsetof(UProjectToTargetToolProperties, bSmoothInFillAreas) == 0x0000F0, "Member 'UProjectToTargetToolProperties::bSmoothInFillAreas' has a wrong offset!");
static_assert(offsetof(UProjectToTargetToolProperties, FillAreaDistanceMultiplier) == 0x0000F4, "Member 'UProjectToTargetToolProperties::FillAreaDistanceMultiplier' has a wrong offset!");
static_assert(offsetof(UProjectToTargetToolProperties, FillAreaSmoothMultiplier) == 0x0000F8, "Member 'UProjectToTargetToolProperties::FillAreaSmoothMultiplier' has a wrong offset!");

// Class MeshModelingToolsExp.RemeshMeshTool
// 0x0050 (0x0108 - 0x00B8)
class URemeshMeshTool : public UMultiSelectionMeshEditingTool
{
public:
	uint8                                         Pad_B8[0x8];                                       // 0x00B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class URemeshMeshToolProperties*              BasicProperties;                                   // 0x00C0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMeshStatisticsProperties*              MeshStatisticsProperties;                          // 0x00C8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMeshOpPreviewWithBackgroundCompute*    Preview;                                           // 0x00D0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMeshElementsVisualizer*                MeshElementsDisplay;                               // 0x00D8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E0[0x28];                                      // 0x00E0(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RemeshMeshTool">();
	}
	static class URemeshMeshTool* GetDefaultObj()
	{
		return GetDefaultObjImpl<URemeshMeshTool>();
	}
};
static_assert(alignof(URemeshMeshTool) == 0x000008, "Wrong alignment on URemeshMeshTool");
static_assert(sizeof(URemeshMeshTool) == 0x000108, "Wrong size on URemeshMeshTool");
static_assert(offsetof(URemeshMeshTool, BasicProperties) == 0x0000C0, "Member 'URemeshMeshTool::BasicProperties' has a wrong offset!");
static_assert(offsetof(URemeshMeshTool, MeshStatisticsProperties) == 0x0000C8, "Member 'URemeshMeshTool::MeshStatisticsProperties' has a wrong offset!");
static_assert(offsetof(URemeshMeshTool, Preview) == 0x0000D0, "Member 'URemeshMeshTool::Preview' has a wrong offset!");
static_assert(offsetof(URemeshMeshTool, MeshElementsDisplay) == 0x0000D8, "Member 'URemeshMeshTool::MeshElementsDisplay' has a wrong offset!");

// Class MeshModelingToolsExp.ProjectToTargetTool
// 0x0010 (0x0118 - 0x0108)
class UProjectToTargetTool final : public URemeshMeshTool
{
public:
	uint8                                         Pad_108[0x10];                                     // 0x0108(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProjectToTargetTool">();
	}
	static class UProjectToTargetTool* GetDefaultObj()
	{
		return GetDefaultObjImpl<UProjectToTargetTool>();
	}
};
static_assert(alignof(UProjectToTargetTool) == 0x000008, "Wrong alignment on UProjectToTargetTool");
static_assert(sizeof(UProjectToTargetTool) == 0x000118, "Wrong size on UProjectToTargetTool");

// Class MeshModelingToolsExp.MeshAnalysisProperties
// 0x0020 (0x00C8 - 0x00A8)
class UMeshAnalysisProperties final : public UInteractiveToolPropertySet
{
public:
	class FString                                 SurfaceArea;                                       // 0x00A8(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Volume;                                            // 0x00B8(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MeshAnalysisProperties">();
	}
	static class UMeshAnalysisProperties* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMeshAnalysisProperties>();
	}
};
static_assert(alignof(UMeshAnalysisProperties) == 0x000008, "Wrong alignment on UMeshAnalysisProperties");
static_assert(sizeof(UMeshAnalysisProperties) == 0x0000C8, "Wrong size on UMeshAnalysisProperties");
static_assert(offsetof(UMeshAnalysisProperties, SurfaceArea) == 0x0000A8, "Member 'UMeshAnalysisProperties::SurfaceArea' has a wrong offset!");
static_assert(offsetof(UMeshAnalysisProperties, Volume) == 0x0000B8, "Member 'UMeshAnalysisProperties::Volume' has a wrong offset!");

// Class MeshModelingToolsExp.MeshStatisticsProperties
// 0x0030 (0x00D8 - 0x00A8)
class UMeshStatisticsProperties final : public UInteractiveToolPropertySet
{
public:
	class FString                                 Mesh;                                              // 0x00A8(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 UV;                                                // 0x00B8(0x0010)(Edit, ZeroConstructor, EditConst, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Attributes;                                        // 0x00C8(0x0010)(Edit, ZeroConstructor, EditConst, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MeshStatisticsProperties">();
	}
	static class UMeshStatisticsProperties* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMeshStatisticsProperties>();
	}
};
static_assert(alignof(UMeshStatisticsProperties) == 0x000008, "Wrong alignment on UMeshStatisticsProperties");
static_assert(sizeof(UMeshStatisticsProperties) == 0x0000D8, "Wrong size on UMeshStatisticsProperties");
static_assert(offsetof(UMeshStatisticsProperties, Mesh) == 0x0000A8, "Member 'UMeshStatisticsProperties::Mesh' has a wrong offset!");
static_assert(offsetof(UMeshStatisticsProperties, UV) == 0x0000B8, "Member 'UMeshStatisticsProperties::UV' has a wrong offset!");
static_assert(offsetof(UMeshStatisticsProperties, Attributes) == 0x0000C8, "Member 'UMeshStatisticsProperties::Attributes' has a wrong offset!");

// Class MeshModelingToolsExp.RemeshMeshToolBuilder
// 0x0000 (0x0028 - 0x0028)
class URemeshMeshToolBuilder final : public UMultiSelectionMeshEditingToolBuilder
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RemeshMeshToolBuilder">();
	}
	static class URemeshMeshToolBuilder* GetDefaultObj()
	{
		return GetDefaultObjImpl<URemeshMeshToolBuilder>();
	}
};
static_assert(alignof(URemeshMeshToolBuilder) == 0x000008, "Wrong alignment on URemeshMeshToolBuilder");
static_assert(sizeof(URemeshMeshToolBuilder) == 0x000028, "Wrong size on URemeshMeshToolBuilder");

// Class MeshModelingToolsExp.RemoveOccludedTrianglesToolBuilder
// 0x0000 (0x0028 - 0x0028)
class URemoveOccludedTrianglesToolBuilder final : public UMultiSelectionMeshEditingToolBuilder
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RemoveOccludedTrianglesToolBuilder">();
	}
	static class URemoveOccludedTrianglesToolBuilder* GetDefaultObj()
	{
		return GetDefaultObjImpl<URemoveOccludedTrianglesToolBuilder>();
	}
};
static_assert(alignof(URemoveOccludedTrianglesToolBuilder) == 0x000008, "Wrong alignment on URemoveOccludedTrianglesToolBuilder");
static_assert(sizeof(URemoveOccludedTrianglesToolBuilder) == 0x000028, "Wrong size on URemoveOccludedTrianglesToolBuilder");

// Class MeshModelingToolsExp.RemoveOccludedTrianglesToolProperties
// 0x0030 (0x00D8 - 0x00A8)
class URemoveOccludedTrianglesToolProperties final : public UInteractiveToolPropertySet
{
public:
	EOcclusionCalculationUIMode                   OcclusionTestMethod;                               // 0x00A8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOcclusionTriangleSamplingUIMode              TriangleSampling;                                  // 0x00A9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AA[0x6];                                       // 0x00AA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        WindingIsoValue;                                   // 0x00B0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AddRandomRays;                                     // 0x00B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AddTriangleSamples;                                // 0x00BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOnlySelfOcclude;                                  // 0x00C0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C1[0x3];                                       // 0x00C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ShrinkRemoval;                                     // 0x00C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        MinAreaIsland;                                     // 0x00C8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MinTriCountIsland;                                 // 0x00D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOccludedAction                               Action;                                            // 0x00D4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D5[0x3];                                       // 0x00D5(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RemoveOccludedTrianglesToolProperties">();
	}
	static class URemoveOccludedTrianglesToolProperties* GetDefaultObj()
	{
		return GetDefaultObjImpl<URemoveOccludedTrianglesToolProperties>();
	}
};
static_assert(alignof(URemoveOccludedTrianglesToolProperties) == 0x000008, "Wrong alignment on URemoveOccludedTrianglesToolProperties");
static_assert(sizeof(URemoveOccludedTrianglesToolProperties) == 0x0000D8, "Wrong size on URemoveOccludedTrianglesToolProperties");
static_assert(offsetof(URemoveOccludedTrianglesToolProperties, OcclusionTestMethod) == 0x0000A8, "Member 'URemoveOccludedTrianglesToolProperties::OcclusionTestMethod' has a wrong offset!");
static_assert(offsetof(URemoveOccludedTrianglesToolProperties, TriangleSampling) == 0x0000A9, "Member 'URemoveOccludedTrianglesToolProperties::TriangleSampling' has a wrong offset!");
static_assert(offsetof(URemoveOccludedTrianglesToolProperties, WindingIsoValue) == 0x0000B0, "Member 'URemoveOccludedTrianglesToolProperties::WindingIsoValue' has a wrong offset!");
static_assert(offsetof(URemoveOccludedTrianglesToolProperties, AddRandomRays) == 0x0000B8, "Member 'URemoveOccludedTrianglesToolProperties::AddRandomRays' has a wrong offset!");
static_assert(offsetof(URemoveOccludedTrianglesToolProperties, AddTriangleSamples) == 0x0000BC, "Member 'URemoveOccludedTrianglesToolProperties::AddTriangleSamples' has a wrong offset!");
static_assert(offsetof(URemoveOccludedTrianglesToolProperties, bOnlySelfOcclude) == 0x0000C0, "Member 'URemoveOccludedTrianglesToolProperties::bOnlySelfOcclude' has a wrong offset!");
static_assert(offsetof(URemoveOccludedTrianglesToolProperties, ShrinkRemoval) == 0x0000C4, "Member 'URemoveOccludedTrianglesToolProperties::ShrinkRemoval' has a wrong offset!");
static_assert(offsetof(URemoveOccludedTrianglesToolProperties, MinAreaIsland) == 0x0000C8, "Member 'URemoveOccludedTrianglesToolProperties::MinAreaIsland' has a wrong offset!");
static_assert(offsetof(URemoveOccludedTrianglesToolProperties, MinTriCountIsland) == 0x0000D0, "Member 'URemoveOccludedTrianglesToolProperties::MinTriCountIsland' has a wrong offset!");
static_assert(offsetof(URemoveOccludedTrianglesToolProperties, Action) == 0x0000D4, "Member 'URemoveOccludedTrianglesToolProperties::Action' has a wrong offset!");

// Class MeshModelingToolsExp.RemoveOccludedTrianglesAdvancedProperties
// 0x0008 (0x00B0 - 0x00A8)
class URemoveOccludedTrianglesAdvancedProperties final : public UInteractiveToolPropertySet
{
public:
	uint8                                         Pad_A8[0x8];                                       // 0x00A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RemoveOccludedTrianglesAdvancedProperties">();
	}
	static class URemoveOccludedTrianglesAdvancedProperties* GetDefaultObj()
	{
		return GetDefaultObjImpl<URemoveOccludedTrianglesAdvancedProperties>();
	}
};
static_assert(alignof(URemoveOccludedTrianglesAdvancedProperties) == 0x000008, "Wrong alignment on URemoveOccludedTrianglesAdvancedProperties");
static_assert(sizeof(URemoveOccludedTrianglesAdvancedProperties) == 0x0000B0, "Wrong size on URemoveOccludedTrianglesAdvancedProperties");

// Class MeshModelingToolsExp.RemoveOccludedTrianglesOperatorFactory
// 0x0018 (0x0040 - 0x0028)
class URemoveOccludedTrianglesOperatorFactory final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class URemoveOccludedTrianglesTool*           Tool;                                              // 0x0030(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RemoveOccludedTrianglesOperatorFactory">();
	}
	static class URemoveOccludedTrianglesOperatorFactory* GetDefaultObj()
	{
		return GetDefaultObjImpl<URemoveOccludedTrianglesOperatorFactory>();
	}
};
static_assert(alignof(URemoveOccludedTrianglesOperatorFactory) == 0x000008, "Wrong alignment on URemoveOccludedTrianglesOperatorFactory");
static_assert(sizeof(URemoveOccludedTrianglesOperatorFactory) == 0x000040, "Wrong size on URemoveOccludedTrianglesOperatorFactory");
static_assert(offsetof(URemoveOccludedTrianglesOperatorFactory, Tool) == 0x000030, "Member 'URemoveOccludedTrianglesOperatorFactory::Tool' has a wrong offset!");

// Class MeshModelingToolsExp.RemoveOccludedTrianglesTool
// 0x0118 (0x01D0 - 0x00B8)
class alignas(0x10) URemoveOccludedTrianglesTool final : public UMultiSelectionMeshEditingTool
{
public:
	class URemoveOccludedTrianglesToolProperties* BasicProperties;                                   // 0x00B8(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPolygroupLayersProperties*             PolygroupLayersProperties;                         // 0x00C0(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URemoveOccludedTrianglesAdvancedProperties* AdvancedProperties;                                // 0x00C8(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UMeshOpPreviewWithBackgroundCompute*> Previews;                                          // 0x00D0(0x0010)(ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<class UPreviewMesh*>                   PreviewCopies;                                     // 0x00E0(0x0010)(ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	uint8                                         Pad_F0[0xE0];                                      // 0x00F0(0x00E0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RemoveOccludedTrianglesTool">();
	}
	static class URemoveOccludedTrianglesTool* GetDefaultObj()
	{
		return GetDefaultObjImpl<URemoveOccludedTrianglesTool>();
	}
};
static_assert(alignof(URemoveOccludedTrianglesTool) == 0x000010, "Wrong alignment on URemoveOccludedTrianglesTool");
static_assert(sizeof(URemoveOccludedTrianglesTool) == 0x0001D0, "Wrong size on URemoveOccludedTrianglesTool");
static_assert(offsetof(URemoveOccludedTrianglesTool, BasicProperties) == 0x0000B8, "Member 'URemoveOccludedTrianglesTool::BasicProperties' has a wrong offset!");
static_assert(offsetof(URemoveOccludedTrianglesTool, PolygroupLayersProperties) == 0x0000C0, "Member 'URemoveOccludedTrianglesTool::PolygroupLayersProperties' has a wrong offset!");
static_assert(offsetof(URemoveOccludedTrianglesTool, AdvancedProperties) == 0x0000C8, "Member 'URemoveOccludedTrianglesTool::AdvancedProperties' has a wrong offset!");
static_assert(offsetof(URemoveOccludedTrianglesTool, Previews) == 0x0000D0, "Member 'URemoveOccludedTrianglesTool::Previews' has a wrong offset!");
static_assert(offsetof(URemoveOccludedTrianglesTool, PreviewCopies) == 0x0000E0, "Member 'URemoveOccludedTrianglesTool::PreviewCopies' has a wrong offset!");

// Class MeshModelingToolsExp.RevolveBoundaryToolBuilder
// 0x0000 (0x0028 - 0x0028)
class URevolveBoundaryToolBuilder final : public USingleSelectionMeshEditingToolBuilder
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RevolveBoundaryToolBuilder">();
	}
	static class URevolveBoundaryToolBuilder* GetDefaultObj()
	{
		return GetDefaultObjImpl<URevolveBoundaryToolBuilder>();
	}
};
static_assert(alignof(URevolveBoundaryToolBuilder) == 0x000008, "Wrong alignment on URevolveBoundaryToolBuilder");
static_assert(sizeof(URevolveBoundaryToolBuilder) == 0x000028, "Wrong size on URevolveBoundaryToolBuilder");

// Class MeshModelingToolsExp.RevolveBoundaryOperatorFactory
// 0x0010 (0x0038 - 0x0028)
class URevolveBoundaryOperatorFactory final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class URevolveBoundaryTool*                   RevolveBoundaryTool;                               // 0x0030(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RevolveBoundaryOperatorFactory">();
	}
	static class URevolveBoundaryOperatorFactory* GetDefaultObj()
	{
		return GetDefaultObjImpl<URevolveBoundaryOperatorFactory>();
	}
};
static_assert(alignof(URevolveBoundaryOperatorFactory) == 0x000008, "Wrong alignment on URevolveBoundaryOperatorFactory");
static_assert(sizeof(URevolveBoundaryOperatorFactory) == 0x000038, "Wrong size on URevolveBoundaryOperatorFactory");
static_assert(offsetof(URevolveBoundaryOperatorFactory, RevolveBoundaryTool) == 0x000030, "Member 'URevolveBoundaryOperatorFactory::RevolveBoundaryTool' has a wrong offset!");

// Class MeshModelingToolsExp.RevolveBoundaryToolProperties
// 0x0030 (0x0148 - 0x0118)
class URevolveBoundaryToolProperties final : public URevolveProperties
{
public:
	ERevolvePropertiesCapFillMode                 CapFillMode;                                       // 0x0118(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisplayInputMesh;                                 // 0x0119(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11A[0x6];                                      // 0x011A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                AxisOrigin;                                        // 0x0120(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              AxisOrientation;                                   // 0x0138(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RevolveBoundaryToolProperties">();
	}
	static class URevolveBoundaryToolProperties* GetDefaultObj()
	{
		return GetDefaultObjImpl<URevolveBoundaryToolProperties>();
	}
};
static_assert(alignof(URevolveBoundaryToolProperties) == 0x000008, "Wrong alignment on URevolveBoundaryToolProperties");
static_assert(sizeof(URevolveBoundaryToolProperties) == 0x000148, "Wrong size on URevolveBoundaryToolProperties");
static_assert(offsetof(URevolveBoundaryToolProperties, CapFillMode) == 0x000118, "Member 'URevolveBoundaryToolProperties::CapFillMode' has a wrong offset!");
static_assert(offsetof(URevolveBoundaryToolProperties, bDisplayInputMesh) == 0x000119, "Member 'URevolveBoundaryToolProperties::bDisplayInputMesh' has a wrong offset!");
static_assert(offsetof(URevolveBoundaryToolProperties, AxisOrigin) == 0x000120, "Member 'URevolveBoundaryToolProperties::AxisOrigin' has a wrong offset!");
static_assert(offsetof(URevolveBoundaryToolProperties, AxisOrientation) == 0x000138, "Member 'URevolveBoundaryToolProperties::AxisOrientation' has a wrong offset!");

// Class MeshModelingToolsExp.RevolveBoundaryTool
// 0x0070 (0x0210 - 0x01A0)
class URevolveBoundaryTool final : public UMeshBoundaryToolBase
{
public:
	uint8                                         Pad_1A0[0x18];                                     // 0x01A0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UCreateMeshObjectTypeProperties*        OutputTypeProperties;                              // 0x01B8(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URevolveBoundaryToolProperties*         Settings;                                          // 0x01C0(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNewMeshMaterialProperties*             MaterialProperties;                                // 0x01C8(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UConstructionPlaneMechanic*             PlaneMechanic;                                     // 0x01D0(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMeshOpPreviewWithBackgroundCompute*    Preview;                                           // 0x01D8(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1E0[0x30];                                     // 0x01E0(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RevolveBoundaryTool">();
	}
	static class URevolveBoundaryTool* GetDefaultObj()
	{
		return GetDefaultObjImpl<URevolveBoundaryTool>();
	}
};
static_assert(alignof(URevolveBoundaryTool) == 0x000010, "Wrong alignment on URevolveBoundaryTool");
static_assert(sizeof(URevolveBoundaryTool) == 0x000210, "Wrong size on URevolveBoundaryTool");
static_assert(offsetof(URevolveBoundaryTool, OutputTypeProperties) == 0x0001B8, "Member 'URevolveBoundaryTool::OutputTypeProperties' has a wrong offset!");
static_assert(offsetof(URevolveBoundaryTool, Settings) == 0x0001C0, "Member 'URevolveBoundaryTool::Settings' has a wrong offset!");
static_assert(offsetof(URevolveBoundaryTool, MaterialProperties) == 0x0001C8, "Member 'URevolveBoundaryTool::MaterialProperties' has a wrong offset!");
static_assert(offsetof(URevolveBoundaryTool, PlaneMechanic) == 0x0001D0, "Member 'URevolveBoundaryTool::PlaneMechanic' has a wrong offset!");
static_assert(offsetof(URevolveBoundaryTool, Preview) == 0x0001D8, "Member 'URevolveBoundaryTool::Preview' has a wrong offset!");

// Class MeshModelingToolsExp.SculptBrushProperties
// 0x0038 (0x00E0 - 0x00A8)
class USculptBrushProperties final : public UInteractiveToolPropertySet
{
public:
	struct FBrushToolRadius                       BrushSize;                                         // 0x00A8(0x0014)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	float                                         BrushFalloffAmount;                                // 0x00BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowFalloff;                                      // 0x00C0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C1[0x3];                                       // 0x00C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Depth;                                             // 0x00C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHitBackFaces;                                     // 0x00C8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C9[0x3];                                       // 0x00C9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FlowRate;                                          // 0x00CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Spacing;                                           // 0x00D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Lazyness;                                          // 0x00D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowPerBrushProps;                                // 0x00D8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowLazyness;                                     // 0x00D9(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowFlowRate;                                     // 0x00DA(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowSpacing;                                      // 0x00DB(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DC[0x4];                                       // 0x00DC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SculptBrushProperties">();
	}
	static class USculptBrushProperties* GetDefaultObj()
	{
		return GetDefaultObjImpl<USculptBrushProperties>();
	}
};
static_assert(alignof(USculptBrushProperties) == 0x000008, "Wrong alignment on USculptBrushProperties");
static_assert(sizeof(USculptBrushProperties) == 0x0000E0, "Wrong size on USculptBrushProperties");
static_assert(offsetof(USculptBrushProperties, BrushSize) == 0x0000A8, "Member 'USculptBrushProperties::BrushSize' has a wrong offset!");
static_assert(offsetof(USculptBrushProperties, BrushFalloffAmount) == 0x0000BC, "Member 'USculptBrushProperties::BrushFalloffAmount' has a wrong offset!");
static_assert(offsetof(USculptBrushProperties, bShowFalloff) == 0x0000C0, "Member 'USculptBrushProperties::bShowFalloff' has a wrong offset!");
static_assert(offsetof(USculptBrushProperties, Depth) == 0x0000C4, "Member 'USculptBrushProperties::Depth' has a wrong offset!");
static_assert(offsetof(USculptBrushProperties, bHitBackFaces) == 0x0000C8, "Member 'USculptBrushProperties::bHitBackFaces' has a wrong offset!");
static_assert(offsetof(USculptBrushProperties, FlowRate) == 0x0000CC, "Member 'USculptBrushProperties::FlowRate' has a wrong offset!");
static_assert(offsetof(USculptBrushProperties, Spacing) == 0x0000D0, "Member 'USculptBrushProperties::Spacing' has a wrong offset!");
static_assert(offsetof(USculptBrushProperties, Lazyness) == 0x0000D4, "Member 'USculptBrushProperties::Lazyness' has a wrong offset!");
static_assert(offsetof(USculptBrushProperties, bShowPerBrushProps) == 0x0000D8, "Member 'USculptBrushProperties::bShowPerBrushProps' has a wrong offset!");
static_assert(offsetof(USculptBrushProperties, bShowLazyness) == 0x0000D9, "Member 'USculptBrushProperties::bShowLazyness' has a wrong offset!");
static_assert(offsetof(USculptBrushProperties, bShowFlowRate) == 0x0000DA, "Member 'USculptBrushProperties::bShowFlowRate' has a wrong offset!");
static_assert(offsetof(USculptBrushProperties, bShowSpacing) == 0x0000DB, "Member 'USculptBrushProperties::bShowSpacing' has a wrong offset!");

// Class MeshModelingToolsExp.KelvinBrushProperties
// 0x0010 (0x00B8 - 0x00A8)
class UKelvinBrushProperties final : public UInteractiveToolPropertySet
{
public:
	float                                         FalloffDistance;                                   // 0x00A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Stiffness;                                         // 0x00AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Incompressiblity;                                  // 0x00B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BrushSteps;                                        // 0x00B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KelvinBrushProperties">();
	}
	static class UKelvinBrushProperties* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKelvinBrushProperties>();
	}
};
static_assert(alignof(UKelvinBrushProperties) == 0x000008, "Wrong alignment on UKelvinBrushProperties");
static_assert(sizeof(UKelvinBrushProperties) == 0x0000B8, "Wrong size on UKelvinBrushProperties");
static_assert(offsetof(UKelvinBrushProperties, FalloffDistance) == 0x0000A8, "Member 'UKelvinBrushProperties::FalloffDistance' has a wrong offset!");
static_assert(offsetof(UKelvinBrushProperties, Stiffness) == 0x0000AC, "Member 'UKelvinBrushProperties::Stiffness' has a wrong offset!");
static_assert(offsetof(UKelvinBrushProperties, Incompressiblity) == 0x0000B0, "Member 'UKelvinBrushProperties::Incompressiblity' has a wrong offset!");
static_assert(offsetof(UKelvinBrushProperties, BrushSteps) == 0x0000B4, "Member 'UKelvinBrushProperties::BrushSteps' has a wrong offset!");

// Class MeshModelingToolsExp.WorkPlaneProperties
// 0x0048 (0x00F0 - 0x00A8)
class UWorkPlaneProperties final : public UInteractiveToolPropertySet
{
public:
	bool                                          bPropertySetEnabled;                               // 0x00A8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowGizmo;                                        // 0x00A9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AA[0x6];                                       // 0x00AA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Position;                                          // 0x00B0(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C8[0x8];                                       // 0x00C8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FQuat                                  Rotation;                                          // 0x00D0(0x0020)(Edit, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WorkPlaneProperties">();
	}
	static class UWorkPlaneProperties* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWorkPlaneProperties>();
	}
};
static_assert(alignof(UWorkPlaneProperties) == 0x000010, "Wrong alignment on UWorkPlaneProperties");
static_assert(sizeof(UWorkPlaneProperties) == 0x0000F0, "Wrong size on UWorkPlaneProperties");
static_assert(offsetof(UWorkPlaneProperties, bPropertySetEnabled) == 0x0000A8, "Member 'UWorkPlaneProperties::bPropertySetEnabled' has a wrong offset!");
static_assert(offsetof(UWorkPlaneProperties, bShowGizmo) == 0x0000A9, "Member 'UWorkPlaneProperties::bShowGizmo' has a wrong offset!");
static_assert(offsetof(UWorkPlaneProperties, Position) == 0x0000B0, "Member 'UWorkPlaneProperties::Position' has a wrong offset!");
static_assert(offsetof(UWorkPlaneProperties, Rotation) == 0x0000D0, "Member 'UWorkPlaneProperties::Rotation' has a wrong offset!");

// Class MeshModelingToolsExp.SculptMaxBrushProperties
// 0x0008 (0x00B0 - 0x00A8)
class USculptMaxBrushProperties final : public UInteractiveToolPropertySet
{
public:
	float                                         MaxHeight;                                         // 0x00A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFreezeCurrentHeight;                              // 0x00AC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AD[0x3];                                       // 0x00AD(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SculptMaxBrushProperties">();
	}
	static class USculptMaxBrushProperties* GetDefaultObj()
	{
		return GetDefaultObjImpl<USculptMaxBrushProperties>();
	}
};
static_assert(alignof(USculptMaxBrushProperties) == 0x000008, "Wrong alignment on USculptMaxBrushProperties");
static_assert(sizeof(USculptMaxBrushProperties) == 0x0000B0, "Wrong size on USculptMaxBrushProperties");
static_assert(offsetof(USculptMaxBrushProperties, MaxHeight) == 0x0000A8, "Member 'USculptMaxBrushProperties::MaxHeight' has a wrong offset!");
static_assert(offsetof(USculptMaxBrushProperties, bFreezeCurrentHeight) == 0x0000AC, "Member 'USculptMaxBrushProperties::bFreezeCurrentHeight' has a wrong offset!");

// Class MeshModelingToolsExp.SeamSculptToolBuilder
// 0x0000 (0x0030 - 0x0030)
class USeamSculptToolBuilder final : public UMeshSurfacePointMeshEditingToolBuilder
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SeamSculptToolBuilder">();
	}
	static class USeamSculptToolBuilder* GetDefaultObj()
	{
		return GetDefaultObjImpl<USeamSculptToolBuilder>();
	}
};
static_assert(alignof(USeamSculptToolBuilder) == 0x000008, "Wrong alignment on USeamSculptToolBuilder");
static_assert(sizeof(USeamSculptToolBuilder) == 0x000030, "Wrong size on USeamSculptToolBuilder");

// Class MeshModelingToolsExp.SeamSculptToolProperties
// 0x0008 (0x00B0 - 0x00A8)
class USeamSculptToolProperties final : public UInteractiveToolPropertySet
{
public:
	bool                                          bShowWireframe;                                    // 0x00A8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHitBackFaces;                                     // 0x00A9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AA[0x6];                                       // 0x00AA(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SeamSculptToolProperties">();
	}
	static class USeamSculptToolProperties* GetDefaultObj()
	{
		return GetDefaultObjImpl<USeamSculptToolProperties>();
	}
};
static_assert(alignof(USeamSculptToolProperties) == 0x000008, "Wrong alignment on USeamSculptToolProperties");
static_assert(sizeof(USeamSculptToolProperties) == 0x0000B0, "Wrong size on USeamSculptToolProperties");
static_assert(offsetof(USeamSculptToolProperties, bShowWireframe) == 0x0000A8, "Member 'USeamSculptToolProperties::bShowWireframe' has a wrong offset!");
static_assert(offsetof(USeamSculptToolProperties, bHitBackFaces) == 0x0000A9, "Member 'USeamSculptToolProperties::bHitBackFaces' has a wrong offset!");

// Class MeshModelingToolsExp.SeamSculptTool
// 0x0100 (0x03E0 - 0x02E0)
class alignas(0x10) USeamSculptTool final : public UDynamicMeshBrushTool
{
public:
	uint8                                         Pad_2E0[0x8];                                      // 0x02E0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USeamSculptToolProperties*              Settings;                                          // 0x02E8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPreviewGeometry*                       PreviewGeom;                                       // 0x02F0(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F8[0xE8];                                     // 0x02F8(0x00E8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SeamSculptTool">();
	}
	static class USeamSculptTool* GetDefaultObj()
	{
		return GetDefaultObjImpl<USeamSculptTool>();
	}
};
static_assert(alignof(USeamSculptTool) == 0x000010, "Wrong alignment on USeamSculptTool");
static_assert(sizeof(USeamSculptTool) == 0x0003E0, "Wrong size on USeamSculptTool");
static_assert(offsetof(USeamSculptTool, Settings) == 0x0002E8, "Member 'USeamSculptTool::Settings' has a wrong offset!");
static_assert(offsetof(USeamSculptTool, PreviewGeom) == 0x0002F0, "Member 'USeamSculptTool::PreviewGeom' has a wrong offset!");

// Class MeshModelingToolsExp.SelfUnionMeshesToolProperties
// 0x0010 (0x00B8 - 0x00A8)
class USelfUnionMeshesToolProperties final : public UInteractiveToolPropertySet
{
public:
	bool                                          bTrimFlaps;                                        // 0x00A8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTryFixHoles;                                      // 0x00A9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTryCollapseEdges;                                 // 0x00AA(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AB[0x1];                                       // 0x00AB(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WindingThreshold;                                  // 0x00AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowNewBoundaryEdges;                             // 0x00B0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOnlyUseFirstMeshMaterials;                        // 0x00B1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B2[0x6];                                       // 0x00B2(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SelfUnionMeshesToolProperties">();
	}
	static class USelfUnionMeshesToolProperties* GetDefaultObj()
	{
		return GetDefaultObjImpl<USelfUnionMeshesToolProperties>();
	}
};
static_assert(alignof(USelfUnionMeshesToolProperties) == 0x000008, "Wrong alignment on USelfUnionMeshesToolProperties");
static_assert(sizeof(USelfUnionMeshesToolProperties) == 0x0000B8, "Wrong size on USelfUnionMeshesToolProperties");
static_assert(offsetof(USelfUnionMeshesToolProperties, bTrimFlaps) == 0x0000A8, "Member 'USelfUnionMeshesToolProperties::bTrimFlaps' has a wrong offset!");
static_assert(offsetof(USelfUnionMeshesToolProperties, bTryFixHoles) == 0x0000A9, "Member 'USelfUnionMeshesToolProperties::bTryFixHoles' has a wrong offset!");
static_assert(offsetof(USelfUnionMeshesToolProperties, bTryCollapseEdges) == 0x0000AA, "Member 'USelfUnionMeshesToolProperties::bTryCollapseEdges' has a wrong offset!");
static_assert(offsetof(USelfUnionMeshesToolProperties, WindingThreshold) == 0x0000AC, "Member 'USelfUnionMeshesToolProperties::WindingThreshold' has a wrong offset!");
static_assert(offsetof(USelfUnionMeshesToolProperties, bShowNewBoundaryEdges) == 0x0000B0, "Member 'USelfUnionMeshesToolProperties::bShowNewBoundaryEdges' has a wrong offset!");
static_assert(offsetof(USelfUnionMeshesToolProperties, bOnlyUseFirstMeshMaterials) == 0x0000B1, "Member 'USelfUnionMeshesToolProperties::bOnlyUseFirstMeshMaterials' has a wrong offset!");

// Class MeshModelingToolsExp.SelfUnionMeshesTool
// 0x0048 (0x0150 - 0x0108)
class USelfUnionMeshesTool final : public UBaseCreateFromSelectedTool
{
public:
	class USelfUnionMeshesToolProperties*         Properties;                                        // 0x0108(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ULineSetComponent*                      DrawnLineSet;                                      // 0x0110(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_118[0x38];                                     // 0x0118(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SelfUnionMeshesTool">();
	}
	static class USelfUnionMeshesTool* GetDefaultObj()
	{
		return GetDefaultObjImpl<USelfUnionMeshesTool>();
	}
};
static_assert(alignof(USelfUnionMeshesTool) == 0x000008, "Wrong alignment on USelfUnionMeshesTool");
static_assert(sizeof(USelfUnionMeshesTool) == 0x000150, "Wrong size on USelfUnionMeshesTool");
static_assert(offsetof(USelfUnionMeshesTool, Properties) == 0x000108, "Member 'USelfUnionMeshesTool::Properties' has a wrong offset!");
static_assert(offsetof(USelfUnionMeshesTool, DrawnLineSet) == 0x000110, "Member 'USelfUnionMeshesTool::DrawnLineSet' has a wrong offset!");

// Class MeshModelingToolsExp.SelfUnionMeshesToolBuilder
// 0x0000 (0x0028 - 0x0028)
class USelfUnionMeshesToolBuilder final : public UBaseCreateFromSelectedToolBuilder
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SelfUnionMeshesToolBuilder">();
	}
	static class USelfUnionMeshesToolBuilder* GetDefaultObj()
	{
		return GetDefaultObjImpl<USelfUnionMeshesToolBuilder>();
	}
};
static_assert(alignof(USelfUnionMeshesToolBuilder) == 0x000008, "Wrong alignment on USelfUnionMeshesToolBuilder");
static_assert(sizeof(USelfUnionMeshesToolBuilder) == 0x000028, "Wrong size on USelfUnionMeshesToolBuilder");

// Class MeshModelingToolsExp.SmoothMeshToolProperties
// 0x0008 (0x00B0 - 0x00A8)
class USmoothMeshToolProperties final : public UInteractiveToolPropertySet
{
public:
	ESmoothMeshToolSmoothType                     SmoothingType;                                     // 0x00A8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A9[0x7];                                       // 0x00A9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SmoothMeshToolProperties">();
	}
	static class USmoothMeshToolProperties* GetDefaultObj()
	{
		return GetDefaultObjImpl<USmoothMeshToolProperties>();
	}
};
static_assert(alignof(USmoothMeshToolProperties) == 0x000008, "Wrong alignment on USmoothMeshToolProperties");
static_assert(sizeof(USmoothMeshToolProperties) == 0x0000B0, "Wrong size on USmoothMeshToolProperties");
static_assert(offsetof(USmoothMeshToolProperties, SmoothingType) == 0x0000A8, "Member 'USmoothMeshToolProperties::SmoothingType' has a wrong offset!");

// Class MeshModelingToolsExp.IterativeSmoothProperties
// 0x0010 (0x00B8 - 0x00A8)
class UIterativeSmoothProperties final : public UInteractiveToolPropertySet
{
public:
	float                                         SmoothingPerStep;                                  // 0x00A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Steps;                                             // 0x00AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSmoothBoundary;                                   // 0x00B0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B1[0x7];                                       // 0x00B1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IterativeSmoothProperties">();
	}
	static class UIterativeSmoothProperties* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIterativeSmoothProperties>();
	}
};
static_assert(alignof(UIterativeSmoothProperties) == 0x000008, "Wrong alignment on UIterativeSmoothProperties");
static_assert(sizeof(UIterativeSmoothProperties) == 0x0000B8, "Wrong size on UIterativeSmoothProperties");
static_assert(offsetof(UIterativeSmoothProperties, SmoothingPerStep) == 0x0000A8, "Member 'UIterativeSmoothProperties::SmoothingPerStep' has a wrong offset!");
static_assert(offsetof(UIterativeSmoothProperties, Steps) == 0x0000AC, "Member 'UIterativeSmoothProperties::Steps' has a wrong offset!");
static_assert(offsetof(UIterativeSmoothProperties, bSmoothBoundary) == 0x0000B0, "Member 'UIterativeSmoothProperties::bSmoothBoundary' has a wrong offset!");

// Class MeshModelingToolsExp.DiffusionSmoothProperties
// 0x0010 (0x00B8 - 0x00A8)
class UDiffusionSmoothProperties final : public UInteractiveToolPropertySet
{
public:
	float                                         SmoothingPerStep;                                  // 0x00A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Steps;                                             // 0x00AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPreserveUVs;                                      // 0x00B0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B1[0x7];                                       // 0x00B1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DiffusionSmoothProperties">();
	}
	static class UDiffusionSmoothProperties* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDiffusionSmoothProperties>();
	}
};
static_assert(alignof(UDiffusionSmoothProperties) == 0x000008, "Wrong alignment on UDiffusionSmoothProperties");
static_assert(sizeof(UDiffusionSmoothProperties) == 0x0000B8, "Wrong size on UDiffusionSmoothProperties");
static_assert(offsetof(UDiffusionSmoothProperties, SmoothingPerStep) == 0x0000A8, "Member 'UDiffusionSmoothProperties::SmoothingPerStep' has a wrong offset!");
static_assert(offsetof(UDiffusionSmoothProperties, Steps) == 0x0000AC, "Member 'UDiffusionSmoothProperties::Steps' has a wrong offset!");
static_assert(offsetof(UDiffusionSmoothProperties, bPreserveUVs) == 0x0000B0, "Member 'UDiffusionSmoothProperties::bPreserveUVs' has a wrong offset!");

// Class MeshModelingToolsExp.ImplicitSmoothProperties
// 0x0010 (0x00B8 - 0x00A8)
class UImplicitSmoothProperties final : public UInteractiveToolPropertySet
{
public:
	float                                         SmoothSpeed;                                       // 0x00A8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Smoothness;                                        // 0x00AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPreserveUVs;                                      // 0x00B0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B1[0x3];                                       // 0x00B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         VolumeCorrection;                                  // 0x00B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ImplicitSmoothProperties">();
	}
	static class UImplicitSmoothProperties* GetDefaultObj()
	{
		return GetDefaultObjImpl<UImplicitSmoothProperties>();
	}
};
static_assert(alignof(UImplicitSmoothProperties) == 0x000008, "Wrong alignment on UImplicitSmoothProperties");
static_assert(sizeof(UImplicitSmoothProperties) == 0x0000B8, "Wrong size on UImplicitSmoothProperties");
static_assert(offsetof(UImplicitSmoothProperties, SmoothSpeed) == 0x0000A8, "Member 'UImplicitSmoothProperties::SmoothSpeed' has a wrong offset!");
static_assert(offsetof(UImplicitSmoothProperties, Smoothness) == 0x0000AC, "Member 'UImplicitSmoothProperties::Smoothness' has a wrong offset!");
static_assert(offsetof(UImplicitSmoothProperties, bPreserveUVs) == 0x0000B0, "Member 'UImplicitSmoothProperties::bPreserveUVs' has a wrong offset!");
static_assert(offsetof(UImplicitSmoothProperties, VolumeCorrection) == 0x0000B4, "Member 'UImplicitSmoothProperties::VolumeCorrection' has a wrong offset!");

// Class MeshModelingToolsExp.SmoothWeightMapSetProperties
// 0x0008 (0x00D0 - 0x00C8)
class USmoothWeightMapSetProperties final : public UWeightMapSetProperties
{
public:
	float                                         MinSmoothMultiplier;                               // 0x00C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CC[0x4];                                       // 0x00CC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SmoothWeightMapSetProperties">();
	}
	static class USmoothWeightMapSetProperties* GetDefaultObj()
	{
		return GetDefaultObjImpl<USmoothWeightMapSetProperties>();
	}
};
static_assert(alignof(USmoothWeightMapSetProperties) == 0x000008, "Wrong alignment on USmoothWeightMapSetProperties");
static_assert(sizeof(USmoothWeightMapSetProperties) == 0x0000D0, "Wrong size on USmoothWeightMapSetProperties");
static_assert(offsetof(USmoothWeightMapSetProperties, MinSmoothMultiplier) == 0x0000C8, "Member 'USmoothWeightMapSetProperties::MinSmoothMultiplier' has a wrong offset!");

// Class MeshModelingToolsExp.SmoothMeshTool
// 0x0030 (0x0430 - 0x0400)
class USmoothMeshTool final : public UBaseMeshProcessingTool
{
public:
	uint8                                         Pad_400[0x8];                                      // 0x0400(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USmoothMeshToolProperties*              SmoothProperties;                                  // 0x0408(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UIterativeSmoothProperties*             IterativeProperties;                               // 0x0410(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDiffusionSmoothProperties*             DiffusionProperties;                               // 0x0418(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImplicitSmoothProperties*              ImplicitProperties;                                // 0x0420(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USmoothWeightMapSetProperties*          WeightMapProperties;                               // 0x0428(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SmoothMeshTool">();
	}
	static class USmoothMeshTool* GetDefaultObj()
	{
		return GetDefaultObjImpl<USmoothMeshTool>();
	}
};
static_assert(alignof(USmoothMeshTool) == 0x000010, "Wrong alignment on USmoothMeshTool");
static_assert(sizeof(USmoothMeshTool) == 0x000430, "Wrong size on USmoothMeshTool");
static_assert(offsetof(USmoothMeshTool, SmoothProperties) == 0x000408, "Member 'USmoothMeshTool::SmoothProperties' has a wrong offset!");
static_assert(offsetof(USmoothMeshTool, IterativeProperties) == 0x000410, "Member 'USmoothMeshTool::IterativeProperties' has a wrong offset!");
static_assert(offsetof(USmoothMeshTool, DiffusionProperties) == 0x000418, "Member 'USmoothMeshTool::DiffusionProperties' has a wrong offset!");
static_assert(offsetof(USmoothMeshTool, ImplicitProperties) == 0x000420, "Member 'USmoothMeshTool::ImplicitProperties' has a wrong offset!");
static_assert(offsetof(USmoothMeshTool, WeightMapProperties) == 0x000428, "Member 'USmoothMeshTool::WeightMapProperties' has a wrong offset!");

// Class MeshModelingToolsExp.SmoothMeshToolBuilder
// 0x0000 (0x0028 - 0x0028)
class USmoothMeshToolBuilder final : public UBaseMeshProcessingToolBuilder
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SmoothMeshToolBuilder">();
	}
	static class USmoothMeshToolBuilder* GetDefaultObj()
	{
		return GetDefaultObjImpl<USmoothMeshToolBuilder>();
	}
};
static_assert(alignof(USmoothMeshToolBuilder) == 0x000008, "Wrong alignment on USmoothMeshToolBuilder");
static_assert(sizeof(USmoothMeshToolBuilder) == 0x000028, "Wrong size on USmoothMeshToolBuilder");

// Class MeshModelingToolsExp.SplitMeshesToolBuilder
// 0x0000 (0x0028 - 0x0028)
class USplitMeshesToolBuilder final : public UMultiSelectionMeshEditingToolBuilder
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SplitMeshesToolBuilder">();
	}
	static class USplitMeshesToolBuilder* GetDefaultObj()
	{
		return GetDefaultObjImpl<USplitMeshesToolBuilder>();
	}
};
static_assert(alignof(USplitMeshesToolBuilder) == 0x000008, "Wrong alignment on USplitMeshesToolBuilder");
static_assert(sizeof(USplitMeshesToolBuilder) == 0x000028, "Wrong size on USplitMeshesToolBuilder");

// Class MeshModelingToolsExp.SplitMeshesToolProperties
// 0x0008 (0x00B0 - 0x00A8)
class USplitMeshesToolProperties final : public UInteractiveToolPropertySet
{
public:
	bool                                          bTransferMaterials;                                // 0x00A8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A9[0x7];                                       // 0x00A9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SplitMeshesToolProperties">();
	}
	static class USplitMeshesToolProperties* GetDefaultObj()
	{
		return GetDefaultObjImpl<USplitMeshesToolProperties>();
	}
};
static_assert(alignof(USplitMeshesToolProperties) == 0x000008, "Wrong alignment on USplitMeshesToolProperties");
static_assert(sizeof(USplitMeshesToolProperties) == 0x0000B0, "Wrong size on USplitMeshesToolProperties");
static_assert(offsetof(USplitMeshesToolProperties, bTransferMaterials) == 0x0000A8, "Member 'USplitMeshesToolProperties::bTransferMaterials' has a wrong offset!");

// Class MeshModelingToolsExp.SplitMeshesTool
// 0x0038 (0x00F0 - 0x00B8)
class USplitMeshesTool final : public UMultiSelectionMeshEditingTool
{
public:
	class USplitMeshesToolProperties*             BasicProperties;                                   // 0x00B8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCreateMeshObjectTypeProperties*        OutputTypeProperties;                              // 0x00C0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C8[0x28];                                      // 0x00C8(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SplitMeshesTool">();
	}
	static class USplitMeshesTool* GetDefaultObj()
	{
		return GetDefaultObjImpl<USplitMeshesTool>();
	}
};
static_assert(alignof(USplitMeshesTool) == 0x000008, "Wrong alignment on USplitMeshesTool");
static_assert(sizeof(USplitMeshesTool) == 0x0000F0, "Wrong size on USplitMeshesTool");
static_assert(offsetof(USplitMeshesTool, BasicProperties) == 0x0000B8, "Member 'USplitMeshesTool::BasicProperties' has a wrong offset!");
static_assert(offsetof(USplitMeshesTool, OutputTypeProperties) == 0x0000C0, "Member 'USplitMeshesTool::OutputTypeProperties' has a wrong offset!");

// Class MeshModelingToolsExp.TransferMeshToolBuilder
// 0x0000 (0x0028 - 0x0028)
class UTransferMeshToolBuilder final : public UMultiSelectionMeshEditingToolBuilder
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TransferMeshToolBuilder">();
	}
	static class UTransferMeshToolBuilder* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTransferMeshToolBuilder>();
	}
};
static_assert(alignof(UTransferMeshToolBuilder) == 0x000008, "Wrong alignment on UTransferMeshToolBuilder");
static_assert(sizeof(UTransferMeshToolBuilder) == 0x000028, "Wrong size on UTransferMeshToolBuilder");

// Class MeshModelingToolsExp.TransferMeshToolProperties
// 0x0078 (0x0120 - 0x00A8)
class UTransferMeshToolProperties final : public UInteractiveToolPropertySet
{
public:
	bool                                          bTransferMaterials;                                // 0x00A8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTransferCollision;                                // 0x00A9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AA[0x6];                                       // 0x00AA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 SourceLOD;                                         // 0x00B0(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 TargetLod;                                         // 0x00C0(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsStaticMeshSource;                               // 0x00D0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D1[0x7];                                       // 0x00D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         SourceLODNamesList;                                // 0x00D8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_E8[0x10];                                      // 0x00E8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         TargetLODNamesList;                                // 0x00F8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_108[0x10];                                     // 0x0108(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsStaticMeshTarget;                               // 0x0118(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_119[0x7];                                      // 0x0119(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	const TArray<class FString> GetSourceLODNamesFunc() const;
	const TArray<class FString> GetTargetLODNamesFunc() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TransferMeshToolProperties">();
	}
	static class UTransferMeshToolProperties* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTransferMeshToolProperties>();
	}
};
static_assert(alignof(UTransferMeshToolProperties) == 0x000008, "Wrong alignment on UTransferMeshToolProperties");
static_assert(sizeof(UTransferMeshToolProperties) == 0x000120, "Wrong size on UTransferMeshToolProperties");
static_assert(offsetof(UTransferMeshToolProperties, bTransferMaterials) == 0x0000A8, "Member 'UTransferMeshToolProperties::bTransferMaterials' has a wrong offset!");
static_assert(offsetof(UTransferMeshToolProperties, bTransferCollision) == 0x0000A9, "Member 'UTransferMeshToolProperties::bTransferCollision' has a wrong offset!");
static_assert(offsetof(UTransferMeshToolProperties, SourceLOD) == 0x0000B0, "Member 'UTransferMeshToolProperties::SourceLOD' has a wrong offset!");
static_assert(offsetof(UTransferMeshToolProperties, TargetLod) == 0x0000C0, "Member 'UTransferMeshToolProperties::TargetLod' has a wrong offset!");
static_assert(offsetof(UTransferMeshToolProperties, bIsStaticMeshSource) == 0x0000D0, "Member 'UTransferMeshToolProperties::bIsStaticMeshSource' has a wrong offset!");
static_assert(offsetof(UTransferMeshToolProperties, SourceLODNamesList) == 0x0000D8, "Member 'UTransferMeshToolProperties::SourceLODNamesList' has a wrong offset!");
static_assert(offsetof(UTransferMeshToolProperties, TargetLODNamesList) == 0x0000F8, "Member 'UTransferMeshToolProperties::TargetLODNamesList' has a wrong offset!");
static_assert(offsetof(UTransferMeshToolProperties, bIsStaticMeshTarget) == 0x000118, "Member 'UTransferMeshToolProperties::bIsStaticMeshTarget' has a wrong offset!");

// Class MeshModelingToolsExp.TransferMeshTool
// 0x0010 (0x00C8 - 0x00B8)
class UTransferMeshTool final : public UMultiSelectionMeshEditingTool
{
public:
	uint8                                         Pad_B8[0x8];                                       // 0x00B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UTransferMeshToolProperties*            BasicProperties;                                   // 0x00C0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TransferMeshTool">();
	}
	static class UTransferMeshTool* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTransferMeshTool>();
	}
};
static_assert(alignof(UTransferMeshTool) == 0x000008, "Wrong alignment on UTransferMeshTool");
static_assert(sizeof(UTransferMeshTool) == 0x0000C8, "Wrong size on UTransferMeshTool");
static_assert(offsetof(UTransferMeshTool, BasicProperties) == 0x0000C0, "Member 'UTransferMeshTool::BasicProperties' has a wrong offset!");

// Class MeshModelingToolsExp.TransformMeshesToolBuilder
// 0x0000 (0x0028 - 0x0028)
class UTransformMeshesToolBuilder final : public UMultiSelectionMeshEditingToolBuilder
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TransformMeshesToolBuilder">();
	}
	static class UTransformMeshesToolBuilder* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTransformMeshesToolBuilder>();
	}
};
static_assert(alignof(UTransformMeshesToolBuilder) == 0x000008, "Wrong alignment on UTransformMeshesToolBuilder");
static_assert(sizeof(UTransformMeshesToolBuilder) == 0x000028, "Wrong size on UTransformMeshesToolBuilder");

// Class MeshModelingToolsExp.TransformMeshesToolProperties
// 0x0008 (0x00B0 - 0x00A8)
class UTransformMeshesToolProperties final : public UInteractiveToolPropertySet
{
public:
	ETransformMeshesTransformMode                 TransformMode;                                     // 0x00A8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bApplyToInstances;                                 // 0x00A9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSetPivotMode;                                     // 0x00AA(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableSnapDragging;                               // 0x00AB(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETransformMeshesSnapDragSource                SnapDragSource;                                    // 0x00AC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETransformMeshesSnapDragRotationMode          RotationMode;                                      // 0x00AD(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHaveInstances;                                    // 0x00AE(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AF[0x1];                                       // 0x00AF(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TransformMeshesToolProperties">();
	}
	static class UTransformMeshesToolProperties* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTransformMeshesToolProperties>();
	}
};
static_assert(alignof(UTransformMeshesToolProperties) == 0x000008, "Wrong alignment on UTransformMeshesToolProperties");
static_assert(sizeof(UTransformMeshesToolProperties) == 0x0000B0, "Wrong size on UTransformMeshesToolProperties");
static_assert(offsetof(UTransformMeshesToolProperties, TransformMode) == 0x0000A8, "Member 'UTransformMeshesToolProperties::TransformMode' has a wrong offset!");
static_assert(offsetof(UTransformMeshesToolProperties, bApplyToInstances) == 0x0000A9, "Member 'UTransformMeshesToolProperties::bApplyToInstances' has a wrong offset!");
static_assert(offsetof(UTransformMeshesToolProperties, bSetPivotMode) == 0x0000AA, "Member 'UTransformMeshesToolProperties::bSetPivotMode' has a wrong offset!");
static_assert(offsetof(UTransformMeshesToolProperties, bEnableSnapDragging) == 0x0000AB, "Member 'UTransformMeshesToolProperties::bEnableSnapDragging' has a wrong offset!");
static_assert(offsetof(UTransformMeshesToolProperties, SnapDragSource) == 0x0000AC, "Member 'UTransformMeshesToolProperties::SnapDragSource' has a wrong offset!");
static_assert(offsetof(UTransformMeshesToolProperties, RotationMode) == 0x0000AD, "Member 'UTransformMeshesToolProperties::RotationMode' has a wrong offset!");
static_assert(offsetof(UTransformMeshesToolProperties, bHaveInstances) == 0x0000AE, "Member 'UTransformMeshesToolProperties::bHaveInstances' has a wrong offset!");

// Class MeshModelingToolsExp.TransformMeshesTool
// 0x00E8 (0x01A0 - 0x00B8)
class alignas(0x10) UTransformMeshesTool final : public UMultiSelectionMeshEditingTool
{
public:
	uint8                                         Pad_B8[0x10];                                      // 0x00B8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UTransformMeshesToolProperties*         TransformProps;                                    // 0x00C8(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FTransformMeshesTarget>         ActiveGizmos;                                      // 0x00D0(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class UDragAlignmentMechanic*                 DragAlignmentMechanic;                             // 0x00E0(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E8[0xB8];                                      // 0x00E8(0x00B8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TransformMeshesTool">();
	}
	static class UTransformMeshesTool* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTransformMeshesTool>();
	}
};
static_assert(alignof(UTransformMeshesTool) == 0x000010, "Wrong alignment on UTransformMeshesTool");
static_assert(sizeof(UTransformMeshesTool) == 0x0001A0, "Wrong size on UTransformMeshesTool");
static_assert(offsetof(UTransformMeshesTool, TransformProps) == 0x0000C8, "Member 'UTransformMeshesTool::TransformProps' has a wrong offset!");
static_assert(offsetof(UTransformMeshesTool, ActiveGizmos) == 0x0000D0, "Member 'UTransformMeshesTool::ActiveGizmos' has a wrong offset!");
static_assert(offsetof(UTransformMeshesTool, DragAlignmentMechanic) == 0x0000E0, "Member 'UTransformMeshesTool::DragAlignmentMechanic' has a wrong offset!");

// Class MeshModelingToolsExp.TriangulateSplinesToolProperties
// 0x0038 (0x00E0 - 0x00A8)
class UTriangulateSplinesToolProperties final : public UInteractiveToolPropertySet
{
public:
	double                                        ErrorTolerance;                                    // 0x00A8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFlattenCurveMethod                           FlattenMethod;                                     // 0x00B0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECombineCurvesMethod                          CombineMethod;                                     // 0x00B1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B2[0x6];                                       // 0x00B2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        Thickness;                                         // 0x00B8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFlipResult;                                       // 0x00C0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOffsetOpenCurvesMethod                       OpenCurves;                                        // 0x00C1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C2[0x6];                                       // 0x00C2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        CurveOffset;                                       // 0x00C8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOffsetClosedCurvesMethod                     OffsetClosedCurves;                                // 0x00D0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOpenCurveEndShapes                           EndShapes;                                         // 0x00D1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOffsetJoinMethod                             JoinMethod;                                        // 0x00D2(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D3[0x5];                                       // 0x00D3(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        MiterLimit;                                        // 0x00D8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TriangulateSplinesToolProperties">();
	}
	static class UTriangulateSplinesToolProperties* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTriangulateSplinesToolProperties>();
	}
};
static_assert(alignof(UTriangulateSplinesToolProperties) == 0x000008, "Wrong alignment on UTriangulateSplinesToolProperties");
static_assert(sizeof(UTriangulateSplinesToolProperties) == 0x0000E0, "Wrong size on UTriangulateSplinesToolProperties");
static_assert(offsetof(UTriangulateSplinesToolProperties, ErrorTolerance) == 0x0000A8, "Member 'UTriangulateSplinesToolProperties::ErrorTolerance' has a wrong offset!");
static_assert(offsetof(UTriangulateSplinesToolProperties, FlattenMethod) == 0x0000B0, "Member 'UTriangulateSplinesToolProperties::FlattenMethod' has a wrong offset!");
static_assert(offsetof(UTriangulateSplinesToolProperties, CombineMethod) == 0x0000B1, "Member 'UTriangulateSplinesToolProperties::CombineMethod' has a wrong offset!");
static_assert(offsetof(UTriangulateSplinesToolProperties, Thickness) == 0x0000B8, "Member 'UTriangulateSplinesToolProperties::Thickness' has a wrong offset!");
static_assert(offsetof(UTriangulateSplinesToolProperties, bFlipResult) == 0x0000C0, "Member 'UTriangulateSplinesToolProperties::bFlipResult' has a wrong offset!");
static_assert(offsetof(UTriangulateSplinesToolProperties, OpenCurves) == 0x0000C1, "Member 'UTriangulateSplinesToolProperties::OpenCurves' has a wrong offset!");
static_assert(offsetof(UTriangulateSplinesToolProperties, CurveOffset) == 0x0000C8, "Member 'UTriangulateSplinesToolProperties::CurveOffset' has a wrong offset!");
static_assert(offsetof(UTriangulateSplinesToolProperties, OffsetClosedCurves) == 0x0000D0, "Member 'UTriangulateSplinesToolProperties::OffsetClosedCurves' has a wrong offset!");
static_assert(offsetof(UTriangulateSplinesToolProperties, EndShapes) == 0x0000D1, "Member 'UTriangulateSplinesToolProperties::EndShapes' has a wrong offset!");
static_assert(offsetof(UTriangulateSplinesToolProperties, JoinMethod) == 0x0000D2, "Member 'UTriangulateSplinesToolProperties::JoinMethod' has a wrong offset!");
static_assert(offsetof(UTriangulateSplinesToolProperties, MiterLimit) == 0x0000D8, "Member 'UTriangulateSplinesToolProperties::MiterLimit' has a wrong offset!");

// Class MeshModelingToolsExp.TriangulateSplinesTool
// 0x0060 (0x00F8 - 0x0098)
class UTriangulateSplinesTool final : public UInteractiveTool
{
public:
	uint8                                         Pad_98[0x10];                                      // 0x0098(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UTriangulateSplinesToolProperties*      TriangulateProperties;                             // 0x00A8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCreateMeshObjectTypeProperties*        OutputTypeProperties;                              // 0x00B0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMeshOpPreviewWithBackgroundCompute*    Preview;                                           // 0x00B8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class UWorld>                  TargetWorld;                                       // 0x00C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<TWeakObjectPtr<class AActor>>          ActorsWithSplines;                                 // 0x00C8(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D8[0x20];                                      // 0x00D8(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TriangulateSplinesTool">();
	}
	static class UTriangulateSplinesTool* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTriangulateSplinesTool>();
	}
};
static_assert(alignof(UTriangulateSplinesTool) == 0x000008, "Wrong alignment on UTriangulateSplinesTool");
static_assert(sizeof(UTriangulateSplinesTool) == 0x0000F8, "Wrong size on UTriangulateSplinesTool");
static_assert(offsetof(UTriangulateSplinesTool, TriangulateProperties) == 0x0000A8, "Member 'UTriangulateSplinesTool::TriangulateProperties' has a wrong offset!");
static_assert(offsetof(UTriangulateSplinesTool, OutputTypeProperties) == 0x0000B0, "Member 'UTriangulateSplinesTool::OutputTypeProperties' has a wrong offset!");
static_assert(offsetof(UTriangulateSplinesTool, Preview) == 0x0000B8, "Member 'UTriangulateSplinesTool::Preview' has a wrong offset!");
static_assert(offsetof(UTriangulateSplinesTool, TargetWorld) == 0x0000C0, "Member 'UTriangulateSplinesTool::TargetWorld' has a wrong offset!");
static_assert(offsetof(UTriangulateSplinesTool, ActorsWithSplines) == 0x0000C8, "Member 'UTriangulateSplinesTool::ActorsWithSplines' has a wrong offset!");

// Class MeshModelingToolsExp.TriangulateSplinesToolBuilder
// 0x0000 (0x0028 - 0x0028)
class UTriangulateSplinesToolBuilder final : public UInteractiveToolBuilder
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TriangulateSplinesToolBuilder">();
	}
	static class UTriangulateSplinesToolBuilder* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTriangulateSplinesToolBuilder>();
	}
};
static_assert(alignof(UTriangulateSplinesToolBuilder) == 0x000008, "Wrong alignment on UTriangulateSplinesToolBuilder");
static_assert(sizeof(UTriangulateSplinesToolBuilder) == 0x000028, "Wrong size on UTriangulateSplinesToolBuilder");

// Class MeshModelingToolsExp.VolumeToMeshToolBuilder
// 0x0000 (0x0028 - 0x0028)
class UVolumeToMeshToolBuilder final : public UInteractiveToolBuilder
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VolumeToMeshToolBuilder">();
	}
	static class UVolumeToMeshToolBuilder* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVolumeToMeshToolBuilder>();
	}
};
static_assert(alignof(UVolumeToMeshToolBuilder) == 0x000008, "Wrong alignment on UVolumeToMeshToolBuilder");
static_assert(sizeof(UVolumeToMeshToolBuilder) == 0x000028, "Wrong size on UVolumeToMeshToolBuilder");

// Class MeshModelingToolsExp.VolumeToMeshToolProperties
// 0x0008 (0x00B0 - 0x00A8)
class UVolumeToMeshToolProperties final : public UInteractiveToolPropertySet
{
public:
	bool                                          bWeldEdges;                                        // 0x00A8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoRepair;                                       // 0x00A9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOptimizeMesh;                                     // 0x00AA(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowWireframe;                                    // 0x00AB(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AC[0x4];                                       // 0x00AC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VolumeToMeshToolProperties">();
	}
	static class UVolumeToMeshToolProperties* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVolumeToMeshToolProperties>();
	}
};
static_assert(alignof(UVolumeToMeshToolProperties) == 0x000008, "Wrong alignment on UVolumeToMeshToolProperties");
static_assert(sizeof(UVolumeToMeshToolProperties) == 0x0000B0, "Wrong size on UVolumeToMeshToolProperties");
static_assert(offsetof(UVolumeToMeshToolProperties, bWeldEdges) == 0x0000A8, "Member 'UVolumeToMeshToolProperties::bWeldEdges' has a wrong offset!");
static_assert(offsetof(UVolumeToMeshToolProperties, bAutoRepair) == 0x0000A9, "Member 'UVolumeToMeshToolProperties::bAutoRepair' has a wrong offset!");
static_assert(offsetof(UVolumeToMeshToolProperties, bOptimizeMesh) == 0x0000AA, "Member 'UVolumeToMeshToolProperties::bOptimizeMesh' has a wrong offset!");
static_assert(offsetof(UVolumeToMeshToolProperties, bShowWireframe) == 0x0000AB, "Member 'UVolumeToMeshToolProperties::bShowWireframe' has a wrong offset!");

// Class MeshModelingToolsExp.VolumeToMeshTool
// 0x0268 (0x0300 - 0x0098)
class UVolumeToMeshTool final : public UInteractiveTool
{
public:
	class UVolumeToMeshToolProperties*            Settings;                                          // 0x0098(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCreateMeshObjectTypeProperties*        OutputTypeProperties;                              // 0x00A0(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPreviewMesh*                           PreviewMesh;                                       // 0x00A8(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TLazyObjectPtr<class AVolume>                 TargetVolume;                                      // 0x00B0(0x0018)(IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ULineSetComponent*                      VolumeEdgesSet;                                    // 0x00C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D0[0x230];                                     // 0x00D0(0x0230)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VolumeToMeshTool">();
	}
	static class UVolumeToMeshTool* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVolumeToMeshTool>();
	}
};
static_assert(alignof(UVolumeToMeshTool) == 0x000008, "Wrong alignment on UVolumeToMeshTool");
static_assert(sizeof(UVolumeToMeshTool) == 0x000300, "Wrong size on UVolumeToMeshTool");
static_assert(offsetof(UVolumeToMeshTool, Settings) == 0x000098, "Member 'UVolumeToMeshTool::Settings' has a wrong offset!");
static_assert(offsetof(UVolumeToMeshTool, OutputTypeProperties) == 0x0000A0, "Member 'UVolumeToMeshTool::OutputTypeProperties' has a wrong offset!");
static_assert(offsetof(UVolumeToMeshTool, PreviewMesh) == 0x0000A8, "Member 'UVolumeToMeshTool::PreviewMesh' has a wrong offset!");
static_assert(offsetof(UVolumeToMeshTool, TargetVolume) == 0x0000B0, "Member 'UVolumeToMeshTool::TargetVolume' has a wrong offset!");
static_assert(offsetof(UVolumeToMeshTool, VolumeEdgesSet) == 0x0000C8, "Member 'UVolumeToMeshTool::VolumeEdgesSet' has a wrong offset!");

// Class MeshModelingToolsExp.VoxelBlendMeshesToolProperties
// 0x0020 (0x00C8 - 0x00A8)
class UVoxelBlendMeshesToolProperties final : public UInteractiveToolPropertySet
{
public:
	double                                        BlendPower;                                        // 0x00A8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        BlendFalloff;                                      // 0x00B0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVoxelBlendOperation                          Operation;                                         // 0x00B8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bVoxWrap;                                          // 0x00B9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRemoveInternalsAfterVoxWrap;                      // 0x00BA(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BB[0x5];                                       // 0x00BB(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        ThickenShells;                                     // 0x00C0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelBlendMeshesToolProperties">();
	}
	static class UVoxelBlendMeshesToolProperties* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelBlendMeshesToolProperties>();
	}
};
static_assert(alignof(UVoxelBlendMeshesToolProperties) == 0x000008, "Wrong alignment on UVoxelBlendMeshesToolProperties");
static_assert(sizeof(UVoxelBlendMeshesToolProperties) == 0x0000C8, "Wrong size on UVoxelBlendMeshesToolProperties");
static_assert(offsetof(UVoxelBlendMeshesToolProperties, BlendPower) == 0x0000A8, "Member 'UVoxelBlendMeshesToolProperties::BlendPower' has a wrong offset!");
static_assert(offsetof(UVoxelBlendMeshesToolProperties, BlendFalloff) == 0x0000B0, "Member 'UVoxelBlendMeshesToolProperties::BlendFalloff' has a wrong offset!");
static_assert(offsetof(UVoxelBlendMeshesToolProperties, Operation) == 0x0000B8, "Member 'UVoxelBlendMeshesToolProperties::Operation' has a wrong offset!");
static_assert(offsetof(UVoxelBlendMeshesToolProperties, bVoxWrap) == 0x0000B9, "Member 'UVoxelBlendMeshesToolProperties::bVoxWrap' has a wrong offset!");
static_assert(offsetof(UVoxelBlendMeshesToolProperties, bRemoveInternalsAfterVoxWrap) == 0x0000BA, "Member 'UVoxelBlendMeshesToolProperties::bRemoveInternalsAfterVoxWrap' has a wrong offset!");
static_assert(offsetof(UVoxelBlendMeshesToolProperties, ThickenShells) == 0x0000C0, "Member 'UVoxelBlendMeshesToolProperties::ThickenShells' has a wrong offset!");

// Class MeshModelingToolsExp.VoxelBlendMeshesTool
// 0x0008 (0x0128 - 0x0120)
class UVoxelBlendMeshesTool final : public UBaseVoxelTool
{
public:
	class UVoxelBlendMeshesToolProperties*        BlendProperties;                                   // 0x0120(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelBlendMeshesTool">();
	}
	static class UVoxelBlendMeshesTool* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelBlendMeshesTool>();
	}
};
static_assert(alignof(UVoxelBlendMeshesTool) == 0x000008, "Wrong alignment on UVoxelBlendMeshesTool");
static_assert(sizeof(UVoxelBlendMeshesTool) == 0x000128, "Wrong size on UVoxelBlendMeshesTool");
static_assert(offsetof(UVoxelBlendMeshesTool, BlendProperties) == 0x000120, "Member 'UVoxelBlendMeshesTool::BlendProperties' has a wrong offset!");

// Class MeshModelingToolsExp.VoxelBlendMeshesToolBuilder
// 0x0000 (0x0028 - 0x0028)
class UVoxelBlendMeshesToolBuilder final : public UBaseCreateFromSelectedToolBuilder
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelBlendMeshesToolBuilder">();
	}
	static class UVoxelBlendMeshesToolBuilder* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelBlendMeshesToolBuilder>();
	}
};
static_assert(alignof(UVoxelBlendMeshesToolBuilder) == 0x000008, "Wrong alignment on UVoxelBlendMeshesToolBuilder");
static_assert(sizeof(UVoxelBlendMeshesToolBuilder) == 0x000028, "Wrong size on UVoxelBlendMeshesToolBuilder");

// Class MeshModelingToolsExp.VoxelMorphologyMeshesToolProperties
// 0x0020 (0x00C8 - 0x00A8)
class UVoxelMorphologyMeshesToolProperties final : public UInteractiveToolPropertySet
{
public:
	EMorphologyOperation                          Operation;                                         // 0x00A8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A9[0x7];                                       // 0x00A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        Distance;                                          // 0x00B0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bVoxWrap;                                          // 0x00B8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRemoveInternalsAfterVoxWrap;                      // 0x00B9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BA[0x6];                                       // 0x00BA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        ThickenShells;                                     // 0x00C0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelMorphologyMeshesToolProperties">();
	}
	static class UVoxelMorphologyMeshesToolProperties* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelMorphologyMeshesToolProperties>();
	}
};
static_assert(alignof(UVoxelMorphologyMeshesToolProperties) == 0x000008, "Wrong alignment on UVoxelMorphologyMeshesToolProperties");
static_assert(sizeof(UVoxelMorphologyMeshesToolProperties) == 0x0000C8, "Wrong size on UVoxelMorphologyMeshesToolProperties");
static_assert(offsetof(UVoxelMorphologyMeshesToolProperties, Operation) == 0x0000A8, "Member 'UVoxelMorphologyMeshesToolProperties::Operation' has a wrong offset!");
static_assert(offsetof(UVoxelMorphologyMeshesToolProperties, Distance) == 0x0000B0, "Member 'UVoxelMorphologyMeshesToolProperties::Distance' has a wrong offset!");
static_assert(offsetof(UVoxelMorphologyMeshesToolProperties, bVoxWrap) == 0x0000B8, "Member 'UVoxelMorphologyMeshesToolProperties::bVoxWrap' has a wrong offset!");
static_assert(offsetof(UVoxelMorphologyMeshesToolProperties, bRemoveInternalsAfterVoxWrap) == 0x0000B9, "Member 'UVoxelMorphologyMeshesToolProperties::bRemoveInternalsAfterVoxWrap' has a wrong offset!");
static_assert(offsetof(UVoxelMorphologyMeshesToolProperties, ThickenShells) == 0x0000C0, "Member 'UVoxelMorphologyMeshesToolProperties::ThickenShells' has a wrong offset!");

// Class MeshModelingToolsExp.VoxelMorphologyMeshesTool
// 0x0008 (0x0128 - 0x0120)
class UVoxelMorphologyMeshesTool final : public UBaseVoxelTool
{
public:
	class UVoxelMorphologyMeshesToolProperties*   MorphologyProperties;                              // 0x0120(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelMorphologyMeshesTool">();
	}
	static class UVoxelMorphologyMeshesTool* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelMorphologyMeshesTool>();
	}
};
static_assert(alignof(UVoxelMorphologyMeshesTool) == 0x000008, "Wrong alignment on UVoxelMorphologyMeshesTool");
static_assert(sizeof(UVoxelMorphologyMeshesTool) == 0x000128, "Wrong size on UVoxelMorphologyMeshesTool");
static_assert(offsetof(UVoxelMorphologyMeshesTool, MorphologyProperties) == 0x000120, "Member 'UVoxelMorphologyMeshesTool::MorphologyProperties' has a wrong offset!");

// Class MeshModelingToolsExp.VoxelMorphologyMeshesToolBuilder
// 0x0000 (0x0028 - 0x0028)
class UVoxelMorphologyMeshesToolBuilder final : public UBaseCreateFromSelectedToolBuilder
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelMorphologyMeshesToolBuilder">();
	}
	static class UVoxelMorphologyMeshesToolBuilder* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelMorphologyMeshesToolBuilder>();
	}
};
static_assert(alignof(UVoxelMorphologyMeshesToolBuilder) == 0x000008, "Wrong alignment on UVoxelMorphologyMeshesToolBuilder");
static_assert(sizeof(UVoxelMorphologyMeshesToolBuilder) == 0x000028, "Wrong size on UVoxelMorphologyMeshesToolBuilder");

// Class MeshModelingToolsExp.VoxelSolidifyMeshesToolProperties
// 0x0020 (0x00C8 - 0x00A8)
class UVoxelSolidifyMeshesToolProperties final : public UInteractiveToolPropertySet
{
public:
	double                                        WindingThreshold;                                  // 0x00A8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        ExtendBounds;                                      // 0x00B0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SurfaceSearchSteps;                                // 0x00B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSolidAtBoundaries;                                // 0x00BC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bApplyThickenShells;                               // 0x00BD(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BE[0x2];                                       // 0x00BE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        ThickenShells;                                     // 0x00C0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelSolidifyMeshesToolProperties">();
	}
	static class UVoxelSolidifyMeshesToolProperties* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelSolidifyMeshesToolProperties>();
	}
};
static_assert(alignof(UVoxelSolidifyMeshesToolProperties) == 0x000008, "Wrong alignment on UVoxelSolidifyMeshesToolProperties");
static_assert(sizeof(UVoxelSolidifyMeshesToolProperties) == 0x0000C8, "Wrong size on UVoxelSolidifyMeshesToolProperties");
static_assert(offsetof(UVoxelSolidifyMeshesToolProperties, WindingThreshold) == 0x0000A8, "Member 'UVoxelSolidifyMeshesToolProperties::WindingThreshold' has a wrong offset!");
static_assert(offsetof(UVoxelSolidifyMeshesToolProperties, ExtendBounds) == 0x0000B0, "Member 'UVoxelSolidifyMeshesToolProperties::ExtendBounds' has a wrong offset!");
static_assert(offsetof(UVoxelSolidifyMeshesToolProperties, SurfaceSearchSteps) == 0x0000B8, "Member 'UVoxelSolidifyMeshesToolProperties::SurfaceSearchSteps' has a wrong offset!");
static_assert(offsetof(UVoxelSolidifyMeshesToolProperties, bSolidAtBoundaries) == 0x0000BC, "Member 'UVoxelSolidifyMeshesToolProperties::bSolidAtBoundaries' has a wrong offset!");
static_assert(offsetof(UVoxelSolidifyMeshesToolProperties, bApplyThickenShells) == 0x0000BD, "Member 'UVoxelSolidifyMeshesToolProperties::bApplyThickenShells' has a wrong offset!");
static_assert(offsetof(UVoxelSolidifyMeshesToolProperties, ThickenShells) == 0x0000C0, "Member 'UVoxelSolidifyMeshesToolProperties::ThickenShells' has a wrong offset!");

// Class MeshModelingToolsExp.VoxelSolidifyMeshesTool
// 0x0008 (0x0128 - 0x0120)
class UVoxelSolidifyMeshesTool final : public UBaseVoxelTool
{
public:
	class UVoxelSolidifyMeshesToolProperties*     SolidifyProperties;                                // 0x0120(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelSolidifyMeshesTool">();
	}
	static class UVoxelSolidifyMeshesTool* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelSolidifyMeshesTool>();
	}
};
static_assert(alignof(UVoxelSolidifyMeshesTool) == 0x000008, "Wrong alignment on UVoxelSolidifyMeshesTool");
static_assert(sizeof(UVoxelSolidifyMeshesTool) == 0x000128, "Wrong size on UVoxelSolidifyMeshesTool");
static_assert(offsetof(UVoxelSolidifyMeshesTool, SolidifyProperties) == 0x000120, "Member 'UVoxelSolidifyMeshesTool::SolidifyProperties' has a wrong offset!");

// Class MeshModelingToolsExp.VoxelSolidifyMeshesToolBuilder
// 0x0000 (0x0028 - 0x0028)
class UVoxelSolidifyMeshesToolBuilder final : public UBaseCreateFromSelectedToolBuilder
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelSolidifyMeshesToolBuilder">();
	}
	static class UVoxelSolidifyMeshesToolBuilder* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelSolidifyMeshesToolBuilder>();
	}
};
static_assert(alignof(UVoxelSolidifyMeshesToolBuilder) == 0x000008, "Wrong alignment on UVoxelSolidifyMeshesToolBuilder");
static_assert(sizeof(UVoxelSolidifyMeshesToolBuilder) == 0x000028, "Wrong size on UVoxelSolidifyMeshesToolBuilder");

// Class MeshModelingToolsExp.WeldMeshEdgesToolBuilder
// 0x0000 (0x0028 - 0x0028)
class UWeldMeshEdgesToolBuilder final : public USingleSelectionMeshEditingToolBuilder
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WeldMeshEdgesToolBuilder">();
	}
	static class UWeldMeshEdgesToolBuilder* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWeldMeshEdgesToolBuilder>();
	}
};
static_assert(alignof(UWeldMeshEdgesToolBuilder) == 0x000008, "Wrong alignment on UWeldMeshEdgesToolBuilder");
static_assert(sizeof(UWeldMeshEdgesToolBuilder) == 0x000028, "Wrong size on UWeldMeshEdgesToolBuilder");

// Class MeshModelingToolsExp.WeldMeshEdgesToolProperties
// 0x0028 (0x00D0 - 0x00A8)
class UWeldMeshEdgesToolProperties final : public UInteractiveToolPropertySet
{
public:
	float                                         Tolerance;                                         // 0x00A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOnlyUnique;                                       // 0x00AC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bResolveTJunctions;                                // 0x00AD(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AE[0x2];                                       // 0x00AE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         InitialEdges;                                      // 0x00B0(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RemainingEdges;                                    // 0x00B4(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EWeldMeshEdgesAttributeUIMode                 AttrWeldingMode;                                   // 0x00B8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B9[0x3];                                       // 0x00B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SplitNormalThreshold;                              // 0x00BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SplitTangentsThreshold;                            // 0x00C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SplitUVThreshold;                                  // 0x00C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SplitColorThreshold;                               // 0x00C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CC[0x4];                                       // 0x00CC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WeldMeshEdgesToolProperties">();
	}
	static class UWeldMeshEdgesToolProperties* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWeldMeshEdgesToolProperties>();
	}
};
static_assert(alignof(UWeldMeshEdgesToolProperties) == 0x000008, "Wrong alignment on UWeldMeshEdgesToolProperties");
static_assert(sizeof(UWeldMeshEdgesToolProperties) == 0x0000D0, "Wrong size on UWeldMeshEdgesToolProperties");
static_assert(offsetof(UWeldMeshEdgesToolProperties, Tolerance) == 0x0000A8, "Member 'UWeldMeshEdgesToolProperties::Tolerance' has a wrong offset!");
static_assert(offsetof(UWeldMeshEdgesToolProperties, bOnlyUnique) == 0x0000AC, "Member 'UWeldMeshEdgesToolProperties::bOnlyUnique' has a wrong offset!");
static_assert(offsetof(UWeldMeshEdgesToolProperties, bResolveTJunctions) == 0x0000AD, "Member 'UWeldMeshEdgesToolProperties::bResolveTJunctions' has a wrong offset!");
static_assert(offsetof(UWeldMeshEdgesToolProperties, InitialEdges) == 0x0000B0, "Member 'UWeldMeshEdgesToolProperties::InitialEdges' has a wrong offset!");
static_assert(offsetof(UWeldMeshEdgesToolProperties, RemainingEdges) == 0x0000B4, "Member 'UWeldMeshEdgesToolProperties::RemainingEdges' has a wrong offset!");
static_assert(offsetof(UWeldMeshEdgesToolProperties, AttrWeldingMode) == 0x0000B8, "Member 'UWeldMeshEdgesToolProperties::AttrWeldingMode' has a wrong offset!");
static_assert(offsetof(UWeldMeshEdgesToolProperties, SplitNormalThreshold) == 0x0000BC, "Member 'UWeldMeshEdgesToolProperties::SplitNormalThreshold' has a wrong offset!");
static_assert(offsetof(UWeldMeshEdgesToolProperties, SplitTangentsThreshold) == 0x0000C0, "Member 'UWeldMeshEdgesToolProperties::SplitTangentsThreshold' has a wrong offset!");
static_assert(offsetof(UWeldMeshEdgesToolProperties, SplitUVThreshold) == 0x0000C4, "Member 'UWeldMeshEdgesToolProperties::SplitUVThreshold' has a wrong offset!");
static_assert(offsetof(UWeldMeshEdgesToolProperties, SplitColorThreshold) == 0x0000C8, "Member 'UWeldMeshEdgesToolProperties::SplitColorThreshold' has a wrong offset!");

// Class MeshModelingToolsExp.WeldMeshEdgesOperatorFactory
// 0x0010 (0x0038 - 0x0028)
class UWeldMeshEdgesOperatorFactory final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UWeldMeshEdgesTool*                     WeldMeshEdgesTool;                                 // 0x0030(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WeldMeshEdgesOperatorFactory">();
	}
	static class UWeldMeshEdgesOperatorFactory* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWeldMeshEdgesOperatorFactory>();
	}
};
static_assert(alignof(UWeldMeshEdgesOperatorFactory) == 0x000008, "Wrong alignment on UWeldMeshEdgesOperatorFactory");
static_assert(sizeof(UWeldMeshEdgesOperatorFactory) == 0x000038, "Wrong size on UWeldMeshEdgesOperatorFactory");
static_assert(offsetof(UWeldMeshEdgesOperatorFactory, WeldMeshEdgesTool) == 0x000030, "Member 'UWeldMeshEdgesOperatorFactory::WeldMeshEdgesTool' has a wrong offset!");

// Class MeshModelingToolsExp.WeldMeshEdgesTool
// 0x0030 (0x00E0 - 0x00B0)
class UWeldMeshEdgesTool final : public USingleSelectionMeshEditingTool
{
public:
	class UWeldMeshEdgesToolProperties*           Settings;                                          // 0x00B0(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMeshOpPreviewWithBackgroundCompute*    PreviewCompute;                                    // 0x00B8(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMeshElementsVisualizer*                MeshElementsDisplay;                               // 0x00C0(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWeldMeshEdgesOperatorFactory*          OperatorFactory;                                   // 0x00C8(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D0[0x10];                                      // 0x00D0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WeldMeshEdgesTool">();
	}
	static class UWeldMeshEdgesTool* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWeldMeshEdgesTool>();
	}
};
static_assert(alignof(UWeldMeshEdgesTool) == 0x000008, "Wrong alignment on UWeldMeshEdgesTool");
static_assert(sizeof(UWeldMeshEdgesTool) == 0x0000E0, "Wrong size on UWeldMeshEdgesTool");
static_assert(offsetof(UWeldMeshEdgesTool, Settings) == 0x0000B0, "Member 'UWeldMeshEdgesTool::Settings' has a wrong offset!");
static_assert(offsetof(UWeldMeshEdgesTool, PreviewCompute) == 0x0000B8, "Member 'UWeldMeshEdgesTool::PreviewCompute' has a wrong offset!");
static_assert(offsetof(UWeldMeshEdgesTool, MeshElementsDisplay) == 0x0000C0, "Member 'UWeldMeshEdgesTool::MeshElementsDisplay' has a wrong offset!");
static_assert(offsetof(UWeldMeshEdgesTool, OperatorFactory) == 0x0000C8, "Member 'UWeldMeshEdgesTool::OperatorFactory' has a wrong offset!");

}

