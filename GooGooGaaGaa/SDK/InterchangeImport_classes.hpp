#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: InterchangeImport

#include "Basic.hpp"

#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "InterchangeCore_classes.hpp"
#include "InterchangeImport_structs.hpp"


namespace SDK
{

// Class InterchangeImport.InterchangeAnimationPayloadInterface
// 0x0000 (0x0028 - 0x0028)
class IInterchangeAnimationPayloadInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InterchangeAnimationPayloadInterface">();
	}
	static class IInterchangeAnimationPayloadInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IInterchangeAnimationPayloadInterface>();
	}
};
static_assert(alignof(IInterchangeAnimationPayloadInterface) == 0x000008, "Wrong alignment on IInterchangeAnimationPayloadInterface");
static_assert(sizeof(IInterchangeAnimationPayloadInterface) == 0x000028, "Wrong size on IInterchangeAnimationPayloadInterface");

// Class InterchangeImport.InterchangeAnimationTrackSetFactory
// 0x0008 (0x0038 - 0x0030)
class UInterchangeAnimationTrackSetFactory final : public UInterchangeFactoryBase
{
public:
	uint8                                         Pad_3119[0x8];                                     // 0x0030(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InterchangeAnimationTrackSetFactory">();
	}
	static class UInterchangeAnimationTrackSetFactory* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInterchangeAnimationTrackSetFactory>();
	}
};
static_assert(alignof(UInterchangeAnimationTrackSetFactory) == 0x000008, "Wrong alignment on UInterchangeAnimationTrackSetFactory");
static_assert(sizeof(UInterchangeAnimationTrackSetFactory) == 0x000038, "Wrong size on UInterchangeAnimationTrackSetFactory");

// Class InterchangeImport.InterchangeBlockedTexturePayloadInterface
// 0x0000 (0x0028 - 0x0028)
class IInterchangeBlockedTexturePayloadInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InterchangeBlockedTexturePayloadInterface">();
	}
	static class IInterchangeBlockedTexturePayloadInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IInterchangeBlockedTexturePayloadInterface>();
	}
};
static_assert(alignof(IInterchangeBlockedTexturePayloadInterface) == 0x000008, "Wrong alignment on IInterchangeBlockedTexturePayloadInterface");
static_assert(sizeof(IInterchangeBlockedTexturePayloadInterface) == 0x000028, "Wrong size on IInterchangeBlockedTexturePayloadInterface");

// Class InterchangeImport.InterchangeActorFactory
// 0x0000 (0x0030 - 0x0030)
class UInterchangeActorFactory : public UInterchangeFactoryBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InterchangeActorFactory">();
	}
	static class UInterchangeActorFactory* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInterchangeActorFactory>();
	}
};
static_assert(alignof(UInterchangeActorFactory) == 0x000008, "Wrong alignment on UInterchangeActorFactory");
static_assert(sizeof(UInterchangeActorFactory) == 0x000030, "Wrong size on UInterchangeActorFactory");

// Class InterchangeImport.InterchangeLightActorFactory
// 0x0000 (0x0030 - 0x0030)
class UInterchangeLightActorFactory final : public UInterchangeActorFactory
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InterchangeLightActorFactory">();
	}
	static class UInterchangeLightActorFactory* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInterchangeLightActorFactory>();
	}
};
static_assert(alignof(UInterchangeLightActorFactory) == 0x000008, "Wrong alignment on UInterchangeLightActorFactory");
static_assert(sizeof(UInterchangeLightActorFactory) == 0x000030, "Wrong size on UInterchangeLightActorFactory");

// Class InterchangeImport.InterchangeMeshPayloadInterface
// 0x0000 (0x0028 - 0x0028)
class IInterchangeMeshPayloadInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InterchangeMeshPayloadInterface">();
	}
	static class IInterchangeMeshPayloadInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IInterchangeMeshPayloadInterface>();
	}
};
static_assert(alignof(IInterchangeMeshPayloadInterface) == 0x000008, "Wrong alignment on IInterchangeMeshPayloadInterface");
static_assert(sizeof(IInterchangeMeshPayloadInterface) == 0x000028, "Wrong size on IInterchangeMeshPayloadInterface");

// Class InterchangeImport.InterchangeSceneImportAssetFactory
// 0x0000 (0x0030 - 0x0030)
class UInterchangeSceneImportAssetFactory final : public UInterchangeFactoryBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InterchangeSceneImportAssetFactory">();
	}
	static class UInterchangeSceneImportAssetFactory* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInterchangeSceneImportAssetFactory>();
	}
};
static_assert(alignof(UInterchangeSceneImportAssetFactory) == 0x000008, "Wrong alignment on UInterchangeSceneImportAssetFactory");
static_assert(sizeof(UInterchangeSceneImportAssetFactory) == 0x000030, "Wrong size on UInterchangeSceneImportAssetFactory");

// Class InterchangeImport.InterchangeSceneVariantSetsFactory
// 0x0008 (0x0038 - 0x0030)
class UInterchangeSceneVariantSetsFactory final : public UInterchangeFactoryBase
{
public:
	uint8                                         Pad_311A[0x8];                                     // 0x0030(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InterchangeSceneVariantSetsFactory">();
	}
	static class UInterchangeSceneVariantSetsFactory* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInterchangeSceneVariantSetsFactory>();
	}
};
static_assert(alignof(UInterchangeSceneVariantSetsFactory) == 0x000008, "Wrong alignment on UInterchangeSceneVariantSetsFactory");
static_assert(sizeof(UInterchangeSceneVariantSetsFactory) == 0x000038, "Wrong size on UInterchangeSceneVariantSetsFactory");

// Class InterchangeImport.InterchangeSlicedTexturePayloadInterface
// 0x0000 (0x0028 - 0x0028)
class IInterchangeSlicedTexturePayloadInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InterchangeSlicedTexturePayloadInterface">();
	}
	static class IInterchangeSlicedTexturePayloadInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IInterchangeSlicedTexturePayloadInterface>();
	}
};
static_assert(alignof(IInterchangeSlicedTexturePayloadInterface) == 0x000008, "Wrong alignment on IInterchangeSlicedTexturePayloadInterface");
static_assert(sizeof(IInterchangeSlicedTexturePayloadInterface) == 0x000028, "Wrong size on IInterchangeSlicedTexturePayloadInterface");

// Class InterchangeImport.InterchangeTextureLightProfilePayloadInterface
// 0x0000 (0x0028 - 0x0028)
class IInterchangeTextureLightProfilePayloadInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InterchangeTextureLightProfilePayloadInterface">();
	}
	static class IInterchangeTextureLightProfilePayloadInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IInterchangeTextureLightProfilePayloadInterface>();
	}
};
static_assert(alignof(IInterchangeTextureLightProfilePayloadInterface) == 0x000008, "Wrong alignment on IInterchangeTextureLightProfilePayloadInterface");
static_assert(sizeof(IInterchangeTextureLightProfilePayloadInterface) == 0x000028, "Wrong size on IInterchangeTextureLightProfilePayloadInterface");

// Class InterchangeImport.InterchangeTexturePayloadInterface
// 0x0000 (0x0028 - 0x0028)
class IInterchangeTexturePayloadInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InterchangeTexturePayloadInterface">();
	}
	static class IInterchangeTexturePayloadInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IInterchangeTexturePayloadInterface>();
	}
};
static_assert(alignof(IInterchangeTexturePayloadInterface) == 0x000008, "Wrong alignment on IInterchangeTexturePayloadInterface");
static_assert(sizeof(IInterchangeTexturePayloadInterface) == 0x000028, "Wrong size on IInterchangeTexturePayloadInterface");

// Class InterchangeImport.InterchangeVariantSetPayloadInterface
// 0x0000 (0x0028 - 0x0028)
class IInterchangeVariantSetPayloadInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InterchangeVariantSetPayloadInterface">();
	}
	static class IInterchangeVariantSetPayloadInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IInterchangeVariantSetPayloadInterface>();
	}
};
static_assert(alignof(IInterchangeVariantSetPayloadInterface) == 0x000008, "Wrong alignment on IInterchangeVariantSetPayloadInterface");
static_assert(sizeof(IInterchangeVariantSetPayloadInterface) == 0x000028, "Wrong size on IInterchangeVariantSetPayloadInterface");

// Class InterchangeImport.MaterialExpressionMaterialXRamp4
// 0x00D0 (0x0180 - 0x00B0)
class UMaterialExpressionMaterialXRamp4 final : public UMaterialExpression
{
public:
	struct FExpressionInput                       Coordinates;                                       // 0x00B0(0x0028)(NoDestructor, NativeAccessSpecifierPublic)
	struct FExpressionInput                       A;                                                 // 0x00D8(0x0028)(NoDestructor, NativeAccessSpecifierPublic)
	struct FExpressionInput                       B;                                                 // 0x0100(0x0028)(NoDestructor, NativeAccessSpecifierPublic)
	struct FExpressionInput                       C;                                                 // 0x0128(0x0028)(NoDestructor, NativeAccessSpecifierPublic)
	struct FExpressionInput                       D;                                                 // 0x0150(0x0028)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         ConstCoordinate;                                   // 0x0178(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_311B[0x7];                                     // 0x0179(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionMaterialXRamp4">();
	}
	static class UMaterialExpressionMaterialXRamp4* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionMaterialXRamp4>();
	}
};
static_assert(alignof(UMaterialExpressionMaterialXRamp4) == 0x000008, "Wrong alignment on UMaterialExpressionMaterialXRamp4");
static_assert(sizeof(UMaterialExpressionMaterialXRamp4) == 0x000180, "Wrong size on UMaterialExpressionMaterialXRamp4");
static_assert(offsetof(UMaterialExpressionMaterialXRamp4, Coordinates) == 0x0000B0, "Member 'UMaterialExpressionMaterialXRamp4::Coordinates' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionMaterialXRamp4, A) == 0x0000D8, "Member 'UMaterialExpressionMaterialXRamp4::A' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionMaterialXRamp4, B) == 0x000100, "Member 'UMaterialExpressionMaterialXRamp4::B' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionMaterialXRamp4, C) == 0x000128, "Member 'UMaterialExpressionMaterialXRamp4::C' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionMaterialXRamp4, D) == 0x000150, "Member 'UMaterialExpressionMaterialXRamp4::D' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionMaterialXRamp4, ConstCoordinate) == 0x000178, "Member 'UMaterialExpressionMaterialXRamp4::ConstCoordinate' has a wrong offset!");

// Class InterchangeImport.InterchangeAnimSequenceFactory
// 0x0000 (0x0030 - 0x0030)
class UInterchangeAnimSequenceFactory final : public UInterchangeFactoryBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InterchangeAnimSequenceFactory">();
	}
	static class UInterchangeAnimSequenceFactory* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInterchangeAnimSequenceFactory>();
	}
};
static_assert(alignof(UInterchangeAnimSequenceFactory) == 0x000008, "Wrong alignment on UInterchangeAnimSequenceFactory");
static_assert(sizeof(UInterchangeAnimSequenceFactory) == 0x000030, "Wrong size on UInterchangeAnimSequenceFactory");

// Class InterchangeImport.InterchangeFbxTranslator
// 0x0020 (0x0058 - 0x0038)
class UInterchangeFbxTranslator final : public UInterchangeTranslatorBase
{
public:
	uint8                                         Pad_311C[0x20];                                    // 0x0038(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InterchangeFbxTranslator">();
	}
	static class UInterchangeFbxTranslator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInterchangeFbxTranslator>();
	}
};
static_assert(alignof(UInterchangeFbxTranslator) == 0x000008, "Wrong alignment on UInterchangeFbxTranslator");
static_assert(sizeof(UInterchangeFbxTranslator) == 0x000058, "Wrong size on UInterchangeFbxTranslator");

// Class InterchangeImport.InterchangeGLTFTranslator
// 0x0240 (0x0278 - 0x0038)
class UInterchangeGLTFTranslator final : public UInterchangeTranslatorBase
{
public:
	uint8                                         Pad_311D[0x240];                                   // 0x0038(0x0240)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InterchangeGLTFTranslator">();
	}
	static class UInterchangeGLTFTranslator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInterchangeGLTFTranslator>();
	}
};
static_assert(alignof(UInterchangeGLTFTranslator) == 0x000008, "Wrong alignment on UInterchangeGLTFTranslator");
static_assert(sizeof(UInterchangeGLTFTranslator) == 0x000278, "Wrong size on UInterchangeGLTFTranslator");

// Class InterchangeImport.InterchangeMaterialXTranslator
// 0x0008 (0x0040 - 0x0038)
class UInterchangeMaterialXTranslator final : public UInterchangeTranslatorBase
{
public:
	uint8                                         Pad_311E[0x8];                                     // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InterchangeMaterialXTranslator">();
	}
	static class UInterchangeMaterialXTranslator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInterchangeMaterialXTranslator>();
	}
};
static_assert(alignof(UInterchangeMaterialXTranslator) == 0x000008, "Wrong alignment on UInterchangeMaterialXTranslator");
static_assert(sizeof(UInterchangeMaterialXTranslator) == 0x000040, "Wrong size on UInterchangeMaterialXTranslator");

// Class InterchangeImport.MaterialExpressionMaterialXAppend3Vector
// 0x0078 (0x0128 - 0x00B0)
class UMaterialExpressionMaterialXAppend3Vector final : public UMaterialExpression
{
public:
	struct FExpressionInput                       A;                                                 // 0x00B0(0x0028)(NoDestructor, NativeAccessSpecifierPublic)
	struct FExpressionInput                       B;                                                 // 0x00D8(0x0028)(NoDestructor, NativeAccessSpecifierPublic)
	struct FExpressionInput                       C;                                                 // 0x0100(0x0028)(NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionMaterialXAppend3Vector">();
	}
	static class UMaterialExpressionMaterialXAppend3Vector* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionMaterialXAppend3Vector>();
	}
};
static_assert(alignof(UMaterialExpressionMaterialXAppend3Vector) == 0x000008, "Wrong alignment on UMaterialExpressionMaterialXAppend3Vector");
static_assert(sizeof(UMaterialExpressionMaterialXAppend3Vector) == 0x000128, "Wrong size on UMaterialExpressionMaterialXAppend3Vector");
static_assert(offsetof(UMaterialExpressionMaterialXAppend3Vector, A) == 0x0000B0, "Member 'UMaterialExpressionMaterialXAppend3Vector::A' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionMaterialXAppend3Vector, B) == 0x0000D8, "Member 'UMaterialExpressionMaterialXAppend3Vector::B' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionMaterialXAppend3Vector, C) == 0x000100, "Member 'UMaterialExpressionMaterialXAppend3Vector::C' has a wrong offset!");

// Class InterchangeImport.MaterialExpressionMaterialXAppend4Vector
// 0x00A0 (0x0150 - 0x00B0)
class UMaterialExpressionMaterialXAppend4Vector final : public UMaterialExpression
{
public:
	struct FExpressionInput                       A;                                                 // 0x00B0(0x0028)(NoDestructor, NativeAccessSpecifierPublic)
	struct FExpressionInput                       B;                                                 // 0x00D8(0x0028)(NoDestructor, NativeAccessSpecifierPublic)
	struct FExpressionInput                       C;                                                 // 0x0100(0x0028)(NoDestructor, NativeAccessSpecifierPublic)
	struct FExpressionInput                       D;                                                 // 0x0128(0x0028)(NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionMaterialXAppend4Vector">();
	}
	static class UMaterialExpressionMaterialXAppend4Vector* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionMaterialXAppend4Vector>();
	}
};
static_assert(alignof(UMaterialExpressionMaterialXAppend4Vector) == 0x000008, "Wrong alignment on UMaterialExpressionMaterialXAppend4Vector");
static_assert(sizeof(UMaterialExpressionMaterialXAppend4Vector) == 0x000150, "Wrong size on UMaterialExpressionMaterialXAppend4Vector");
static_assert(offsetof(UMaterialExpressionMaterialXAppend4Vector, A) == 0x0000B0, "Member 'UMaterialExpressionMaterialXAppend4Vector::A' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionMaterialXAppend4Vector, B) == 0x0000D8, "Member 'UMaterialExpressionMaterialXAppend4Vector::B' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionMaterialXAppend4Vector, C) == 0x000100, "Member 'UMaterialExpressionMaterialXAppend4Vector::C' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionMaterialXAppend4Vector, D) == 0x000128, "Member 'UMaterialExpressionMaterialXAppend4Vector::D' has a wrong offset!");

// Class InterchangeImport.MaterialExpressionMaterialXBurn
// 0x0080 (0x0130 - 0x00B0)
class UMaterialExpressionMaterialXBurn final : public UMaterialExpression
{
public:
	struct FExpressionInput                       A;                                                 // 0x00B0(0x0028)(NoDestructor, NativeAccessSpecifierPublic)
	struct FExpressionInput                       B;                                                 // 0x00D8(0x0028)(NoDestructor, NativeAccessSpecifierPublic)
	struct FExpressionInput                       Alpha;                                             // 0x0100(0x0028)(NoDestructor, NativeAccessSpecifierPublic)
	float                                         ConstAlpha;                                        // 0x0128(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_311F[0x4];                                     // 0x012C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionMaterialXBurn">();
	}
	static class UMaterialExpressionMaterialXBurn* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionMaterialXBurn>();
	}
};
static_assert(alignof(UMaterialExpressionMaterialXBurn) == 0x000008, "Wrong alignment on UMaterialExpressionMaterialXBurn");
static_assert(sizeof(UMaterialExpressionMaterialXBurn) == 0x000130, "Wrong size on UMaterialExpressionMaterialXBurn");
static_assert(offsetof(UMaterialExpressionMaterialXBurn, A) == 0x0000B0, "Member 'UMaterialExpressionMaterialXBurn::A' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionMaterialXBurn, B) == 0x0000D8, "Member 'UMaterialExpressionMaterialXBurn::B' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionMaterialXBurn, Alpha) == 0x000100, "Member 'UMaterialExpressionMaterialXBurn::Alpha' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionMaterialXBurn, ConstAlpha) == 0x000128, "Member 'UMaterialExpressionMaterialXBurn::ConstAlpha' has a wrong offset!");

// Class InterchangeImport.MaterialExpressionMaterialXDifference
// 0x0080 (0x0130 - 0x00B0)
class UMaterialExpressionMaterialXDifference final : public UMaterialExpression
{
public:
	struct FExpressionInput                       A;                                                 // 0x00B0(0x0028)(NoDestructor, NativeAccessSpecifierPublic)
	struct FExpressionInput                       B;                                                 // 0x00D8(0x0028)(NoDestructor, NativeAccessSpecifierPublic)
	struct FExpressionInput                       Alpha;                                             // 0x0100(0x0028)(NoDestructor, NativeAccessSpecifierPublic)
	float                                         ConstAlpha;                                        // 0x0128(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3120[0x4];                                     // 0x012C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionMaterialXDifference">();
	}
	static class UMaterialExpressionMaterialXDifference* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionMaterialXDifference>();
	}
};
static_assert(alignof(UMaterialExpressionMaterialXDifference) == 0x000008, "Wrong alignment on UMaterialExpressionMaterialXDifference");
static_assert(sizeof(UMaterialExpressionMaterialXDifference) == 0x000130, "Wrong size on UMaterialExpressionMaterialXDifference");
static_assert(offsetof(UMaterialExpressionMaterialXDifference, A) == 0x0000B0, "Member 'UMaterialExpressionMaterialXDifference::A' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionMaterialXDifference, B) == 0x0000D8, "Member 'UMaterialExpressionMaterialXDifference::B' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionMaterialXDifference, Alpha) == 0x000100, "Member 'UMaterialExpressionMaterialXDifference::Alpha' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionMaterialXDifference, ConstAlpha) == 0x000128, "Member 'UMaterialExpressionMaterialXDifference::ConstAlpha' has a wrong offset!");

// Class InterchangeImport.MaterialExpressionMaterialXDisjointOver
// 0x0080 (0x0130 - 0x00B0)
class UMaterialExpressionMaterialXDisjointOver final : public UMaterialExpression
{
public:
	struct FExpressionInput                       A;                                                 // 0x00B0(0x0028)(NoDestructor, NativeAccessSpecifierPublic)
	struct FExpressionInput                       B;                                                 // 0x00D8(0x0028)(NoDestructor, NativeAccessSpecifierPublic)
	struct FExpressionInput                       Alpha;                                             // 0x0100(0x0028)(NoDestructor, NativeAccessSpecifierPublic)
	float                                         ConstAlpha;                                        // 0x0128(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3121[0x4];                                     // 0x012C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionMaterialXDisjointOver">();
	}
	static class UMaterialExpressionMaterialXDisjointOver* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionMaterialXDisjointOver>();
	}
};
static_assert(alignof(UMaterialExpressionMaterialXDisjointOver) == 0x000008, "Wrong alignment on UMaterialExpressionMaterialXDisjointOver");
static_assert(sizeof(UMaterialExpressionMaterialXDisjointOver) == 0x000130, "Wrong size on UMaterialExpressionMaterialXDisjointOver");
static_assert(offsetof(UMaterialExpressionMaterialXDisjointOver, A) == 0x0000B0, "Member 'UMaterialExpressionMaterialXDisjointOver::A' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionMaterialXDisjointOver, B) == 0x0000D8, "Member 'UMaterialExpressionMaterialXDisjointOver::B' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionMaterialXDisjointOver, Alpha) == 0x000100, "Member 'UMaterialExpressionMaterialXDisjointOver::Alpha' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionMaterialXDisjointOver, ConstAlpha) == 0x000128, "Member 'UMaterialExpressionMaterialXDisjointOver::ConstAlpha' has a wrong offset!");

// Class InterchangeImport.MaterialExpressionMaterialXDodge
// 0x0080 (0x0130 - 0x00B0)
class UMaterialExpressionMaterialXDodge final : public UMaterialExpression
{
public:
	struct FExpressionInput                       A;                                                 // 0x00B0(0x0028)(NoDestructor, NativeAccessSpecifierPublic)
	struct FExpressionInput                       B;                                                 // 0x00D8(0x0028)(NoDestructor, NativeAccessSpecifierPublic)
	struct FExpressionInput                       Alpha;                                             // 0x0100(0x0028)(NoDestructor, NativeAccessSpecifierPublic)
	float                                         ConstAlpha;                                        // 0x0128(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3122[0x4];                                     // 0x012C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionMaterialXDodge">();
	}
	static class UMaterialExpressionMaterialXDodge* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionMaterialXDodge>();
	}
};
static_assert(alignof(UMaterialExpressionMaterialXDodge) == 0x000008, "Wrong alignment on UMaterialExpressionMaterialXDodge");
static_assert(sizeof(UMaterialExpressionMaterialXDodge) == 0x000130, "Wrong size on UMaterialExpressionMaterialXDodge");
static_assert(offsetof(UMaterialExpressionMaterialXDodge, A) == 0x0000B0, "Member 'UMaterialExpressionMaterialXDodge::A' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionMaterialXDodge, B) == 0x0000D8, "Member 'UMaterialExpressionMaterialXDodge::B' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionMaterialXDodge, Alpha) == 0x000100, "Member 'UMaterialExpressionMaterialXDodge::Alpha' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionMaterialXDodge, ConstAlpha) == 0x000128, "Member 'UMaterialExpressionMaterialXDodge::ConstAlpha' has a wrong offset!");

// Class InterchangeImport.MaterialExpressionMaterialXFractal3D
// 0x00F8 (0x01A8 - 0x00B0)
class UMaterialExpressionMaterialXFractal3D final : public UMaterialExpression
{
public:
	struct FExpressionInput                       Position;                                          // 0x00B0(0x0028)(NoDestructor, NativeAccessSpecifierPublic)
	struct FExpressionInput                       Amplitude;                                         // 0x00D8(0x0028)(NoDestructor, NativeAccessSpecifierPublic)
	float                                         ConstAmplitude;                                    // 0x0100(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3123[0x4];                                     // 0x0104(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FExpressionInput                       Octaves;                                           // 0x0108(0x0028)(NoDestructor, NativeAccessSpecifierPublic)
	int32                                         ConstOctaves;                                      // 0x0130(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3124[0x4];                                     // 0x0134(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FExpressionInput                       Lacunarity;                                        // 0x0138(0x0028)(NoDestructor, NativeAccessSpecifierPublic)
	float                                         ConstLacunarity;                                   // 0x0160(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3125[0x4];                                     // 0x0164(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FExpressionInput                       Diminish;                                          // 0x0168(0x0028)(NoDestructor, NativeAccessSpecifierPublic)
	float                                         ConstDiminish;                                     // 0x0190(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Scale;                                             // 0x0194(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTurbulence;                                       // 0x0198(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3126[0x3];                                     // 0x0199(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Levels;                                            // 0x019C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OutputMin;                                         // 0x01A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OutputMax;                                         // 0x01A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionMaterialXFractal3D">();
	}
	static class UMaterialExpressionMaterialXFractal3D* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionMaterialXFractal3D>();
	}
};
static_assert(alignof(UMaterialExpressionMaterialXFractal3D) == 0x000008, "Wrong alignment on UMaterialExpressionMaterialXFractal3D");
static_assert(sizeof(UMaterialExpressionMaterialXFractal3D) == 0x0001A8, "Wrong size on UMaterialExpressionMaterialXFractal3D");
static_assert(offsetof(UMaterialExpressionMaterialXFractal3D, Position) == 0x0000B0, "Member 'UMaterialExpressionMaterialXFractal3D::Position' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionMaterialXFractal3D, Amplitude) == 0x0000D8, "Member 'UMaterialExpressionMaterialXFractal3D::Amplitude' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionMaterialXFractal3D, ConstAmplitude) == 0x000100, "Member 'UMaterialExpressionMaterialXFractal3D::ConstAmplitude' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionMaterialXFractal3D, Octaves) == 0x000108, "Member 'UMaterialExpressionMaterialXFractal3D::Octaves' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionMaterialXFractal3D, ConstOctaves) == 0x000130, "Member 'UMaterialExpressionMaterialXFractal3D::ConstOctaves' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionMaterialXFractal3D, Lacunarity) == 0x000138, "Member 'UMaterialExpressionMaterialXFractal3D::Lacunarity' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionMaterialXFractal3D, ConstLacunarity) == 0x000160, "Member 'UMaterialExpressionMaterialXFractal3D::ConstLacunarity' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionMaterialXFractal3D, Diminish) == 0x000168, "Member 'UMaterialExpressionMaterialXFractal3D::Diminish' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionMaterialXFractal3D, ConstDiminish) == 0x000190, "Member 'UMaterialExpressionMaterialXFractal3D::ConstDiminish' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionMaterialXFractal3D, Scale) == 0x000194, "Member 'UMaterialExpressionMaterialXFractal3D::Scale' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionMaterialXFractal3D, bTurbulence) == 0x000198, "Member 'UMaterialExpressionMaterialXFractal3D::bTurbulence' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionMaterialXFractal3D, Levels) == 0x00019C, "Member 'UMaterialExpressionMaterialXFractal3D::Levels' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionMaterialXFractal3D, OutputMin) == 0x0001A0, "Member 'UMaterialExpressionMaterialXFractal3D::OutputMin' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionMaterialXFractal3D, OutputMax) == 0x0001A4, "Member 'UMaterialExpressionMaterialXFractal3D::OutputMax' has a wrong offset!");

// Class InterchangeImport.MaterialExpressionMaterialXIn
// 0x0080 (0x0130 - 0x00B0)
class UMaterialExpressionMaterialXIn final : public UMaterialExpression
{
public:
	struct FExpressionInput                       A;                                                 // 0x00B0(0x0028)(NoDestructor, NativeAccessSpecifierPublic)
	struct FExpressionInput                       B;                                                 // 0x00D8(0x0028)(NoDestructor, NativeAccessSpecifierPublic)
	struct FExpressionInput                       Alpha;                                             // 0x0100(0x0028)(NoDestructor, NativeAccessSpecifierPublic)
	float                                         ConstAlpha;                                        // 0x0128(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3127[0x4];                                     // 0x012C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionMaterialXIn">();
	}
	static class UMaterialExpressionMaterialXIn* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionMaterialXIn>();
	}
};
static_assert(alignof(UMaterialExpressionMaterialXIn) == 0x000008, "Wrong alignment on UMaterialExpressionMaterialXIn");
static_assert(sizeof(UMaterialExpressionMaterialXIn) == 0x000130, "Wrong size on UMaterialExpressionMaterialXIn");
static_assert(offsetof(UMaterialExpressionMaterialXIn, A) == 0x0000B0, "Member 'UMaterialExpressionMaterialXIn::A' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionMaterialXIn, B) == 0x0000D8, "Member 'UMaterialExpressionMaterialXIn::B' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionMaterialXIn, Alpha) == 0x000100, "Member 'UMaterialExpressionMaterialXIn::Alpha' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionMaterialXIn, ConstAlpha) == 0x000128, "Member 'UMaterialExpressionMaterialXIn::ConstAlpha' has a wrong offset!");

// Class InterchangeImport.MaterialExpressionMaterialXLuminance
// 0x0040 (0x00F0 - 0x00B0)
class UMaterialExpressionMaterialXLuminance final : public UMaterialExpression
{
public:
	struct FExpressionInput                       Input;                                             // 0x00B0(0x0028)(NoDestructor, NativeAccessSpecifierPublic)
	struct FLinearColor                           LuminanceFactors;                                  // 0x00D8(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMaterialXLuminanceMode                       LuminanceMode;                                     // 0x00E8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3128[0x7];                                     // 0x00E9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionMaterialXLuminance">();
	}
	static class UMaterialExpressionMaterialXLuminance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionMaterialXLuminance>();
	}
};
static_assert(alignof(UMaterialExpressionMaterialXLuminance) == 0x000008, "Wrong alignment on UMaterialExpressionMaterialXLuminance");
static_assert(sizeof(UMaterialExpressionMaterialXLuminance) == 0x0000F0, "Wrong size on UMaterialExpressionMaterialXLuminance");
static_assert(offsetof(UMaterialExpressionMaterialXLuminance, Input) == 0x0000B0, "Member 'UMaterialExpressionMaterialXLuminance::Input' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionMaterialXLuminance, LuminanceFactors) == 0x0000D8, "Member 'UMaterialExpressionMaterialXLuminance::LuminanceFactors' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionMaterialXLuminance, LuminanceMode) == 0x0000E8, "Member 'UMaterialExpressionMaterialXLuminance::LuminanceMode' has a wrong offset!");

// Class InterchangeImport.MaterialExpressionMaterialXMask
// 0x0080 (0x0130 - 0x00B0)
class UMaterialExpressionMaterialXMask final : public UMaterialExpression
{
public:
	struct FExpressionInput                       A;                                                 // 0x00B0(0x0028)(NoDestructor, NativeAccessSpecifierPublic)
	struct FExpressionInput                       B;                                                 // 0x00D8(0x0028)(NoDestructor, NativeAccessSpecifierPublic)
	struct FExpressionInput                       Alpha;                                             // 0x0100(0x0028)(NoDestructor, NativeAccessSpecifierPublic)
	float                                         ConstAlpha;                                        // 0x0128(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3129[0x4];                                     // 0x012C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionMaterialXMask">();
	}
	static class UMaterialExpressionMaterialXMask* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionMaterialXMask>();
	}
};
static_assert(alignof(UMaterialExpressionMaterialXMask) == 0x000008, "Wrong alignment on UMaterialExpressionMaterialXMask");
static_assert(sizeof(UMaterialExpressionMaterialXMask) == 0x000130, "Wrong size on UMaterialExpressionMaterialXMask");
static_assert(offsetof(UMaterialExpressionMaterialXMask, A) == 0x0000B0, "Member 'UMaterialExpressionMaterialXMask::A' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionMaterialXMask, B) == 0x0000D8, "Member 'UMaterialExpressionMaterialXMask::B' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionMaterialXMask, Alpha) == 0x000100, "Member 'UMaterialExpressionMaterialXMask::Alpha' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionMaterialXMask, ConstAlpha) == 0x000128, "Member 'UMaterialExpressionMaterialXMask::ConstAlpha' has a wrong offset!");

// Class InterchangeImport.MaterialExpressionMaterialXMatte
// 0x0080 (0x0130 - 0x00B0)
class UMaterialExpressionMaterialXMatte final : public UMaterialExpression
{
public:
	struct FExpressionInput                       A;                                                 // 0x00B0(0x0028)(NoDestructor, NativeAccessSpecifierPublic)
	struct FExpressionInput                       B;                                                 // 0x00D8(0x0028)(NoDestructor, NativeAccessSpecifierPublic)
	struct FExpressionInput                       Alpha;                                             // 0x0100(0x0028)(NoDestructor, NativeAccessSpecifierPublic)
	float                                         ConstAlpha;                                        // 0x0128(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_312A[0x4];                                     // 0x012C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionMaterialXMatte">();
	}
	static class UMaterialExpressionMaterialXMatte* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionMaterialXMatte>();
	}
};
static_assert(alignof(UMaterialExpressionMaterialXMatte) == 0x000008, "Wrong alignment on UMaterialExpressionMaterialXMatte");
static_assert(sizeof(UMaterialExpressionMaterialXMatte) == 0x000130, "Wrong size on UMaterialExpressionMaterialXMatte");
static_assert(offsetof(UMaterialExpressionMaterialXMatte, A) == 0x0000B0, "Member 'UMaterialExpressionMaterialXMatte::A' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionMaterialXMatte, B) == 0x0000D8, "Member 'UMaterialExpressionMaterialXMatte::B' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionMaterialXMatte, Alpha) == 0x000100, "Member 'UMaterialExpressionMaterialXMatte::Alpha' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionMaterialXMatte, ConstAlpha) == 0x000128, "Member 'UMaterialExpressionMaterialXMatte::ConstAlpha' has a wrong offset!");

// Class InterchangeImport.MaterialExpressionMaterialXMinus
// 0x0080 (0x0130 - 0x00B0)
class UMaterialExpressionMaterialXMinus final : public UMaterialExpression
{
public:
	struct FExpressionInput                       A;                                                 // 0x00B0(0x0028)(NoDestructor, NativeAccessSpecifierPublic)
	struct FExpressionInput                       B;                                                 // 0x00D8(0x0028)(NoDestructor, NativeAccessSpecifierPublic)
	struct FExpressionInput                       Alpha;                                             // 0x0100(0x0028)(NoDestructor, NativeAccessSpecifierPublic)
	float                                         ConstAlpha;                                        // 0x0128(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_312B[0x4];                                     // 0x012C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionMaterialXMinus">();
	}
	static class UMaterialExpressionMaterialXMinus* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionMaterialXMinus>();
	}
};
static_assert(alignof(UMaterialExpressionMaterialXMinus) == 0x000008, "Wrong alignment on UMaterialExpressionMaterialXMinus");
static_assert(sizeof(UMaterialExpressionMaterialXMinus) == 0x000130, "Wrong size on UMaterialExpressionMaterialXMinus");
static_assert(offsetof(UMaterialExpressionMaterialXMinus, A) == 0x0000B0, "Member 'UMaterialExpressionMaterialXMinus::A' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionMaterialXMinus, B) == 0x0000D8, "Member 'UMaterialExpressionMaterialXMinus::B' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionMaterialXMinus, Alpha) == 0x000100, "Member 'UMaterialExpressionMaterialXMinus::Alpha' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionMaterialXMinus, ConstAlpha) == 0x000128, "Member 'UMaterialExpressionMaterialXMinus::ConstAlpha' has a wrong offset!");

// Class InterchangeImport.MaterialExpressionMaterialXOut
// 0x0080 (0x0130 - 0x00B0)
class UMaterialExpressionMaterialXOut final : public UMaterialExpression
{
public:
	struct FExpressionInput                       A;                                                 // 0x00B0(0x0028)(NoDestructor, NativeAccessSpecifierPublic)
	struct FExpressionInput                       B;                                                 // 0x00D8(0x0028)(NoDestructor, NativeAccessSpecifierPublic)
	struct FExpressionInput                       Alpha;                                             // 0x0100(0x0028)(NoDestructor, NativeAccessSpecifierPublic)
	float                                         ConstAlpha;                                        // 0x0128(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_312C[0x4];                                     // 0x012C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionMaterialXOut">();
	}
	static class UMaterialExpressionMaterialXOut* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionMaterialXOut>();
	}
};
static_assert(alignof(UMaterialExpressionMaterialXOut) == 0x000008, "Wrong alignment on UMaterialExpressionMaterialXOut");
static_assert(sizeof(UMaterialExpressionMaterialXOut) == 0x000130, "Wrong size on UMaterialExpressionMaterialXOut");
static_assert(offsetof(UMaterialExpressionMaterialXOut, A) == 0x0000B0, "Member 'UMaterialExpressionMaterialXOut::A' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionMaterialXOut, B) == 0x0000D8, "Member 'UMaterialExpressionMaterialXOut::B' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionMaterialXOut, Alpha) == 0x000100, "Member 'UMaterialExpressionMaterialXOut::Alpha' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionMaterialXOut, ConstAlpha) == 0x000128, "Member 'UMaterialExpressionMaterialXOut::ConstAlpha' has a wrong offset!");

// Class InterchangeImport.MaterialExpressionMaterialXOver
// 0x0080 (0x0130 - 0x00B0)
class UMaterialExpressionMaterialXOver final : public UMaterialExpression
{
public:
	struct FExpressionInput                       A;                                                 // 0x00B0(0x0028)(NoDestructor, NativeAccessSpecifierPublic)
	struct FExpressionInput                       B;                                                 // 0x00D8(0x0028)(NoDestructor, NativeAccessSpecifierPublic)
	struct FExpressionInput                       Alpha;                                             // 0x0100(0x0028)(NoDestructor, NativeAccessSpecifierPublic)
	float                                         ConstAlpha;                                        // 0x0128(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_312D[0x4];                                     // 0x012C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionMaterialXOver">();
	}
	static class UMaterialExpressionMaterialXOver* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionMaterialXOver>();
	}
};
static_assert(alignof(UMaterialExpressionMaterialXOver) == 0x000008, "Wrong alignment on UMaterialExpressionMaterialXOver");
static_assert(sizeof(UMaterialExpressionMaterialXOver) == 0x000130, "Wrong size on UMaterialExpressionMaterialXOver");
static_assert(offsetof(UMaterialExpressionMaterialXOver, A) == 0x0000B0, "Member 'UMaterialExpressionMaterialXOver::A' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionMaterialXOver, B) == 0x0000D8, "Member 'UMaterialExpressionMaterialXOver::B' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionMaterialXOver, Alpha) == 0x000100, "Member 'UMaterialExpressionMaterialXOver::Alpha' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionMaterialXOver, ConstAlpha) == 0x000128, "Member 'UMaterialExpressionMaterialXOver::ConstAlpha' has a wrong offset!");

// Class InterchangeImport.MaterialExpressionMaterialXOverlay
// 0x0080 (0x0130 - 0x00B0)
class UMaterialExpressionMaterialXOverlay final : public UMaterialExpression
{
public:
	struct FExpressionInput                       A;                                                 // 0x00B0(0x0028)(NoDestructor, NativeAccessSpecifierPublic)
	struct FExpressionInput                       B;                                                 // 0x00D8(0x0028)(NoDestructor, NativeAccessSpecifierPublic)
	struct FExpressionInput                       Alpha;                                             // 0x0100(0x0028)(NoDestructor, NativeAccessSpecifierPublic)
	float                                         ConstAlpha;                                        // 0x0128(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_312E[0x4];                                     // 0x012C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionMaterialXOverlay">();
	}
	static class UMaterialExpressionMaterialXOverlay* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionMaterialXOverlay>();
	}
};
static_assert(alignof(UMaterialExpressionMaterialXOverlay) == 0x000008, "Wrong alignment on UMaterialExpressionMaterialXOverlay");
static_assert(sizeof(UMaterialExpressionMaterialXOverlay) == 0x000130, "Wrong size on UMaterialExpressionMaterialXOverlay");
static_assert(offsetof(UMaterialExpressionMaterialXOverlay, A) == 0x0000B0, "Member 'UMaterialExpressionMaterialXOverlay::A' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionMaterialXOverlay, B) == 0x0000D8, "Member 'UMaterialExpressionMaterialXOverlay::B' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionMaterialXOverlay, Alpha) == 0x000100, "Member 'UMaterialExpressionMaterialXOverlay::Alpha' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionMaterialXOverlay, ConstAlpha) == 0x000128, "Member 'UMaterialExpressionMaterialXOverlay::ConstAlpha' has a wrong offset!");

// Class InterchangeImport.MaterialExpressionMaterialXPlace2D
// 0x00D0 (0x0180 - 0x00B0)
class UMaterialExpressionMaterialXPlace2D final : public UMaterialExpression
{
public:
	struct FExpressionInput                       Coordinates;                                       // 0x00B0(0x0028)(NoDestructor, NativeAccessSpecifierPublic)
	struct FExpressionInput                       Pivot;                                             // 0x00D8(0x0028)(NoDestructor, NativeAccessSpecifierPublic)
	struct FExpressionInput                       Scale;                                             // 0x0100(0x0028)(NoDestructor, NativeAccessSpecifierPublic)
	struct FExpressionInput                       Offset;                                            // 0x0128(0x0028)(NoDestructor, NativeAccessSpecifierPublic)
	struct FExpressionInput                       RotationAngle;                                     // 0x0150(0x0028)(NoDestructor, NativeAccessSpecifierPublic)
	float                                         ConstRotationAngle;                                // 0x0178(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         ConstCoordinate;                                   // 0x017C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_312F[0x3];                                     // 0x017D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionMaterialXPlace2D">();
	}
	static class UMaterialExpressionMaterialXPlace2D* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionMaterialXPlace2D>();
	}
};
static_assert(alignof(UMaterialExpressionMaterialXPlace2D) == 0x000008, "Wrong alignment on UMaterialExpressionMaterialXPlace2D");
static_assert(sizeof(UMaterialExpressionMaterialXPlace2D) == 0x000180, "Wrong size on UMaterialExpressionMaterialXPlace2D");
static_assert(offsetof(UMaterialExpressionMaterialXPlace2D, Coordinates) == 0x0000B0, "Member 'UMaterialExpressionMaterialXPlace2D::Coordinates' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionMaterialXPlace2D, Pivot) == 0x0000D8, "Member 'UMaterialExpressionMaterialXPlace2D::Pivot' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionMaterialXPlace2D, Scale) == 0x000100, "Member 'UMaterialExpressionMaterialXPlace2D::Scale' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionMaterialXPlace2D, Offset) == 0x000128, "Member 'UMaterialExpressionMaterialXPlace2D::Offset' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionMaterialXPlace2D, RotationAngle) == 0x000150, "Member 'UMaterialExpressionMaterialXPlace2D::RotationAngle' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionMaterialXPlace2D, ConstRotationAngle) == 0x000178, "Member 'UMaterialExpressionMaterialXPlace2D::ConstRotationAngle' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionMaterialXPlace2D, ConstCoordinate) == 0x00017C, "Member 'UMaterialExpressionMaterialXPlace2D::ConstCoordinate' has a wrong offset!");

// Class InterchangeImport.MaterialExpressionMaterialXPlus
// 0x0080 (0x0130 - 0x00B0)
class UMaterialExpressionMaterialXPlus final : public UMaterialExpression
{
public:
	struct FExpressionInput                       A;                                                 // 0x00B0(0x0028)(NoDestructor, NativeAccessSpecifierPublic)
	struct FExpressionInput                       B;                                                 // 0x00D8(0x0028)(NoDestructor, NativeAccessSpecifierPublic)
	struct FExpressionInput                       Alpha;                                             // 0x0100(0x0028)(NoDestructor, NativeAccessSpecifierPublic)
	float                                         ConstAlpha;                                        // 0x0128(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3130[0x4];                                     // 0x012C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionMaterialXPlus">();
	}
	static class UMaterialExpressionMaterialXPlus* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionMaterialXPlus>();
	}
};
static_assert(alignof(UMaterialExpressionMaterialXPlus) == 0x000008, "Wrong alignment on UMaterialExpressionMaterialXPlus");
static_assert(sizeof(UMaterialExpressionMaterialXPlus) == 0x000130, "Wrong size on UMaterialExpressionMaterialXPlus");
static_assert(offsetof(UMaterialExpressionMaterialXPlus, A) == 0x0000B0, "Member 'UMaterialExpressionMaterialXPlus::A' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionMaterialXPlus, B) == 0x0000D8, "Member 'UMaterialExpressionMaterialXPlus::B' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionMaterialXPlus, Alpha) == 0x000100, "Member 'UMaterialExpressionMaterialXPlus::Alpha' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionMaterialXPlus, ConstAlpha) == 0x000128, "Member 'UMaterialExpressionMaterialXPlus::ConstAlpha' has a wrong offset!");

// Class InterchangeImport.MaterialExpressionMaterialXPremult
// 0x0028 (0x00D8 - 0x00B0)
class UMaterialExpressionMaterialXPremult final : public UMaterialExpression
{
public:
	struct FExpressionInput                       Input;                                             // 0x00B0(0x0028)(NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionMaterialXPremult">();
	}
	static class UMaterialExpressionMaterialXPremult* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionMaterialXPremult>();
	}
};
static_assert(alignof(UMaterialExpressionMaterialXPremult) == 0x000008, "Wrong alignment on UMaterialExpressionMaterialXPremult");
static_assert(sizeof(UMaterialExpressionMaterialXPremult) == 0x0000D8, "Wrong size on UMaterialExpressionMaterialXPremult");
static_assert(offsetof(UMaterialExpressionMaterialXPremult, Input) == 0x0000B0, "Member 'UMaterialExpressionMaterialXPremult::Input' has a wrong offset!");

// Class InterchangeImport.MaterialExpressionMaterialXRampLeftRight
// 0x0080 (0x0130 - 0x00B0)
class UMaterialExpressionMaterialXRampLeftRight final : public UMaterialExpression
{
public:
	struct FExpressionInput                       Coordinates;                                       // 0x00B0(0x0028)(NoDestructor, NativeAccessSpecifierPublic)
	struct FExpressionInput                       A;                                                 // 0x00D8(0x0028)(NoDestructor, NativeAccessSpecifierPublic)
	struct FExpressionInput                       B;                                                 // 0x0100(0x0028)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         ConstCoordinate;                                   // 0x0128(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3131[0x7];                                     // 0x0129(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionMaterialXRampLeftRight">();
	}
	static class UMaterialExpressionMaterialXRampLeftRight* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionMaterialXRampLeftRight>();
	}
};
static_assert(alignof(UMaterialExpressionMaterialXRampLeftRight) == 0x000008, "Wrong alignment on UMaterialExpressionMaterialXRampLeftRight");
static_assert(sizeof(UMaterialExpressionMaterialXRampLeftRight) == 0x000130, "Wrong size on UMaterialExpressionMaterialXRampLeftRight");
static_assert(offsetof(UMaterialExpressionMaterialXRampLeftRight, Coordinates) == 0x0000B0, "Member 'UMaterialExpressionMaterialXRampLeftRight::Coordinates' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionMaterialXRampLeftRight, A) == 0x0000D8, "Member 'UMaterialExpressionMaterialXRampLeftRight::A' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionMaterialXRampLeftRight, B) == 0x000100, "Member 'UMaterialExpressionMaterialXRampLeftRight::B' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionMaterialXRampLeftRight, ConstCoordinate) == 0x000128, "Member 'UMaterialExpressionMaterialXRampLeftRight::ConstCoordinate' has a wrong offset!");

// Class InterchangeImport.MaterialExpressionMaterialXRampTopBottom
// 0x0080 (0x0130 - 0x00B0)
class UMaterialExpressionMaterialXRampTopBottom final : public UMaterialExpression
{
public:
	struct FExpressionInput                       Coordinates;                                       // 0x00B0(0x0028)(NoDestructor, NativeAccessSpecifierPublic)
	struct FExpressionInput                       A;                                                 // 0x00D8(0x0028)(NoDestructor, NativeAccessSpecifierPublic)
	struct FExpressionInput                       B;                                                 // 0x0100(0x0028)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         ConstCoordinate;                                   // 0x0128(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3132[0x7];                                     // 0x0129(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionMaterialXRampTopBottom">();
	}
	static class UMaterialExpressionMaterialXRampTopBottom* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionMaterialXRampTopBottom>();
	}
};
static_assert(alignof(UMaterialExpressionMaterialXRampTopBottom) == 0x000008, "Wrong alignment on UMaterialExpressionMaterialXRampTopBottom");
static_assert(sizeof(UMaterialExpressionMaterialXRampTopBottom) == 0x000130, "Wrong size on UMaterialExpressionMaterialXRampTopBottom");
static_assert(offsetof(UMaterialExpressionMaterialXRampTopBottom, Coordinates) == 0x0000B0, "Member 'UMaterialExpressionMaterialXRampTopBottom::Coordinates' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionMaterialXRampTopBottom, A) == 0x0000D8, "Member 'UMaterialExpressionMaterialXRampTopBottom::A' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionMaterialXRampTopBottom, B) == 0x000100, "Member 'UMaterialExpressionMaterialXRampTopBottom::B' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionMaterialXRampTopBottom, ConstCoordinate) == 0x000128, "Member 'UMaterialExpressionMaterialXRampTopBottom::ConstCoordinate' has a wrong offset!");

// Class InterchangeImport.MaterialExpressionMaterialXRemap
// 0x00D8 (0x0188 - 0x00B0)
class UMaterialExpressionMaterialXRemap final : public UMaterialExpression
{
public:
	struct FExpressionInput                       Input;                                             // 0x00B0(0x0028)(NoDestructor, NativeAccessSpecifierPublic)
	struct FExpressionInput                       InputLow;                                          // 0x00D8(0x0028)(NoDestructor, NativeAccessSpecifierPublic)
	struct FExpressionInput                       InputHigh;                                         // 0x0100(0x0028)(NoDestructor, NativeAccessSpecifierPublic)
	struct FExpressionInput                       TargetLow;                                         // 0x0128(0x0028)(NoDestructor, NativeAccessSpecifierPublic)
	struct FExpressionInput                       TargetHigh;                                        // 0x0150(0x0028)(NoDestructor, NativeAccessSpecifierPublic)
	float                                         InputLowDefault;                                   // 0x0178(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InputHighDefault;                                  // 0x017C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetLowDefault;                                  // 0x0180(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetHighDefault;                                 // 0x0184(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionMaterialXRemap">();
	}
	static class UMaterialExpressionMaterialXRemap* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionMaterialXRemap>();
	}
};
static_assert(alignof(UMaterialExpressionMaterialXRemap) == 0x000008, "Wrong alignment on UMaterialExpressionMaterialXRemap");
static_assert(sizeof(UMaterialExpressionMaterialXRemap) == 0x000188, "Wrong size on UMaterialExpressionMaterialXRemap");
static_assert(offsetof(UMaterialExpressionMaterialXRemap, Input) == 0x0000B0, "Member 'UMaterialExpressionMaterialXRemap::Input' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionMaterialXRemap, InputLow) == 0x0000D8, "Member 'UMaterialExpressionMaterialXRemap::InputLow' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionMaterialXRemap, InputHigh) == 0x000100, "Member 'UMaterialExpressionMaterialXRemap::InputHigh' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionMaterialXRemap, TargetLow) == 0x000128, "Member 'UMaterialExpressionMaterialXRemap::TargetLow' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionMaterialXRemap, TargetHigh) == 0x000150, "Member 'UMaterialExpressionMaterialXRemap::TargetHigh' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionMaterialXRemap, InputLowDefault) == 0x000178, "Member 'UMaterialExpressionMaterialXRemap::InputLowDefault' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionMaterialXRemap, InputHighDefault) == 0x00017C, "Member 'UMaterialExpressionMaterialXRemap::InputHighDefault' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionMaterialXRemap, TargetLowDefault) == 0x000180, "Member 'UMaterialExpressionMaterialXRemap::TargetLowDefault' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionMaterialXRemap, TargetHighDefault) == 0x000184, "Member 'UMaterialExpressionMaterialXRemap::TargetHighDefault' has a wrong offset!");

// Class InterchangeImport.MaterialExpressionMaterialXRotate2D
// 0x0058 (0x0108 - 0x00B0)
class UMaterialExpressionMaterialXRotate2D final : public UMaterialExpression
{
public:
	struct FExpressionInput                       Input;                                             // 0x00B0(0x0028)(NoDestructor, NativeAccessSpecifierPublic)
	struct FExpressionInput                       RotationAngle;                                     // 0x00D8(0x0028)(NoDestructor, NativeAccessSpecifierPublic)
	float                                         ConstRotationAngle;                                // 0x0100(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3133[0x4];                                     // 0x0104(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionMaterialXRotate2D">();
	}
	static class UMaterialExpressionMaterialXRotate2D* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionMaterialXRotate2D>();
	}
};
static_assert(alignof(UMaterialExpressionMaterialXRotate2D) == 0x000008, "Wrong alignment on UMaterialExpressionMaterialXRotate2D");
static_assert(sizeof(UMaterialExpressionMaterialXRotate2D) == 0x000108, "Wrong size on UMaterialExpressionMaterialXRotate2D");
static_assert(offsetof(UMaterialExpressionMaterialXRotate2D, Input) == 0x0000B0, "Member 'UMaterialExpressionMaterialXRotate2D::Input' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionMaterialXRotate2D, RotationAngle) == 0x0000D8, "Member 'UMaterialExpressionMaterialXRotate2D::RotationAngle' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionMaterialXRotate2D, ConstRotationAngle) == 0x000100, "Member 'UMaterialExpressionMaterialXRotate2D::ConstRotationAngle' has a wrong offset!");

// Class InterchangeImport.MaterialExpressionMaterialXScreen
// 0x0080 (0x0130 - 0x00B0)
class UMaterialExpressionMaterialXScreen final : public UMaterialExpression
{
public:
	struct FExpressionInput                       A;                                                 // 0x00B0(0x0028)(NoDestructor, NativeAccessSpecifierPublic)
	struct FExpressionInput                       B;                                                 // 0x00D8(0x0028)(NoDestructor, NativeAccessSpecifierPublic)
	struct FExpressionInput                       Alpha;                                             // 0x0100(0x0028)(NoDestructor, NativeAccessSpecifierPublic)
	float                                         ConstAlpha;                                        // 0x0128(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3134[0x4];                                     // 0x012C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionMaterialXScreen">();
	}
	static class UMaterialExpressionMaterialXScreen* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionMaterialXScreen>();
	}
};
static_assert(alignof(UMaterialExpressionMaterialXScreen) == 0x000008, "Wrong alignment on UMaterialExpressionMaterialXScreen");
static_assert(sizeof(UMaterialExpressionMaterialXScreen) == 0x000130, "Wrong size on UMaterialExpressionMaterialXScreen");
static_assert(offsetof(UMaterialExpressionMaterialXScreen, A) == 0x0000B0, "Member 'UMaterialExpressionMaterialXScreen::A' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionMaterialXScreen, B) == 0x0000D8, "Member 'UMaterialExpressionMaterialXScreen::B' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionMaterialXScreen, Alpha) == 0x000100, "Member 'UMaterialExpressionMaterialXScreen::Alpha' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionMaterialXScreen, ConstAlpha) == 0x000128, "Member 'UMaterialExpressionMaterialXScreen::ConstAlpha' has a wrong offset!");

// Class InterchangeImport.MaterialExpressionMaterialXSplitLeftRight
// 0x00A8 (0x0158 - 0x00B0)
class UMaterialExpressionMaterialXSplitLeftRight final : public UMaterialExpression
{
public:
	struct FExpressionInput                       Coordinates;                                       // 0x00B0(0x0028)(NoDestructor, NativeAccessSpecifierPublic)
	struct FExpressionInput                       A;                                                 // 0x00D8(0x0028)(NoDestructor, NativeAccessSpecifierPublic)
	struct FExpressionInput                       B;                                                 // 0x0100(0x0028)(NoDestructor, NativeAccessSpecifierPublic)
	struct FExpressionInput                       Center;                                            // 0x0128(0x0028)(NoDestructor, NativeAccessSpecifierPublic)
	float                                         ConstCenter;                                       // 0x0150(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         ConstCoordinate;                                   // 0x0154(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3135[0x3];                                     // 0x0155(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionMaterialXSplitLeftRight">();
	}
	static class UMaterialExpressionMaterialXSplitLeftRight* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionMaterialXSplitLeftRight>();
	}
};
static_assert(alignof(UMaterialExpressionMaterialXSplitLeftRight) == 0x000008, "Wrong alignment on UMaterialExpressionMaterialXSplitLeftRight");
static_assert(sizeof(UMaterialExpressionMaterialXSplitLeftRight) == 0x000158, "Wrong size on UMaterialExpressionMaterialXSplitLeftRight");
static_assert(offsetof(UMaterialExpressionMaterialXSplitLeftRight, Coordinates) == 0x0000B0, "Member 'UMaterialExpressionMaterialXSplitLeftRight::Coordinates' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionMaterialXSplitLeftRight, A) == 0x0000D8, "Member 'UMaterialExpressionMaterialXSplitLeftRight::A' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionMaterialXSplitLeftRight, B) == 0x000100, "Member 'UMaterialExpressionMaterialXSplitLeftRight::B' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionMaterialXSplitLeftRight, Center) == 0x000128, "Member 'UMaterialExpressionMaterialXSplitLeftRight::Center' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionMaterialXSplitLeftRight, ConstCenter) == 0x000150, "Member 'UMaterialExpressionMaterialXSplitLeftRight::ConstCenter' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionMaterialXSplitLeftRight, ConstCoordinate) == 0x000154, "Member 'UMaterialExpressionMaterialXSplitLeftRight::ConstCoordinate' has a wrong offset!");

// Class InterchangeImport.MaterialExpressionMaterialXSplitTopBottom
// 0x00A8 (0x0158 - 0x00B0)
class UMaterialExpressionMaterialXSplitTopBottom final : public UMaterialExpression
{
public:
	struct FExpressionInput                       Coordinates;                                       // 0x00B0(0x0028)(NoDestructor, NativeAccessSpecifierPublic)
	struct FExpressionInput                       A;                                                 // 0x00D8(0x0028)(NoDestructor, NativeAccessSpecifierPublic)
	struct FExpressionInput                       B;                                                 // 0x0100(0x0028)(NoDestructor, NativeAccessSpecifierPublic)
	struct FExpressionInput                       Center;                                            // 0x0128(0x0028)(NoDestructor, NativeAccessSpecifierPublic)
	float                                         ConstCenter;                                       // 0x0150(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         ConstCoordinate;                                   // 0x0154(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3136[0x3];                                     // 0x0155(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionMaterialXSplitTopBottom">();
	}
	static class UMaterialExpressionMaterialXSplitTopBottom* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionMaterialXSplitTopBottom>();
	}
};
static_assert(alignof(UMaterialExpressionMaterialXSplitTopBottom) == 0x000008, "Wrong alignment on UMaterialExpressionMaterialXSplitTopBottom");
static_assert(sizeof(UMaterialExpressionMaterialXSplitTopBottom) == 0x000158, "Wrong size on UMaterialExpressionMaterialXSplitTopBottom");
static_assert(offsetof(UMaterialExpressionMaterialXSplitTopBottom, Coordinates) == 0x0000B0, "Member 'UMaterialExpressionMaterialXSplitTopBottom::Coordinates' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionMaterialXSplitTopBottom, A) == 0x0000D8, "Member 'UMaterialExpressionMaterialXSplitTopBottom::A' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionMaterialXSplitTopBottom, B) == 0x000100, "Member 'UMaterialExpressionMaterialXSplitTopBottom::B' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionMaterialXSplitTopBottom, Center) == 0x000128, "Member 'UMaterialExpressionMaterialXSplitTopBottom::Center' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionMaterialXSplitTopBottom, ConstCenter) == 0x000150, "Member 'UMaterialExpressionMaterialXSplitTopBottom::ConstCenter' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionMaterialXSplitTopBottom, ConstCoordinate) == 0x000154, "Member 'UMaterialExpressionMaterialXSplitTopBottom::ConstCoordinate' has a wrong offset!");

// Class InterchangeImport.MaterialExpressionMaterialXSwizzle
// 0x0038 (0x00E8 - 0x00B0)
class UMaterialExpressionMaterialXSwizzle final : public UMaterialExpression
{
public:
	struct FExpressionInput                       Input;                                             // 0x00B0(0x0028)(NoDestructor, NativeAccessSpecifierPublic)
	class FString                                 Channels;                                          // 0x00D8(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionMaterialXSwizzle">();
	}
	static class UMaterialExpressionMaterialXSwizzle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionMaterialXSwizzle>();
	}
};
static_assert(alignof(UMaterialExpressionMaterialXSwizzle) == 0x000008, "Wrong alignment on UMaterialExpressionMaterialXSwizzle");
static_assert(sizeof(UMaterialExpressionMaterialXSwizzle) == 0x0000E8, "Wrong size on UMaterialExpressionMaterialXSwizzle");
static_assert(offsetof(UMaterialExpressionMaterialXSwizzle, Input) == 0x0000B0, "Member 'UMaterialExpressionMaterialXSwizzle::Input' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionMaterialXSwizzle, Channels) == 0x0000D8, "Member 'UMaterialExpressionMaterialXSwizzle::Channels' has a wrong offset!");

// Class InterchangeImport.MaterialExpressionMaterialXTextureSampleParameterBlur
// 0x0010 (0x0250 - 0x0240)
class UMaterialExpressionMaterialXTextureSampleParameterBlur final : public UMaterialExpressionTextureSampleParameter2D
{
public:
	EMAterialXTextureSampleBlurKernel             KernelSize;                                        // 0x0240(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FilterSize;                                        // 0x0244(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FilterOffset;                                      // 0x0248(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMaterialXTextureSampleBlurFilter             Filter;                                            // 0x024C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3137[0x3];                                     // 0x024D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionMaterialXTextureSampleParameterBlur">();
	}
	static class UMaterialExpressionMaterialXTextureSampleParameterBlur* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionMaterialXTextureSampleParameterBlur>();
	}
};
static_assert(alignof(UMaterialExpressionMaterialXTextureSampleParameterBlur) == 0x000008, "Wrong alignment on UMaterialExpressionMaterialXTextureSampleParameterBlur");
static_assert(sizeof(UMaterialExpressionMaterialXTextureSampleParameterBlur) == 0x000250, "Wrong size on UMaterialExpressionMaterialXTextureSampleParameterBlur");
static_assert(offsetof(UMaterialExpressionMaterialXTextureSampleParameterBlur, KernelSize) == 0x000240, "Member 'UMaterialExpressionMaterialXTextureSampleParameterBlur::KernelSize' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionMaterialXTextureSampleParameterBlur, FilterSize) == 0x000244, "Member 'UMaterialExpressionMaterialXTextureSampleParameterBlur::FilterSize' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionMaterialXTextureSampleParameterBlur, FilterOffset) == 0x000248, "Member 'UMaterialExpressionMaterialXTextureSampleParameterBlur::FilterOffset' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionMaterialXTextureSampleParameterBlur, Filter) == 0x00024C, "Member 'UMaterialExpressionMaterialXTextureSampleParameterBlur::Filter' has a wrong offset!");

// Class InterchangeImport.MaterialExpressionMaterialXUnpremult
// 0x0028 (0x00D8 - 0x00B0)
class UMaterialExpressionMaterialXUnpremult final : public UMaterialExpression
{
public:
	struct FExpressionInput                       Input;                                             // 0x00B0(0x0028)(NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionMaterialXUnpremult">();
	}
	static class UMaterialExpressionMaterialXUnpremult* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionMaterialXUnpremult>();
	}
};
static_assert(alignof(UMaterialExpressionMaterialXUnpremult) == 0x000008, "Wrong alignment on UMaterialExpressionMaterialXUnpremult");
static_assert(sizeof(UMaterialExpressionMaterialXUnpremult) == 0x0000D8, "Wrong size on UMaterialExpressionMaterialXUnpremult");
static_assert(offsetof(UMaterialExpressionMaterialXUnpremult, Input) == 0x0000B0, "Member 'UMaterialExpressionMaterialXUnpremult::Input' has a wrong offset!");

// Class InterchangeImport.InterchangeMaterialFactory
// 0x0008 (0x0038 - 0x0030)
class UInterchangeMaterialFactory final : public UInterchangeFactoryBase
{
public:
	uint8                                         Pad_3138[0x8];                                     // 0x0030(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InterchangeMaterialFactory">();
	}
	static class UInterchangeMaterialFactory* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInterchangeMaterialFactory>();
	}
};
static_assert(alignof(UInterchangeMaterialFactory) == 0x000008, "Wrong alignment on UInterchangeMaterialFactory");
static_assert(sizeof(UInterchangeMaterialFactory) == 0x000038, "Wrong size on UInterchangeMaterialFactory");

// Class InterchangeImport.InterchangeMaterialFunctionFactory
// 0x0008 (0x0038 - 0x0030)
class UInterchangeMaterialFunctionFactory final : public UInterchangeFactoryBase
{
public:
	uint8                                         Pad_3139[0x8];                                     // 0x0030(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InterchangeMaterialFunctionFactory">();
	}
	static class UInterchangeMaterialFunctionFactory* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInterchangeMaterialFunctionFactory>();
	}
};
static_assert(alignof(UInterchangeMaterialFunctionFactory) == 0x000008, "Wrong alignment on UInterchangeMaterialFunctionFactory");
static_assert(sizeof(UInterchangeMaterialFunctionFactory) == 0x000038, "Wrong size on UInterchangeMaterialFunctionFactory");

// Class InterchangeImport.InterchangeOBJTranslator
// 0x0018 (0x0050 - 0x0038)
class UInterchangeOBJTranslator final : public UInterchangeTranslatorBase
{
public:
	uint8                                         Pad_313A[0x18];                                    // 0x0038(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InterchangeOBJTranslator">();
	}
	static class UInterchangeOBJTranslator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInterchangeOBJTranslator>();
	}
};
static_assert(alignof(UInterchangeOBJTranslator) == 0x000008, "Wrong alignment on UInterchangeOBJTranslator");
static_assert(sizeof(UInterchangeOBJTranslator) == 0x000050, "Wrong size on UInterchangeOBJTranslator");

// Class InterchangeImport.InterchangePhysicsAssetFactory
// 0x0000 (0x0030 - 0x0030)
class UInterchangePhysicsAssetFactory final : public UInterchangeFactoryBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InterchangePhysicsAssetFactory">();
	}
	static class UInterchangePhysicsAssetFactory* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInterchangePhysicsAssetFactory>();
	}
};
static_assert(alignof(UInterchangePhysicsAssetFactory) == 0x000008, "Wrong alignment on UInterchangePhysicsAssetFactory");
static_assert(sizeof(UInterchangePhysicsAssetFactory) == 0x000030, "Wrong size on UInterchangePhysicsAssetFactory");

// Class InterchangeImport.InterchangeSkeletalMeshFactory
// 0x0030 (0x0060 - 0x0030)
class UInterchangeSkeletalMeshFactory final : public UInterchangeFactoryBase
{
public:
	uint8                                         Pad_313B[0x30];                                    // 0x0030(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InterchangeSkeletalMeshFactory">();
	}
	static class UInterchangeSkeletalMeshFactory* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInterchangeSkeletalMeshFactory>();
	}
};
static_assert(alignof(UInterchangeSkeletalMeshFactory) == 0x000008, "Wrong alignment on UInterchangeSkeletalMeshFactory");
static_assert(sizeof(UInterchangeSkeletalMeshFactory) == 0x000060, "Wrong size on UInterchangeSkeletalMeshFactory");

// Class InterchangeImport.InterchangeSkeletonFactory
// 0x0000 (0x0030 - 0x0030)
class UInterchangeSkeletonFactory final : public UInterchangeFactoryBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InterchangeSkeletonFactory">();
	}
	static class UInterchangeSkeletonFactory* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInterchangeSkeletonFactory>();
	}
};
static_assert(alignof(UInterchangeSkeletonFactory) == 0x000008, "Wrong alignment on UInterchangeSkeletonFactory");
static_assert(sizeof(UInterchangeSkeletonFactory) == 0x000030, "Wrong size on UInterchangeSkeletonFactory");

// Class InterchangeImport.InterchangeStaticMeshFactory
// 0x0018 (0x0048 - 0x0030)
class UInterchangeStaticMeshFactory final : public UInterchangeFactoryBase
{
public:
	uint8                                         Pad_313C[0x18];                                    // 0x0030(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InterchangeStaticMeshFactory">();
	}
	static class UInterchangeStaticMeshFactory* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInterchangeStaticMeshFactory>();
	}
};
static_assert(alignof(UInterchangeStaticMeshFactory) == 0x000008, "Wrong alignment on UInterchangeStaticMeshFactory");
static_assert(sizeof(UInterchangeStaticMeshFactory) == 0x000048, "Wrong size on UInterchangeStaticMeshFactory");

// Class InterchangeImport.InterchangeCineCameraActorFactory
// 0x0000 (0x0030 - 0x0030)
class UInterchangeCineCameraActorFactory final : public UInterchangeActorFactory
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InterchangeCineCameraActorFactory">();
	}
	static class UInterchangeCineCameraActorFactory* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInterchangeCineCameraActorFactory>();
	}
};
static_assert(alignof(UInterchangeCineCameraActorFactory) == 0x000008, "Wrong alignment on UInterchangeCineCameraActorFactory");
static_assert(sizeof(UInterchangeCineCameraActorFactory) == 0x000030, "Wrong size on UInterchangeCineCameraActorFactory");

// Class InterchangeImport.InterchangeCameraActorFactory
// 0x0000 (0x0030 - 0x0030)
class UInterchangeCameraActorFactory final : public UInterchangeActorFactory
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InterchangeCameraActorFactory">();
	}
	static class UInterchangeCameraActorFactory* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInterchangeCameraActorFactory>();
	}
};
static_assert(alignof(UInterchangeCameraActorFactory) == 0x000008, "Wrong alignment on UInterchangeCameraActorFactory");
static_assert(sizeof(UInterchangeCameraActorFactory) == 0x000030, "Wrong size on UInterchangeCameraActorFactory");

// Class InterchangeImport.InterchangeSkeletalMeshActorFactory
// 0x0000 (0x0030 - 0x0030)
class UInterchangeSkeletalMeshActorFactory final : public UInterchangeActorFactory
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InterchangeSkeletalMeshActorFactory">();
	}
	static class UInterchangeSkeletalMeshActorFactory* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInterchangeSkeletalMeshActorFactory>();
	}
};
static_assert(alignof(UInterchangeSkeletalMeshActorFactory) == 0x000008, "Wrong alignment on UInterchangeSkeletalMeshActorFactory");
static_assert(sizeof(UInterchangeSkeletalMeshActorFactory) == 0x000030, "Wrong size on UInterchangeSkeletalMeshActorFactory");

// Class InterchangeImport.InterchangeStaticMeshActorFactory
// 0x0000 (0x0030 - 0x0030)
class UInterchangeStaticMeshActorFactory final : public UInterchangeActorFactory
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InterchangeStaticMeshActorFactory">();
	}
	static class UInterchangeStaticMeshActorFactory* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInterchangeStaticMeshActorFactory>();
	}
};
static_assert(alignof(UInterchangeStaticMeshActorFactory) == 0x000008, "Wrong alignment on UInterchangeStaticMeshActorFactory");
static_assert(sizeof(UInterchangeStaticMeshActorFactory) == 0x000030, "Wrong size on UInterchangeStaticMeshActorFactory");

// Class InterchangeImport.InterchangeDDSTranslator
// 0x0010 (0x0048 - 0x0038)
class UInterchangeDDSTranslator final : public UInterchangeTranslatorBase
{
public:
	uint8                                         Pad_313D[0x10];                                    // 0x0038(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InterchangeDDSTranslator">();
	}
	static class UInterchangeDDSTranslator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInterchangeDDSTranslator>();
	}
};
static_assert(alignof(UInterchangeDDSTranslator) == 0x000008, "Wrong alignment on UInterchangeDDSTranslator");
static_assert(sizeof(UInterchangeDDSTranslator) == 0x000048, "Wrong size on UInterchangeDDSTranslator");

// Class InterchangeImport.InterchangeIESTranslator
// 0x0008 (0x0040 - 0x0038)
class UInterchangeIESTranslator final : public UInterchangeTranslatorBase
{
public:
	uint8                                         Pad_313E[0x8];                                     // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InterchangeIESTranslator">();
	}
	static class UInterchangeIESTranslator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInterchangeIESTranslator>();
	}
};
static_assert(alignof(UInterchangeIESTranslator) == 0x000008, "Wrong alignment on UInterchangeIESTranslator");
static_assert(sizeof(UInterchangeIESTranslator) == 0x000040, "Wrong size on UInterchangeIESTranslator");

// Class InterchangeImport.InterchangeImageWrapperTranslator
// 0x0010 (0x0048 - 0x0038)
class UInterchangeImageWrapperTranslator final : public UInterchangeTranslatorBase
{
public:
	uint8                                         Pad_313F[0x10];                                    // 0x0038(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InterchangeImageWrapperTranslator">();
	}
	static class UInterchangeImageWrapperTranslator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInterchangeImageWrapperTranslator>();
	}
};
static_assert(alignof(UInterchangeImageWrapperTranslator) == 0x000008, "Wrong alignment on UInterchangeImageWrapperTranslator");
static_assert(sizeof(UInterchangeImageWrapperTranslator) == 0x000048, "Wrong size on UInterchangeImageWrapperTranslator");

// Class InterchangeImport.InterchangeJPGTranslator
// 0x0008 (0x0040 - 0x0038)
class UInterchangeJPGTranslator final : public UInterchangeTranslatorBase
{
public:
	uint8                                         Pad_3140[0x8];                                     // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InterchangeJPGTranslator">();
	}
	static class UInterchangeJPGTranslator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInterchangeJPGTranslator>();
	}
};
static_assert(alignof(UInterchangeJPGTranslator) == 0x000008, "Wrong alignment on UInterchangeJPGTranslator");
static_assert(sizeof(UInterchangeJPGTranslator) == 0x000040, "Wrong size on UInterchangeJPGTranslator");

// Class InterchangeImport.InterchangePCXTranslator
// 0x0008 (0x0040 - 0x0038)
class UInterchangePCXTranslator final : public UInterchangeTranslatorBase
{
public:
	uint8                                         Pad_3141[0x8];                                     // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InterchangePCXTranslator">();
	}
	static class UInterchangePCXTranslator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInterchangePCXTranslator>();
	}
};
static_assert(alignof(UInterchangePCXTranslator) == 0x000008, "Wrong alignment on UInterchangePCXTranslator");
static_assert(sizeof(UInterchangePCXTranslator) == 0x000040, "Wrong size on UInterchangePCXTranslator");

// Class InterchangeImport.InterchangePSDTranslator
// 0x0008 (0x0040 - 0x0038)
class UInterchangePSDTranslator final : public UInterchangeTranslatorBase
{
public:
	uint8                                         Pad_3142[0x8];                                     // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InterchangePSDTranslator">();
	}
	static class UInterchangePSDTranslator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInterchangePSDTranslator>();
	}
};
static_assert(alignof(UInterchangePSDTranslator) == 0x000008, "Wrong alignment on UInterchangePSDTranslator");
static_assert(sizeof(UInterchangePSDTranslator) == 0x000040, "Wrong size on UInterchangePSDTranslator");

// Class InterchangeImport.InterchangeTextureFactory
// 0x0090 (0x00C0 - 0x0030)
class UInterchangeTextureFactory final : public UInterchangeFactoryBase
{
public:
	uint8                                         Pad_3143[0x90];                                    // 0x0030(0x0090)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InterchangeTextureFactory">();
	}
	static class UInterchangeTextureFactory* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInterchangeTextureFactory>();
	}
};
static_assert(alignof(UInterchangeTextureFactory) == 0x000008, "Wrong alignment on UInterchangeTextureFactory");
static_assert(sizeof(UInterchangeTextureFactory) == 0x0000C0, "Wrong size on UInterchangeTextureFactory");

}

