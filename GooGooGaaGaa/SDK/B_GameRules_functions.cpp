#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: B_GameRules

#include "Basic.hpp"

#include "B_GameRules_classes.hpp"
#include "B_GameRules_parameters.hpp"


namespace SDK
{

// Function B_GameRules.B_GameRules_C.AddGameModifier
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FS_GameModifier                  NewModifier                                            (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)

void UB_GameRules_C::AddGameModifier(const struct FS_GameModifier& NewModifier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_GameRules_C", "AddGameModifier");

	Params::B_GameRules_C_AddGameModifier Parms{};

	Parms.NewModifier = std::move(NewModifier);

	UObject::ProcessEvent(Func, &Parms);
}


// Function B_GameRules.B_GameRules_C.AddPowerupRule
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FS_PowerupRules                  NewPowerupRules                                        (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)

void UB_GameRules_C::AddPowerupRule(const struct FS_PowerupRules& NewPowerupRules)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_GameRules_C", "AddPowerupRule");

	Params::B_GameRules_C_AddPowerupRule Parms{};

	Parms.NewPowerupRules = std::move(NewPowerupRules);

	UObject::ProcessEvent(Func, &Parms);
}


// Function B_GameRules.B_GameRules_C.AddSkillRule
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FS_SkillRules                    NewSkillRule                                           (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)

void UB_GameRules_C::AddSkillRule(const struct FS_SkillRules& NewSkillRule)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_GameRules_C", "AddSkillRule");

	Params::B_GameRules_C_AddSkillRule Parms{};

	Parms.NewSkillRule = std::move(NewSkillRule);

	UObject::ProcessEvent(Func, &Parms);
}


// Function B_GameRules.B_GameRules_C.AreAnyRulesActive
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    RulesActive                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UB_GameRules_C::AreAnyRulesActive(bool* RulesActive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_GameRules_C", "AreAnyRulesActive");

	Params::B_GameRules_C_AreAnyRulesActive Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (RulesActive != nullptr)
		*RulesActive = Parms.RulesActive;
}


// Function B_GameRules.B_GameRules_C.DoesGameModifierExist
// (Private, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// E_GameModifierType                      ModType                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    ModExists                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   ModIndex                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UB_GameRules_C::DoesGameModifierExist(E_GameModifierType ModType, bool* ModExists, int32* ModIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_GameRules_C", "DoesGameModifierExist");

	Params::B_GameRules_C_DoesGameModifierExist Parms{};

	Parms.ModType = ModType;

	UObject::ProcessEvent(Func, &Parms);

	if (ModExists != nullptr)
		*ModExists = Parms.ModExists;

	if (ModIndex != nullptr)
		*ModIndex = Parms.ModIndex;
}


// Function B_GameRules.B_GameRules_C.DoesPowerupRuleExist
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// E_PowerupRuleType                       Powerup                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    PowerupExists                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   PowerupIndex                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UB_GameRules_C::DoesPowerupRuleExist(E_PowerupRuleType Powerup, bool* PowerupExists, int32* PowerupIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_GameRules_C", "DoesPowerupRuleExist");

	Params::B_GameRules_C_DoesPowerupRuleExist Parms{};

	Parms.Powerup = Powerup;

	UObject::ProcessEvent(Func, &Parms);

	if (PowerupExists != nullptr)
		*PowerupExists = Parms.PowerupExists;

	if (PowerupIndex != nullptr)
		*PowerupIndex = Parms.PowerupIndex;
}


// Function B_GameRules.B_GameRules_C.DoesSkillRuleExist
// (Private, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// E_SkillRuleType                         SkillType                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    RuleExists                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   RuleIndex                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UB_GameRules_C::DoesSkillRuleExist(E_SkillRuleType SkillType, bool* RuleExists, int32* RuleIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_GameRules_C", "DoesSkillRuleExist");

	Params::B_GameRules_C_DoesSkillRuleExist Parms{};

	Parms.SkillType = SkillType;

	UObject::ProcessEvent(Func, &Parms);

	if (RuleExists != nullptr)
		*RuleExists = Parms.RuleExists;

	if (RuleIndex != nullptr)
		*RuleIndex = Parms.RuleIndex;
}


// Function B_GameRules.B_GameRules_C.RemoveGameModifier
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// E_GameModifierType                      ModType                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UB_GameRules_C::RemoveGameModifier(E_GameModifierType ModType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_GameRules_C", "RemoveGameModifier");

	Params::B_GameRules_C_RemoveGameModifier Parms{};

	Parms.ModType = ModType;

	UObject::ProcessEvent(Func, &Parms);
}


// Function B_GameRules.B_GameRules_C.RemovePowerupRule
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// E_PowerupRuleType                       Powerup                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UB_GameRules_C::RemovePowerupRule(E_PowerupRuleType Powerup)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_GameRules_C", "RemovePowerupRule");

	Params::B_GameRules_C_RemovePowerupRule Parms{};

	Parms.Powerup = Powerup;

	UObject::ProcessEvent(Func, &Parms);
}


// Function B_GameRules.B_GameRules_C.RemoveSkillRule
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// E_SkillRuleType                         SkillType                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UB_GameRules_C::RemoveSkillRule(E_SkillRuleType SkillType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_GameRules_C", "RemoveSkillRule");

	Params::B_GameRules_C_RemoveSkillRule Parms{};

	Parms.SkillType = SkillType;

	UObject::ProcessEvent(Func, &Parms);
}


// Function B_GameRules.B_GameRules_C.ResetAll
// (Public, BlueprintCallable, BlueprintEvent)

void UB_GameRules_C::ResetAll()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_GameRules_C", "ResetAll");

	UObject::ProcessEvent(Func, nullptr);
}


// Function B_GameRules.B_GameRules_C.Save
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FString                           Param_Name                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, HasGetValueTypeHash)

void UB_GameRules_C::Save(const class FString& Param_Name)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_GameRules_C", "Save");

	Params::B_GameRules_C_Save Parms{};

	Parms.Param_Name = std::move(Param_Name);

	UObject::ProcessEvent(Func, &Parms);
}

}

