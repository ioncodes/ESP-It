#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: B_ObjectiveMatchManager

#include "Basic.hpp"

#include "E_ObjectiveTeam_structs.hpp"
#include "PropWitchHuntModule_classes.hpp"
#include "ETeamID_structs.hpp"


namespace SDK
{

// BlueprintGeneratedClass B_ObjectiveMatchManager.B_ObjectiveMatchManager_C
// 0x00D0 (0x0100 - 0x0030)
class UB_ObjectiveMatchManager_C final : public UBaseManager
{
public:
	TMap<class FString, class UB_ObjectiveMatchPlayerState_C*> Players;                                           // 0x0030(0x0050)(Edit, BlueprintVisible, DisableEditOnInstance)
	int32                                         CurrentRound;                                      // 0x0080(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	int32                                         RequiredPlayersPerTeam;                            // 0x0084(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          IgnorePlayersPerTeamRequirement;                   // 0x0088(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          IsMatchOver;                                       // 0x0089(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_5D57[0x6];                                     // 0x008A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<E_ObjectiveTeam, int32>                  TeamWins;                                          // 0x0090(0x0050)(Edit, BlueprintVisible, DisableEditOnInstance)
	bool                                          TeamAStartsAsWitch;                                // 0x00E0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_5D58[0x7];                                     // 0x00E1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UB_ObjectiveRoundState_C*>       RoundStates;                                       // 0x00E8(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance)
	E_ObjectiveTeam                               SurrenderedTeam;                                   // 0x00F8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

public:
	void AddPlayerWithId(const class FString& PlayerId, class UB_ObjectiveMatchPlayerState_C** ObjectiveMatchPlayerState);
	void AddRoundState(class UB_ObjectiveRoundState_C* RoundState);
	void AddTeamWin(E_ObjectiveTeam Team);
	void CanTeamSurrender(ETeamID TeamToSurrender, class AB_GameState_C* GameState, bool* CanSurrender);
	void GetIntactTeam(class AB_GameState_C* GameState, E_ObjectiveTeam* Team);
	void GetObjectiveMatchPlayerState(class APlayerState* PlayerState, class UB_ObjectiveMatchPlayerState_C** ObjectiveMatchPlayerState);
	void GetRoundStatesSortedByTeam(TArray<class UB_ObjectiveRoundState_C*>* RoundStatesSortedByTeam);
	void GetWinnerForRound(bool FirstRound, E_ObjectiveTeam* WinnerTeam);
	void GetWinnerTeam(class AB_GameState_C* GameState, E_ObjectiveTeam* WinnerTeam, int32* ReasonIndex);
	void IsMatchDead(class AB_GameState_C* GameState, bool* Param_IsMatchDead);
	void IsMatchIntact(class AB_GameState_C* GameState, bool* EnoughPlayerConnected);
	void IsPlayerInMatch(class APlayerState* PlayerState, bool* IsInMatch);
	void PrintPlayerIds();
	void RandomizeTeamAStartsAsWitch();
	void RemovePlayer(class APlayerState* PlayerStateToRemove);
	void RemovePlayerWhenMatchNotStarted(class APlayerState* PlayerState);
	void TearDown();

public:
	static class UClass* StaticClass()
	{
		return StaticBPGeneratedClassImpl<"B_ObjectiveMatchManager_C">();
	}
	static class UB_ObjectiveMatchManager_C* GetDefaultObj()
	{
		return GetDefaultObjImpl<UB_ObjectiveMatchManager_C>();
	}
};
static_assert(alignof(UB_ObjectiveMatchManager_C) == 0x000008, "Wrong alignment on UB_ObjectiveMatchManager_C");
static_assert(sizeof(UB_ObjectiveMatchManager_C) == 0x000100, "Wrong size on UB_ObjectiveMatchManager_C");
static_assert(offsetof(UB_ObjectiveMatchManager_C, Players) == 0x000030, "Member 'UB_ObjectiveMatchManager_C::Players' has a wrong offset!");
static_assert(offsetof(UB_ObjectiveMatchManager_C, CurrentRound) == 0x000080, "Member 'UB_ObjectiveMatchManager_C::CurrentRound' has a wrong offset!");
static_assert(offsetof(UB_ObjectiveMatchManager_C, RequiredPlayersPerTeam) == 0x000084, "Member 'UB_ObjectiveMatchManager_C::RequiredPlayersPerTeam' has a wrong offset!");
static_assert(offsetof(UB_ObjectiveMatchManager_C, IgnorePlayersPerTeamRequirement) == 0x000088, "Member 'UB_ObjectiveMatchManager_C::IgnorePlayersPerTeamRequirement' has a wrong offset!");
static_assert(offsetof(UB_ObjectiveMatchManager_C, IsMatchOver) == 0x000089, "Member 'UB_ObjectiveMatchManager_C::IsMatchOver' has a wrong offset!");
static_assert(offsetof(UB_ObjectiveMatchManager_C, TeamWins) == 0x000090, "Member 'UB_ObjectiveMatchManager_C::TeamWins' has a wrong offset!");
static_assert(offsetof(UB_ObjectiveMatchManager_C, TeamAStartsAsWitch) == 0x0000E0, "Member 'UB_ObjectiveMatchManager_C::TeamAStartsAsWitch' has a wrong offset!");
static_assert(offsetof(UB_ObjectiveMatchManager_C, RoundStates) == 0x0000E8, "Member 'UB_ObjectiveMatchManager_C::RoundStates' has a wrong offset!");
static_assert(offsetof(UB_ObjectiveMatchManager_C, SurrenderedTeam) == 0x0000F8, "Member 'UB_ObjectiveMatchManager_C::SurrenderedTeam' has a wrong offset!");

}

