#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: CoreUObject

#include "Basic.hpp"


namespace SDK
{

// Enum CoreUObject.EAutomationEventType
// NumValues: 0x0004
enum class EAutomationEventType : uint8
{
	Info                                     = 0,
	Warning                                  = 1,
	Error                                    = 2,
	EAutomationEventType_MAX                 = 3,
};

// Enum CoreUObject.ERangeBoundTypes
// NumValues: 0x0004
enum class ERangeBoundTypes : uint8
{
	Exclusive                                = 0,
	Inclusive                                = 1,
	Open                                     = 2,
	ERangeBoundTypes_MAX                     = 3,
};

// Enum CoreUObject.EInterpCurveMode
// NumValues: 0x0007
enum class EInterpCurveMode : uint8
{
	CIM_Linear                               = 0,
	CIM_CurveAuto                            = 1,
	CIM_Constant                             = 2,
	CIM_CurveUser                            = 3,
	CIM_CurveBreak                           = 4,
	CIM_CurveAutoClamped                     = 5,
	CIM_MAX                                  = 6,
};

// Enum CoreUObject.EInputDeviceConnectionState
// NumValues: 0x0005
enum class EInputDeviceConnectionState : uint8
{
	Invalid                                  = 0,
	Unknown                                  = 1,
	Disconnected                             = 2,
	Connected                                = 3,
	EInputDeviceConnectionState_MAX          = 4,
};

// Enum CoreUObject.ELocalizedTextSourceCategory
// NumValues: 0x0004
enum class ELocalizedTextSourceCategory : uint8
{
	Game                                     = 0,
	Engine                                   = 1,
	Editor                                   = 2,
	ELocalizedTextSourceCategory_MAX         = 3,
};

// Enum CoreUObject.ELifetimeCondition
// NumValues: 0x0012
enum class ELifetimeCondition : uint8
{
	COND_None                                = 0,
	COND_InitialOnly                         = 1,
	COND_OwnerOnly                           = 2,
	COND_SkipOwner                           = 3,
	COND_SimulatedOnly                       = 4,
	COND_AutonomousOnly                      = 5,
	COND_SimulatedOrPhysics                  = 6,
	COND_InitialOrOwner                      = 7,
	COND_Custom                              = 8,
	COND_ReplayOrOwner                       = 9,
	COND_ReplayOnly                          = 10,
	COND_SimulatedOnlyNoReplay               = 11,
	COND_SimulatedOrPhysicsNoReplay          = 12,
	COND_SkipReplay                          = 13,
	COND_Dynamic                             = 14,
	COND_Never                               = 15,
	COND_NetGroup                            = 16,
	COND_Max                                 = 17,
};

// Enum CoreUObject.EDataValidationUsecase
// NumValues: 0x0007
enum class EDataValidationUsecase : uint8
{
	None                                     = 0,
	Manual                                   = 1,
	Commandlet                               = 2,
	Save                                     = 3,
	PreSubmit                                = 4,
	Script                                   = 5,
	EDataValidationUsecase_MAX               = 6,
};

// Enum CoreUObject.ESearchCase
// NumValues: 0x0003
enum class ESearchCase : uint8
{
	CaseSensitive                            = 0,
	IgnoreCase                               = 1,
	ESearchCase_MAX                          = 2,
};

// Enum CoreUObject.ESearchDir
// NumValues: 0x0003
enum class ESearchDir : uint8
{
	FromStart                                = 0,
	FromEnd                                  = 1,
	ESearchDir_MAX                           = 2,
};

// Enum CoreUObject.ELogTimes
// NumValues: 0x0005
enum class ELogTimes : uint8
{
	None                                     = 0,
	UTC                                      = 1,
	SinceGStartTime                          = 2,
	Local                                    = 3,
	ELogTimes_MAX                            = 4,
};

// Enum CoreUObject.EAxis
// NumValues: 0x0005
enum class EAxis : uint8
{
	None                                     = 0,
	X                                        = 1,
	Y                                        = 2,
	Z                                        = 3,
	EAxis_MAX                                = 4,
};

// Enum CoreUObject.EAxisList
// NumValues: 0x000D
enum class EAxisList : uint8
{
	None                                     = 0,
	X                                        = 1,
	Y                                        = 2,
	Z                                        = 4,
	Screen                                   = 8,
	XY                                       = 3,
	XZ                                       = 5,
	YZ                                       = 6,
	XYZ                                      = 7,
	All                                      = 15,
	ZRotation                                = 6,
	Rotate2D                                 = 8,
	EAxisList_MAX                            = 16,
};

// Enum CoreUObject.EPixelFormat
// NumValues: 0x005D
enum class EPixelFormat : uint8
{
	PF_Unknown                               = 0,
	PF_A32B32G32R32F                         = 1,
	PF_B8G8R8A8                              = 2,
	PF_G8                                    = 3,
	PF_G16                                   = 4,
	PF_DXT1                                  = 5,
	PF_DXT3                                  = 6,
	PF_DXT5                                  = 7,
	PF_UYVY                                  = 8,
	PF_FloatRGB                              = 9,
	PF_FloatRGBA                             = 10,
	PF_DepthStencil                          = 11,
	PF_ShadowDepth                           = 12,
	PF_R32_FLOAT                             = 13,
	PF_G16R16                                = 14,
	PF_G16R16F                               = 15,
	PF_G16R16F_FILTER                        = 16,
	PF_G32R32F                               = 17,
	PF_A2B10G10R10                           = 18,
	PF_A16B16G16R16                          = 19,
	PF_D24                                   = 20,
	PF_R16F                                  = 21,
	PF_R16F_FILTER                           = 22,
	PF_BC5                                   = 23,
	PF_V8U8                                  = 24,
	PF_A1                                    = 25,
	PF_FloatR11G11B10                        = 26,
	PF_A8                                    = 27,
	PF_R32_UINT                              = 28,
	PF_R32_SINT                              = 29,
	PF_PVRTC2                                = 30,
	PF_PVRTC4                                = 31,
	PF_R16_UINT                              = 32,
	PF_R16_SINT                              = 33,
	PF_R16G16B16A16_UINT                     = 34,
	PF_R16G16B16A16_SINT                     = 35,
	PF_R5G6B5_UNORM                          = 36,
	PF_R8G8B8A8                              = 37,
	PF_A8R8G8B8                              = 38,
	PF_BC4                                   = 39,
	PF_R8G8                                  = 40,
	PF_ATC_RGB                               = 41,
	PF_ATC_RGBA_E                            = 42,
	PF_ATC_RGBA_I                            = 43,
	PF_X24_G8                                = 44,
	PF_ETC1                                  = 45,
	PF_ETC2_RGB                              = 46,
	PF_ETC2_RGBA                             = 47,
	PF_R32G32B32A32_UINT                     = 48,
	PF_R16G16_UINT                           = 49,
	PF_ASTC_4x4                              = 50,
	PF_ASTC_6x6                              = 51,
	PF_ASTC_8x8                              = 52,
	PF_ASTC_10x10                            = 53,
	PF_ASTC_12x12                            = 54,
	PF_BC6H                                  = 55,
	PF_BC7                                   = 56,
	PF_R8_UINT                               = 57,
	PF_L8                                    = 58,
	PF_XGXR8                                 = 59,
	PF_R8G8B8A8_UINT                         = 60,
	PF_R8G8B8A8_SNORM                        = 61,
	PF_R16G16B16A16_UNORM                    = 62,
	PF_R16G16B16A16_SNORM                    = 63,
	PF_PLATFORM_HDR_0                        = 64,
	PF_PLATFORM_HDR_1                        = 65,
	PF_PLATFORM_HDR_2                        = 66,
	PF_NV12                                  = 67,
	PF_R32G32_UINT                           = 68,
	PF_ETC2_R11_EAC                          = 69,
	PF_ETC2_RG11_EAC                         = 70,
	PF_R8                                    = 71,
	PF_B5G5R5A1_UNORM                        = 72,
	PF_ASTC_4x4_HDR                          = 73,
	PF_ASTC_6x6_HDR                          = 74,
	PF_ASTC_8x8_HDR                          = 75,
	PF_ASTC_10x10_HDR                        = 76,
	PF_ASTC_12x12_HDR                        = 77,
	PF_G16R16_SNORM                          = 78,
	PF_R8G8_UINT                             = 79,
	PF_R32G32B32_UINT                        = 80,
	PF_R32G32B32_SINT                        = 81,
	PF_R32G32B32F                            = 82,
	PF_R8_SINT                               = 83,
	PF_R64_UINT                              = 84,
	PF_R9G9B9EXP5                            = 85,
	PF_P010                                  = 86,
	PF_ASTC_4x4_NORM_RG                      = 87,
	PF_ASTC_6x6_NORM_RG                      = 88,
	PF_ASTC_8x8_NORM_RG                      = 89,
	PF_ASTC_10x10_NORM_RG                    = 90,
	PF_ASTC_12x12_NORM_RG                    = 91,
	PF_MAX_0                                 = 92,
};

// Enum CoreUObject.EMouseCursor
// NumValues: 0x000F
enum class EMouseCursor : uint8
{
	None                                     = 0,
	Default                                  = 1,
	TextEditBeam                             = 2,
	ResizeLeftRight                          = 3,
	ResizeUpDown                             = 4,
	ResizeSouthEast                          = 5,
	ResizeSouthWest                          = 6,
	CardinalCross                            = 7,
	Crosshairs                               = 8,
	Hand                                     = 9,
	GrabHand                                 = 10,
	GrabHandClosed                           = 11,
	SlashedCircle                            = 12,
	EyeDropper                               = 13,
	EMouseCursor_MAX                         = 14,
};

// Enum CoreUObject.EUnit
// NumValues: 0x004D
enum class EUnit : uint8
{
	Micrometers                              = 0,
	Millimeters                              = 1,
	Centimeters                              = 2,
	Meters                                   = 3,
	Kilometers                               = 4,
	Inches                                   = 5,
	Feet                                     = 6,
	Yards                                    = 7,
	Miles                                    = 8,
	Lightyears                               = 9,
	Degrees                                  = 10,
	Radians                                  = 11,
	CentimetersPerSecond                     = 12,
	MetersPerSecond                          = 13,
	KilometersPerHour                        = 14,
	MilesPerHour                             = 15,
	DegreesPerSecond                         = 16,
	RadiansPerSecond                         = 17,
	CentimetersPerSecondSquared              = 18,
	MetersPerSecondSquared                   = 19,
	Celsius                                  = 20,
	Farenheit                                = 21,
	Kelvin                                   = 22,
	Micrograms                               = 23,
	Milligrams                               = 24,
	Grams                                    = 25,
	Kilograms                                = 26,
	MetricTons                               = 27,
	Ounces                                   = 28,
	Pounds                                   = 29,
	Stones                                   = 30,
	GramsPerCubicCentimeter                  = 31,
	GramsPerCubicMeter                       = 32,
	KilogramsPerCubicCentimeter              = 33,
	KilogramsPerCubicMeter                   = 34,
	Newtons                                  = 35,
	PoundsForce                              = 36,
	KilogramsForce                           = 37,
	KilogramCentimetersPerSecondSquared      = 38,
	NewtonMeters                             = 39,
	KilogramCentimetersSquaredPerSecondSquared = 40,
	NewtonSeconds                            = 41,
	KilogramCentimeters                      = 42,
	KilogramMeters                           = 43,
	Hertz                                    = 44,
	Kilohertz                                = 45,
	Megahertz                                = 46,
	Gigahertz                                = 47,
	RevolutionsPerMinute                     = 48,
	Bytes                                    = 49,
	Kilobytes                                = 50,
	Megabytes                                = 51,
	Gigabytes                                = 52,
	Terabytes                                = 53,
	Lumens                                   = 54,
	Candela                                  = 55,
	Lux                                      = 56,
	CandelaPerMeter2                         = 57,
	ExposureValue                            = 58,
	Nanoseconds                              = 59,
	Microseconds                             = 60,
	Milliseconds                             = 61,
	Seconds                                  = 62,
	Minutes                                  = 63,
	Hours                                    = 64,
	Days                                     = 65,
	Months                                   = 66,
	Years                                    = 67,
	PixelsPerInch                            = 68,
	Percentage                               = 69,
	Multiplier                               = 70,
	Pascals                                  = 71,
	KiloPascals                              = 72,
	MegaPascals                              = 73,
	GigaPascals                              = 74,
	Unspecified                              = 75,
	EUnit_MAX                                = 76,
};

// Enum CoreUObject.EPropertyAccessChangeNotifyMode
// NumValues: 0x0004
enum class EPropertyAccessChangeNotifyMode : uint8
{
	Default                                  = 0,
	Never                                    = 1,
	Always                                   = 2,
	EPropertyAccessChangeNotifyMode_MAX      = 3,
};

// Enum CoreUObject.EAppMsgCategory
// NumValues: 0x0005
enum class EAppMsgCategory : uint8
{
	Warning                                  = 0,
	Error                                    = 1,
	Success                                  = 2,
	Info                                     = 3,
	EAppMsgCategory_MAX                      = 4,
};

// Enum CoreUObject.EAppReturnType
// NumValues: 0x0009
enum class EAppReturnType : uint8
{
	No                                       = 0,
	Yes                                      = 1,
	YesAll                                   = 2,
	NoAll                                    = 3,
	Cancel                                   = 4,
	Ok                                       = 5,
	Retry                                    = 6,
	Continue                                 = 7,
	EAppReturnType_MAX                       = 8,
};

// Enum CoreUObject.EAppMsgType
// NumValues: 0x0009
enum class EAppMsgType : uint8
{
	Ok                                       = 0,
	YesNo                                    = 1,
	OkCancel                                 = 2,
	YesNoCancel                              = 3,
	CancelRetryContinue                      = 4,
	YesNoYesAllNoAll                         = 5,
	YesNoYesAllNoAllCancel                   = 6,
	YesNoYesAll                              = 7,
	EAppMsgType_MAX                          = 8,
};

// Enum CoreUObject.EInputDeviceTriggerMask
// NumValues: 0x0005
enum class EInputDeviceTriggerMask : uint8
{
	None                                     = 0,
	Left                                     = 1,
	Right                                    = 2,
	All                                      = 3,
	EInputDeviceTriggerMask_MAX              = 4,
};

// Enum CoreUObject.EDataValidationResult
// NumValues: 0x0004
enum class EDataValidationResult : uint8
{
	Invalid                                  = 0,
	Valid                                    = 1,
	NotValidated                             = 2,
	EDataValidationResult_MAX                = 3,
};

// Enum CoreUObject.EOverriddenPropertyOperation
// NumValues: 0x0006
enum class EOverriddenPropertyOperation : uint8
{
	None                                     = 0,
	Modified                                 = 1,
	Replace                                  = 2,
	Add                                      = 3,
	Remove                                   = 4,
	EOverriddenPropertyOperation_MAX         = 5,
};

// ScriptStruct CoreUObject.Quat
// 0x0020 (0x0020 - 0x0000)
struct alignas(0x10) FQuat final
{
public:
	double                                        X;                                                 // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        Y;                                                 // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        Z;                                                 // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        W;                                                 // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FQuat) == 0x000010, "Wrong alignment on FQuat");
static_assert(sizeof(FQuat) == 0x000020, "Wrong size on FQuat");
static_assert(offsetof(FQuat, X) == 0x000000, "Member 'FQuat::X' has a wrong offset!");
static_assert(offsetof(FQuat, Y) == 0x000008, "Member 'FQuat::Y' has a wrong offset!");
static_assert(offsetof(FQuat, Z) == 0x000010, "Member 'FQuat::Z' has a wrong offset!");
static_assert(offsetof(FQuat, W) == 0x000018, "Member 'FQuat::W' has a wrong offset!");

// ScriptStruct CoreUObject.InterpCurvePointQuat
// 0x0080 (0x0080 - 0x0000)
struct FInterpCurvePointQuat final
{
public:
	float                                         InVal;                                             // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0xC];                                        // 0x0004(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FQuat                                  OutVal;                                            // 0x0010(0x0020)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FQuat                                  ArriveTangent;                                     // 0x0030(0x0020)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FQuat                                  LeaveTangent;                                      // 0x0050(0x0020)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EInterpCurveMode                              InterpMode;                                        // 0x0070(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0xF];                                       // 0x0071(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FInterpCurvePointQuat) == 0x000010, "Wrong alignment on FInterpCurvePointQuat");
static_assert(sizeof(FInterpCurvePointQuat) == 0x000080, "Wrong size on FInterpCurvePointQuat");
static_assert(offsetof(FInterpCurvePointQuat, InVal) == 0x000000, "Member 'FInterpCurvePointQuat::InVal' has a wrong offset!");
static_assert(offsetof(FInterpCurvePointQuat, OutVal) == 0x000010, "Member 'FInterpCurvePointQuat::OutVal' has a wrong offset!");
static_assert(offsetof(FInterpCurvePointQuat, ArriveTangent) == 0x000030, "Member 'FInterpCurvePointQuat::ArriveTangent' has a wrong offset!");
static_assert(offsetof(FInterpCurvePointQuat, LeaveTangent) == 0x000050, "Member 'FInterpCurvePointQuat::LeaveTangent' has a wrong offset!");
static_assert(offsetof(FInterpCurvePointQuat, InterpMode) == 0x000070, "Member 'FInterpCurvePointQuat::InterpMode' has a wrong offset!");

// ScriptStruct CoreUObject.InterpCurveQuat
// 0x0018 (0x0018 - 0x0000)
struct FInterpCurveQuat final
{
public:
	TArray<struct FInterpCurvePointQuat>          Points;                                            // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bIsLooped;                                         // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LoopKeyOffset;                                     // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInterpCurveQuat) == 0x000008, "Wrong alignment on FInterpCurveQuat");
static_assert(sizeof(FInterpCurveQuat) == 0x000018, "Wrong size on FInterpCurveQuat");
static_assert(offsetof(FInterpCurveQuat, Points) == 0x000000, "Member 'FInterpCurveQuat::Points' has a wrong offset!");
static_assert(offsetof(FInterpCurveQuat, bIsLooped) == 0x000010, "Member 'FInterpCurveQuat::bIsLooped' has a wrong offset!");
static_assert(offsetof(FInterpCurveQuat, LoopKeyOffset) == 0x000014, "Member 'FInterpCurveQuat::LoopKeyOffset' has a wrong offset!");

// ScriptStruct CoreUObject.TopLevelAssetPath
// 0x0010 (0x0010 - 0x0000)
struct FTopLevelAssetPath final
{
public:
	class FName                                   PackageName;                                       // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   AssetName;                                         // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FTopLevelAssetPath) == 0x000004, "Wrong alignment on FTopLevelAssetPath");
static_assert(sizeof(FTopLevelAssetPath) == 0x000010, "Wrong size on FTopLevelAssetPath");
static_assert(offsetof(FTopLevelAssetPath, PackageName) == 0x000000, "Member 'FTopLevelAssetPath::PackageName' has a wrong offset!");
static_assert(offsetof(FTopLevelAssetPath, AssetName) == 0x000008, "Member 'FTopLevelAssetPath::AssetName' has a wrong offset!");

// ScriptStruct CoreUObject.SoftObjectPath
// 0x0020 (0x0020 - 0x0000)
struct FSoftObjectPath
{
public:
	struct FTopLevelAssetPath                     AssetPath;                                         // 0x0000(0x0010)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SubPathString;                                     // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSoftObjectPath) == 0x000008, "Wrong alignment on FSoftObjectPath");
static_assert(sizeof(FSoftObjectPath) == 0x000020, "Wrong size on FSoftObjectPath");
static_assert(offsetof(FSoftObjectPath, AssetPath) == 0x000000, "Member 'FSoftObjectPath::AssetPath' has a wrong offset!");
static_assert(offsetof(FSoftObjectPath, SubPathString) == 0x000010, "Member 'FSoftObjectPath::SubPathString' has a wrong offset!");

// ScriptStruct CoreUObject.ARFilter
// 0x0150 (0x0150 - 0x0000)
struct FARFilter final
{
public:
	TArray<class FName>                           PackageNames;                                      // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<class FName>                           PackagePaths;                                      // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FSoftObjectPath>                SoftObjectPaths;                                   // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<class FName>                           ClassNames;                                        // 0x0030(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FTopLevelAssetPath>             ClassPaths;                                        // 0x0040(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	uint8                                         Pad_50[0x50];                                      // 0x0050(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<class FName>                             RecursiveClassesExclusionSet;                      // 0x00A0(0x0050)(BlueprintVisible, NativeAccessSpecifierPublic)
	TSet<struct FTopLevelAssetPath>               RecursiveClassPathsExclusionSet;                   // 0x00F0(0x0050)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bRecursivePaths;                                   // 0x0140(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRecursiveClasses;                                 // 0x0141(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIncludeOnlyOnDiskAssets;                          // 0x0142(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_143[0xD];                                      // 0x0143(0x000D)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FARFilter) == 0x000008, "Wrong alignment on FARFilter");
static_assert(sizeof(FARFilter) == 0x000150, "Wrong size on FARFilter");
static_assert(offsetof(FARFilter, PackageNames) == 0x000000, "Member 'FARFilter::PackageNames' has a wrong offset!");
static_assert(offsetof(FARFilter, PackagePaths) == 0x000010, "Member 'FARFilter::PackagePaths' has a wrong offset!");
static_assert(offsetof(FARFilter, SoftObjectPaths) == 0x000020, "Member 'FARFilter::SoftObjectPaths' has a wrong offset!");
static_assert(offsetof(FARFilter, ClassNames) == 0x000030, "Member 'FARFilter::ClassNames' has a wrong offset!");
static_assert(offsetof(FARFilter, ClassPaths) == 0x000040, "Member 'FARFilter::ClassPaths' has a wrong offset!");
static_assert(offsetof(FARFilter, RecursiveClassesExclusionSet) == 0x0000A0, "Member 'FARFilter::RecursiveClassesExclusionSet' has a wrong offset!");
static_assert(offsetof(FARFilter, RecursiveClassPathsExclusionSet) == 0x0000F0, "Member 'FARFilter::RecursiveClassPathsExclusionSet' has a wrong offset!");
static_assert(offsetof(FARFilter, bRecursivePaths) == 0x000140, "Member 'FARFilter::bRecursivePaths' has a wrong offset!");
static_assert(offsetof(FARFilter, bRecursiveClasses) == 0x000141, "Member 'FARFilter::bRecursiveClasses' has a wrong offset!");
static_assert(offsetof(FARFilter, bIncludeOnlyOnDiskAssets) == 0x000142, "Member 'FARFilter::bIncludeOnlyOnDiskAssets' has a wrong offset!");

// ScriptStruct CoreUObject.Vector
// 0x0018 (0x0018 - 0x0000)
struct FVector
{
public:
	using UnderlayingType = double;                                                                  // 0x0000(0x0008)(NOT AUTO-GENERATED PROPERTY)

	double                                        X;                                                 // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        Y;                                                 // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        Z;                                                 // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	FVector& Normalize()
	{
		*this /= Magnitude();
		return *this;
	}
	FVector& operator*=(const FVector& Other)
	{
		*this = *this * Other;
		return *this;
	}
	FVector& operator*=(float Scalar)
	{
		*this = *this * Scalar;
		return *this;
	}
	FVector& operator+=(const FVector& Other)
	{
		*this = *this + Other;
		return *this;
	}
	FVector& operator-=(const FVector& Other)
	{
		*this = *this - Other;
		return *this;
	}
	FVector& operator/=(const FVector& Other)
	{
		*this = *this / Other;
		return *this;
	}
	FVector& operator/=(float Scalar)
	{
		*this = *this / Scalar;
		return *this;
	}

	UnderlayingType Dot(const FVector& Other) const
	{
		return (X * Other.X) + (Y * Other.Y) + (Z * Other.Z);
	}
	UnderlayingType GetDistanceTo(const FVector& Other) const
	{
		FVector DiffVector = Other - *this;
		return DiffVector.Magnitude();
	}
	UnderlayingType GetDistanceToInMeters(const FVector& Other) const
	{
		return GetDistanceTo(Other) * static_cast<UnderlayingType>(0.01);
	}
	FVector GetNormalized() const
	{
		return *this / Magnitude();
	}
	bool IsZero() const
	{
		return X == 0.0 && Y == 0.0 && Z == 0.0;
	}
	UnderlayingType Magnitude() const
	{
		return std::sqrt((X * X) + (Y * Y) + (Z * Z));
	}
	bool operator!=(const FVector& Other) const
	{
		return X != Other.X || Y != Other.Y || Z != Other.Z;
	}
	FVector operator*(const FVector& Other) const
	{
		return { X * Other.X, Y * Other.Y, Z * Other.Z };
	}
	FVector operator*(float Scalar) const
	{
		return { X * Scalar, Y * Scalar, Z * Scalar };
	}
	FVector operator+(const FVector& Other) const
	{
		return { X + Other.X, Y + Other.Y, Z + Other.Z };
	}
	FVector operator-(const FVector& Other) const
	{
		return { X - Other.X, Y - Other.Y, Z - Other.Z };
	}
	FVector operator/(const FVector& Other) const
	{
		if (Other.X == 0.0f || Other.Y == 0.0f ||Other.Z == 0.0f)
			return *this;
	
		return { X / Other.X, Y / Other.Y, Z / Other.Z };
	}
	FVector operator/(float Scalar) const
	{
		if (Scalar == 0.0f)
			return *this;
	
		return { X / Scalar, Y / Scalar, Z / Scalar };
	}
	bool operator==(const FVector& Other) const
	{
		return X == Other.X && Y == Other.Y && Z == Other.Z;
	}
};
static_assert(alignof(FVector) == 0x000008, "Wrong alignment on FVector");
static_assert(sizeof(FVector) == 0x000018, "Wrong size on FVector");
static_assert(offsetof(FVector, X) == 0x000000, "Member 'FVector::X' has a wrong offset!");
static_assert(offsetof(FVector, Y) == 0x000008, "Member 'FVector::Y' has a wrong offset!");
static_assert(offsetof(FVector, Z) == 0x000010, "Member 'FVector::Z' has a wrong offset!");

// ScriptStruct CoreUObject.TwoVectors
// 0x0030 (0x0030 - 0x0000)
struct FTwoVectors final
{
public:
	struct FVector                                V1;                                                // 0x0000(0x0018)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                V2;                                                // 0x0018(0x0018)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTwoVectors) == 0x000008, "Wrong alignment on FTwoVectors");
static_assert(sizeof(FTwoVectors) == 0x000030, "Wrong size on FTwoVectors");
static_assert(offsetof(FTwoVectors, V1) == 0x000000, "Member 'FTwoVectors::V1' has a wrong offset!");
static_assert(offsetof(FTwoVectors, V2) == 0x000018, "Member 'FTwoVectors::V2' has a wrong offset!");

// ScriptStruct CoreUObject.InterpCurvePointTwoVectors
// 0x00A0 (0x00A0 - 0x0000)
struct FInterpCurvePointTwoVectors final
{
public:
	float                                         InVal;                                             // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTwoVectors                            OutVal;                                            // 0x0008(0x0030)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FTwoVectors                            ArriveTangent;                                     // 0x0038(0x0030)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FTwoVectors                            LeaveTangent;                                      // 0x0068(0x0030)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	EInterpCurveMode                              InterpMode;                                        // 0x0098(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_99[0x7];                                       // 0x0099(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FInterpCurvePointTwoVectors) == 0x000008, "Wrong alignment on FInterpCurvePointTwoVectors");
static_assert(sizeof(FInterpCurvePointTwoVectors) == 0x0000A0, "Wrong size on FInterpCurvePointTwoVectors");
static_assert(offsetof(FInterpCurvePointTwoVectors, InVal) == 0x000000, "Member 'FInterpCurvePointTwoVectors::InVal' has a wrong offset!");
static_assert(offsetof(FInterpCurvePointTwoVectors, OutVal) == 0x000008, "Member 'FInterpCurvePointTwoVectors::OutVal' has a wrong offset!");
static_assert(offsetof(FInterpCurvePointTwoVectors, ArriveTangent) == 0x000038, "Member 'FInterpCurvePointTwoVectors::ArriveTangent' has a wrong offset!");
static_assert(offsetof(FInterpCurvePointTwoVectors, LeaveTangent) == 0x000068, "Member 'FInterpCurvePointTwoVectors::LeaveTangent' has a wrong offset!");
static_assert(offsetof(FInterpCurvePointTwoVectors, InterpMode) == 0x000098, "Member 'FInterpCurvePointTwoVectors::InterpMode' has a wrong offset!");

// ScriptStruct CoreUObject.InterpCurveTwoVectors
// 0x0018 (0x0018 - 0x0000)
struct FInterpCurveTwoVectors final
{
public:
	TArray<struct FInterpCurvePointTwoVectors>    Points;                                            // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bIsLooped;                                         // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LoopKeyOffset;                                     // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInterpCurveTwoVectors) == 0x000008, "Wrong alignment on FInterpCurveTwoVectors");
static_assert(sizeof(FInterpCurveTwoVectors) == 0x000018, "Wrong size on FInterpCurveTwoVectors");
static_assert(offsetof(FInterpCurveTwoVectors, Points) == 0x000000, "Member 'FInterpCurveTwoVectors::Points' has a wrong offset!");
static_assert(offsetof(FInterpCurveTwoVectors, bIsLooped) == 0x000010, "Member 'FInterpCurveTwoVectors::bIsLooped' has a wrong offset!");
static_assert(offsetof(FInterpCurveTwoVectors, LoopKeyOffset) == 0x000014, "Member 'FInterpCurveTwoVectors::LoopKeyOffset' has a wrong offset!");

// ScriptStruct CoreUObject.InterpCurvePointVector
// 0x0058 (0x0058 - 0x0000)
struct FInterpCurvePointVector final
{
public:
	float                                         InVal;                                             // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                OutVal;                                            // 0x0008(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ArriveTangent;                                     // 0x0020(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LeaveTangent;                                      // 0x0038(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EInterpCurveMode                              InterpMode;                                        // 0x0050(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FInterpCurvePointVector) == 0x000008, "Wrong alignment on FInterpCurvePointVector");
static_assert(sizeof(FInterpCurvePointVector) == 0x000058, "Wrong size on FInterpCurvePointVector");
static_assert(offsetof(FInterpCurvePointVector, InVal) == 0x000000, "Member 'FInterpCurvePointVector::InVal' has a wrong offset!");
static_assert(offsetof(FInterpCurvePointVector, OutVal) == 0x000008, "Member 'FInterpCurvePointVector::OutVal' has a wrong offset!");
static_assert(offsetof(FInterpCurvePointVector, ArriveTangent) == 0x000020, "Member 'FInterpCurvePointVector::ArriveTangent' has a wrong offset!");
static_assert(offsetof(FInterpCurvePointVector, LeaveTangent) == 0x000038, "Member 'FInterpCurvePointVector::LeaveTangent' has a wrong offset!");
static_assert(offsetof(FInterpCurvePointVector, InterpMode) == 0x000050, "Member 'FInterpCurvePointVector::InterpMode' has a wrong offset!");

// ScriptStruct CoreUObject.InterpCurveVector
// 0x0018 (0x0018 - 0x0000)
struct FInterpCurveVector final
{
public:
	TArray<struct FInterpCurvePointVector>        Points;                                            // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bIsLooped;                                         // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LoopKeyOffset;                                     // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInterpCurveVector) == 0x000008, "Wrong alignment on FInterpCurveVector");
static_assert(sizeof(FInterpCurveVector) == 0x000018, "Wrong size on FInterpCurveVector");
static_assert(offsetof(FInterpCurveVector, Points) == 0x000000, "Member 'FInterpCurveVector::Points' has a wrong offset!");
static_assert(offsetof(FInterpCurveVector, bIsLooped) == 0x000010, "Member 'FInterpCurveVector::bIsLooped' has a wrong offset!");
static_assert(offsetof(FInterpCurveVector, LoopKeyOffset) == 0x000014, "Member 'FInterpCurveVector::LoopKeyOffset' has a wrong offset!");

// ScriptStruct CoreUObject.Vector2D
// 0x0010 (0x0010 - 0x0000)
struct FVector2D final
{
public:
	double                                        X;                                                 // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        Y;                                                 // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVector2D) == 0x000008, "Wrong alignment on FVector2D");
static_assert(sizeof(FVector2D) == 0x000010, "Wrong size on FVector2D");
static_assert(offsetof(FVector2D, X) == 0x000000, "Member 'FVector2D::X' has a wrong offset!");
static_assert(offsetof(FVector2D, Y) == 0x000008, "Member 'FVector2D::Y' has a wrong offset!");

// ScriptStruct CoreUObject.InterpCurvePointVector2D
// 0x0040 (0x0040 - 0x0000)
struct FInterpCurvePointVector2D final
{
public:
	float                                         InVal;                                             // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              OutVal;                                            // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              ArriveTangent;                                     // 0x0018(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              LeaveTangent;                                      // 0x0028(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EInterpCurveMode                              InterpMode;                                        // 0x0038(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FInterpCurvePointVector2D) == 0x000008, "Wrong alignment on FInterpCurvePointVector2D");
static_assert(sizeof(FInterpCurvePointVector2D) == 0x000040, "Wrong size on FInterpCurvePointVector2D");
static_assert(offsetof(FInterpCurvePointVector2D, InVal) == 0x000000, "Member 'FInterpCurvePointVector2D::InVal' has a wrong offset!");
static_assert(offsetof(FInterpCurvePointVector2D, OutVal) == 0x000008, "Member 'FInterpCurvePointVector2D::OutVal' has a wrong offset!");
static_assert(offsetof(FInterpCurvePointVector2D, ArriveTangent) == 0x000018, "Member 'FInterpCurvePointVector2D::ArriveTangent' has a wrong offset!");
static_assert(offsetof(FInterpCurvePointVector2D, LeaveTangent) == 0x000028, "Member 'FInterpCurvePointVector2D::LeaveTangent' has a wrong offset!");
static_assert(offsetof(FInterpCurvePointVector2D, InterpMode) == 0x000038, "Member 'FInterpCurvePointVector2D::InterpMode' has a wrong offset!");

// ScriptStruct CoreUObject.InterpCurveVector2D
// 0x0018 (0x0018 - 0x0000)
struct FInterpCurveVector2D final
{
public:
	TArray<struct FInterpCurvePointVector2D>      Points;                                            // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bIsLooped;                                         // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LoopKeyOffset;                                     // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInterpCurveVector2D) == 0x000008, "Wrong alignment on FInterpCurveVector2D");
static_assert(sizeof(FInterpCurveVector2D) == 0x000018, "Wrong size on FInterpCurveVector2D");
static_assert(offsetof(FInterpCurveVector2D, Points) == 0x000000, "Member 'FInterpCurveVector2D::Points' has a wrong offset!");
static_assert(offsetof(FInterpCurveVector2D, bIsLooped) == 0x000010, "Member 'FInterpCurveVector2D::bIsLooped' has a wrong offset!");
static_assert(offsetof(FInterpCurveVector2D, LoopKeyOffset) == 0x000014, "Member 'FInterpCurveVector2D::LoopKeyOffset' has a wrong offset!");

// ScriptStruct CoreUObject.Vector4d
// 0x0020 (0x0020 - 0x0000)
struct alignas(0x10) FVector4d final
{
public:
	double                                        X;                                                 // 0x0000(0x0008)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        Y;                                                 // 0x0008(0x0008)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        Z;                                                 // 0x0010(0x0008)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        W;                                                 // 0x0018(0x0008)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVector4d) == 0x000010, "Wrong alignment on FVector4d");
static_assert(sizeof(FVector4d) == 0x000020, "Wrong size on FVector4d");
static_assert(offsetof(FVector4d, X) == 0x000000, "Member 'FVector4d::X' has a wrong offset!");
static_assert(offsetof(FVector4d, Y) == 0x000008, "Member 'FVector4d::Y' has a wrong offset!");
static_assert(offsetof(FVector4d, Z) == 0x000010, "Member 'FVector4d::Z' has a wrong offset!");
static_assert(offsetof(FVector4d, W) == 0x000018, "Member 'FVector4d::W' has a wrong offset!");

// ScriptStruct CoreUObject.AssetBundleEntry
// 0x0018 (0x0018 - 0x0000)
struct FAssetBundleEntry final
{
public:
	class FName                                   BundleName;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTopLevelAssetPath>             AssetPaths;                                        // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAssetBundleEntry) == 0x000008, "Wrong alignment on FAssetBundleEntry");
static_assert(sizeof(FAssetBundleEntry) == 0x000018, "Wrong size on FAssetBundleEntry");
static_assert(offsetof(FAssetBundleEntry, BundleName) == 0x000000, "Member 'FAssetBundleEntry::BundleName' has a wrong offset!");
static_assert(offsetof(FAssetBundleEntry, AssetPaths) == 0x000008, "Member 'FAssetBundleEntry::AssetPaths' has a wrong offset!");

// ScriptStruct CoreUObject.AssetBundleData
// 0x0010 (0x0010 - 0x0000)
struct FAssetBundleData final
{
public:
	TArray<struct FAssetBundleEntry>              Bundles;                                           // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAssetBundleData) == 0x000008, "Wrong alignment on FAssetBundleData");
static_assert(sizeof(FAssetBundleData) == 0x000010, "Wrong size on FAssetBundleData");
static_assert(offsetof(FAssetBundleData, Bundles) == 0x000000, "Member 'FAssetBundleData::Bundles' has a wrong offset!");

// ScriptStruct CoreUObject.AssetData
// 0x0068 (0x0068 - 0x0000)
struct alignas(0x08) FAssetData final
{
public:
	class FName                                   PackageName;                                       // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PackagePath;                                       // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AssetName;                                         // 0x0010(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AssetClass;                                        // 0x0018(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTopLevelAssetPath                     AssetClassPath;                                    // 0x0020(0x0010)(BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_30[0x38];                                      // 0x0030(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAssetData) == 0x000008, "Wrong alignment on FAssetData");
static_assert(sizeof(FAssetData) == 0x000068, "Wrong size on FAssetData");
static_assert(offsetof(FAssetData, PackageName) == 0x000000, "Member 'FAssetData::PackageName' has a wrong offset!");
static_assert(offsetof(FAssetData, PackagePath) == 0x000008, "Member 'FAssetData::PackagePath' has a wrong offset!");
static_assert(offsetof(FAssetData, AssetName) == 0x000010, "Member 'FAssetData::AssetName' has a wrong offset!");
static_assert(offsetof(FAssetData, AssetClass) == 0x000018, "Member 'FAssetData::AssetClass' has a wrong offset!");
static_assert(offsetof(FAssetData, AssetClassPath) == 0x000020, "Member 'FAssetData::AssetClassPath' has a wrong offset!");

// ScriptStruct CoreUObject.Guid
// 0x0010 (0x0010 - 0x0000)
struct FGuid final
{
public:
	int32                                         A;                                                 // 0x0000(0x0004)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         B;                                                 // 0x0004(0x0004)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         C;                                                 // 0x0008(0x0004)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         D;                                                 // 0x000C(0x0004)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGuid) == 0x000004, "Wrong alignment on FGuid");
static_assert(sizeof(FGuid) == 0x000010, "Wrong size on FGuid");
static_assert(offsetof(FGuid, A) == 0x000000, "Member 'FGuid::A' has a wrong offset!");
static_assert(offsetof(FGuid, B) == 0x000004, "Member 'FGuid::B' has a wrong offset!");
static_assert(offsetof(FGuid, C) == 0x000008, "Member 'FGuid::C' has a wrong offset!");
static_assert(offsetof(FGuid, D) == 0x00000C, "Member 'FGuid::D' has a wrong offset!");

// ScriptStruct CoreUObject.AutomationEvent
// 0x0038 (0x0038 - 0x0000)
struct FAutomationEvent final
{
public:
	EAutomationEventType                          Type;                                              // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Message;                                           // 0x0008(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Context;                                           // 0x0018(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGuid                                  Artifact;                                          // 0x0028(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAutomationEvent) == 0x000008, "Wrong alignment on FAutomationEvent");
static_assert(sizeof(FAutomationEvent) == 0x000038, "Wrong size on FAutomationEvent");
static_assert(offsetof(FAutomationEvent, Type) == 0x000000, "Member 'FAutomationEvent::Type' has a wrong offset!");
static_assert(offsetof(FAutomationEvent, Message) == 0x000008, "Member 'FAutomationEvent::Message' has a wrong offset!");
static_assert(offsetof(FAutomationEvent, Context) == 0x000018, "Member 'FAutomationEvent::Context' has a wrong offset!");
static_assert(offsetof(FAutomationEvent, Artifact) == 0x000028, "Member 'FAutomationEvent::Artifact' has a wrong offset!");

// ScriptStruct CoreUObject.DateTime
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x08) FDateTime final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDateTime) == 0x000008, "Wrong alignment on FDateTime");
static_assert(sizeof(FDateTime) == 0x000008, "Wrong size on FDateTime");

// ScriptStruct CoreUObject.AutomationExecutionEntry
// 0x0058 (0x0058 - 0x0000)
struct FAutomationExecutionEntry final
{
public:
	struct FAutomationEvent                       Event;                                             // 0x0000(0x0038)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Filename;                                          // 0x0038(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LineNumber;                                        // 0x0048(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDateTime                              Timestamp;                                         // 0x0050(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAutomationExecutionEntry) == 0x000008, "Wrong alignment on FAutomationExecutionEntry");
static_assert(sizeof(FAutomationExecutionEntry) == 0x000058, "Wrong size on FAutomationExecutionEntry");
static_assert(offsetof(FAutomationExecutionEntry, Event) == 0x000000, "Member 'FAutomationExecutionEntry::Event' has a wrong offset!");
static_assert(offsetof(FAutomationExecutionEntry, Filename) == 0x000038, "Member 'FAutomationExecutionEntry::Filename' has a wrong offset!");
static_assert(offsetof(FAutomationExecutionEntry, LineNumber) == 0x000048, "Member 'FAutomationExecutionEntry::LineNumber' has a wrong offset!");
static_assert(offsetof(FAutomationExecutionEntry, Timestamp) == 0x000050, "Member 'FAutomationExecutionEntry::Timestamp' has a wrong offset!");

// ScriptStruct CoreUObject.Box
// 0x0038 (0x0038 - 0x0000)
struct FBox final
{
public:
	struct FVector                                Min;                                               // 0x0000(0x0018)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Max;                                               // 0x0018(0x0018)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsValid;                                           // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBox) == 0x000008, "Wrong alignment on FBox");
static_assert(sizeof(FBox) == 0x000038, "Wrong size on FBox");
static_assert(offsetof(FBox, Min) == 0x000000, "Member 'FBox::Min' has a wrong offset!");
static_assert(offsetof(FBox, Max) == 0x000018, "Member 'FBox::Max' has a wrong offset!");
static_assert(offsetof(FBox, IsValid) == 0x000030, "Member 'FBox::IsValid' has a wrong offset!");

// ScriptStruct CoreUObject.Box2D
// 0x0028 (0x0028 - 0x0000)
struct FBox2D final
{
public:
	struct FVector2D                              Min;                                               // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              Max;                                               // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsValid;                                          // 0x0020(0x0001)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBox2D) == 0x000008, "Wrong alignment on FBox2D");
static_assert(sizeof(FBox2D) == 0x000028, "Wrong size on FBox2D");
static_assert(offsetof(FBox2D, Min) == 0x000000, "Member 'FBox2D::Min' has a wrong offset!");
static_assert(offsetof(FBox2D, Max) == 0x000010, "Member 'FBox2D::Max' has a wrong offset!");
static_assert(offsetof(FBox2D, bIsValid) == 0x000020, "Member 'FBox2D::bIsValid' has a wrong offset!");

// ScriptStruct CoreUObject.Vector2f
// 0x0008 (0x0008 - 0x0000)
struct FVector2f
{
public:
	float                                         X;                                                 // 0x0000(0x0004)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Y;                                                 // 0x0004(0x0004)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVector2f) == 0x000004, "Wrong alignment on FVector2f");
static_assert(sizeof(FVector2f) == 0x000008, "Wrong size on FVector2f");
static_assert(offsetof(FVector2f, X) == 0x000000, "Member 'FVector2f::X' has a wrong offset!");
static_assert(offsetof(FVector2f, Y) == 0x000004, "Member 'FVector2f::Y' has a wrong offset!");

// ScriptStruct CoreUObject.Box2f
// 0x0014 (0x0014 - 0x0000)
struct FBox2f final
{
public:
	struct FVector2f                              Min;                                               // 0x0000(0x0008)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2f                              Max;                                               // 0x0008(0x0008)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsValid;                                          // 0x0010(0x0001)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBox2f) == 0x000004, "Wrong alignment on FBox2f");
static_assert(sizeof(FBox2f) == 0x000014, "Wrong size on FBox2f");
static_assert(offsetof(FBox2f, Min) == 0x000000, "Member 'FBox2f::Min' has a wrong offset!");
static_assert(offsetof(FBox2f, Max) == 0x000008, "Member 'FBox2f::Max' has a wrong offset!");
static_assert(offsetof(FBox2f, bIsValid) == 0x000010, "Member 'FBox2f::bIsValid' has a wrong offset!");

// ScriptStruct CoreUObject.Vector3d
// 0x0018 (0x0018 - 0x0000)
struct FVector3d
{
public:
	double                                        X;                                                 // 0x0000(0x0008)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        Y;                                                 // 0x0008(0x0008)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        Z;                                                 // 0x0010(0x0008)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVector3d) == 0x000008, "Wrong alignment on FVector3d");
static_assert(sizeof(FVector3d) == 0x000018, "Wrong size on FVector3d");
static_assert(offsetof(FVector3d, X) == 0x000000, "Member 'FVector3d::X' has a wrong offset!");
static_assert(offsetof(FVector3d, Y) == 0x000008, "Member 'FVector3d::Y' has a wrong offset!");
static_assert(offsetof(FVector3d, Z) == 0x000010, "Member 'FVector3d::Z' has a wrong offset!");

// ScriptStruct CoreUObject.Box3d
// 0x0038 (0x0038 - 0x0000)
struct FBox3d final
{
public:
	struct FVector3d                              Min;                                               // 0x0000(0x0018)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector3d                              Max;                                               // 0x0018(0x0018)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsValid;                                           // 0x0030(0x0001)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBox3d) == 0x000008, "Wrong alignment on FBox3d");
static_assert(sizeof(FBox3d) == 0x000038, "Wrong size on FBox3d");
static_assert(offsetof(FBox3d, Min) == 0x000000, "Member 'FBox3d::Min' has a wrong offset!");
static_assert(offsetof(FBox3d, Max) == 0x000018, "Member 'FBox3d::Max' has a wrong offset!");
static_assert(offsetof(FBox3d, IsValid) == 0x000030, "Member 'FBox3d::IsValid' has a wrong offset!");

// ScriptStruct CoreUObject.Vector3f
// 0x000C (0x000C - 0x0000)
struct FVector3f
{
public:
	float                                         X;                                                 // 0x0000(0x0004)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Y;                                                 // 0x0004(0x0004)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Z;                                                 // 0x0008(0x0004)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVector3f) == 0x000004, "Wrong alignment on FVector3f");
static_assert(sizeof(FVector3f) == 0x00000C, "Wrong size on FVector3f");
static_assert(offsetof(FVector3f, X) == 0x000000, "Member 'FVector3f::X' has a wrong offset!");
static_assert(offsetof(FVector3f, Y) == 0x000004, "Member 'FVector3f::Y' has a wrong offset!");
static_assert(offsetof(FVector3f, Z) == 0x000008, "Member 'FVector3f::Z' has a wrong offset!");

// ScriptStruct CoreUObject.Box3f
// 0x001C (0x001C - 0x0000)
struct FBox3f final
{
public:
	struct FVector3f                              Min;                                               // 0x0000(0x000C)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector3f                              Max;                                               // 0x000C(0x000C)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsValid;                                           // 0x0018(0x0001)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBox3f) == 0x000004, "Wrong alignment on FBox3f");
static_assert(sizeof(FBox3f) == 0x00001C, "Wrong size on FBox3f");
static_assert(offsetof(FBox3f, Min) == 0x000000, "Member 'FBox3f::Min' has a wrong offset!");
static_assert(offsetof(FBox3f, Max) == 0x00000C, "Member 'FBox3f::Max' has a wrong offset!");
static_assert(offsetof(FBox3f, IsValid) == 0x000018, "Member 'FBox3f::IsValid' has a wrong offset!");

// ScriptStruct CoreUObject.BoxSphereBounds
// 0x0038 (0x0038 - 0x0000)
struct FBoxSphereBounds final
{
public:
	struct FVector                                Origin;                                            // 0x0000(0x0018)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                BoxExtent;                                         // 0x0018(0x0018)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        SphereRadius;                                      // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBoxSphereBounds) == 0x000008, "Wrong alignment on FBoxSphereBounds");
static_assert(sizeof(FBoxSphereBounds) == 0x000038, "Wrong size on FBoxSphereBounds");
static_assert(offsetof(FBoxSphereBounds, Origin) == 0x000000, "Member 'FBoxSphereBounds::Origin' has a wrong offset!");
static_assert(offsetof(FBoxSphereBounds, BoxExtent) == 0x000018, "Member 'FBoxSphereBounds::BoxExtent' has a wrong offset!");
static_assert(offsetof(FBoxSphereBounds, SphereRadius) == 0x000030, "Member 'FBoxSphereBounds::SphereRadius' has a wrong offset!");

// ScriptStruct CoreUObject.BoxSphereBounds3d
// 0x0038 (0x0038 - 0x0000)
struct FBoxSphereBounds3d final
{
public:
	struct FVector3d                              Origin;                                            // 0x0000(0x0018)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector3d                              BoxExtent;                                         // 0x0018(0x0018)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        SphereRadius;                                      // 0x0030(0x0008)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBoxSphereBounds3d) == 0x000008, "Wrong alignment on FBoxSphereBounds3d");
static_assert(sizeof(FBoxSphereBounds3d) == 0x000038, "Wrong size on FBoxSphereBounds3d");
static_assert(offsetof(FBoxSphereBounds3d, Origin) == 0x000000, "Member 'FBoxSphereBounds3d::Origin' has a wrong offset!");
static_assert(offsetof(FBoxSphereBounds3d, BoxExtent) == 0x000018, "Member 'FBoxSphereBounds3d::BoxExtent' has a wrong offset!");
static_assert(offsetof(FBoxSphereBounds3d, SphereRadius) == 0x000030, "Member 'FBoxSphereBounds3d::SphereRadius' has a wrong offset!");

// ScriptStruct CoreUObject.BoxSphereBounds3f
// 0x001C (0x001C - 0x0000)
struct FBoxSphereBounds3f final
{
public:
	struct FVector3f                              Origin;                                            // 0x0000(0x000C)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector3f                              BoxExtent;                                         // 0x000C(0x000C)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SphereRadius;                                      // 0x0018(0x0004)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBoxSphereBounds3f) == 0x000004, "Wrong alignment on FBoxSphereBounds3f");
static_assert(sizeof(FBoxSphereBounds3f) == 0x00001C, "Wrong size on FBoxSphereBounds3f");
static_assert(offsetof(FBoxSphereBounds3f, Origin) == 0x000000, "Member 'FBoxSphereBounds3f::Origin' has a wrong offset!");
static_assert(offsetof(FBoxSphereBounds3f, BoxExtent) == 0x00000C, "Member 'FBoxSphereBounds3f::BoxExtent' has a wrong offset!");
static_assert(offsetof(FBoxSphereBounds3f, SphereRadius) == 0x000018, "Member 'FBoxSphereBounds3f::SphereRadius' has a wrong offset!");

// ScriptStruct CoreUObject.Color
// 0x0004 (0x0004 - 0x0000)
struct alignas(0x04) FColor final
{
public:
	uint8                                         B;                                                 // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         G;                                                 // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         R;                                                 // 0x0002(0x0001)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         A;                                                 // 0x0003(0x0001)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FColor) == 0x000004, "Wrong alignment on FColor");
static_assert(sizeof(FColor) == 0x000004, "Wrong size on FColor");
static_assert(offsetof(FColor, B) == 0x000000, "Member 'FColor::B' has a wrong offset!");
static_assert(offsetof(FColor, G) == 0x000001, "Member 'FColor::G' has a wrong offset!");
static_assert(offsetof(FColor, R) == 0x000002, "Member 'FColor::R' has a wrong offset!");
static_assert(offsetof(FColor, A) == 0x000003, "Member 'FColor::A' has a wrong offset!");

// ScriptStruct CoreUObject.DirectoryPath
// 0x0010 (0x0010 - 0x0000)
struct FDirectoryPath final
{
public:
	class FString                                 Path;                                              // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDirectoryPath) == 0x000008, "Wrong alignment on FDirectoryPath");
static_assert(sizeof(FDirectoryPath) == 0x000010, "Wrong size on FDirectoryPath");
static_assert(offsetof(FDirectoryPath, Path) == 0x000000, "Member 'FDirectoryPath::Path' has a wrong offset!");

// ScriptStruct CoreUObject.DoubleRangeBound
// 0x0010 (0x0010 - 0x0000)
struct FDoubleRangeBound final
{
public:
	ERangeBoundTypes                              Type;                                              // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        Value;                                             // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FDoubleRangeBound) == 0x000008, "Wrong alignment on FDoubleRangeBound");
static_assert(sizeof(FDoubleRangeBound) == 0x000010, "Wrong size on FDoubleRangeBound");
static_assert(offsetof(FDoubleRangeBound, Type) == 0x000000, "Member 'FDoubleRangeBound::Type' has a wrong offset!");
static_assert(offsetof(FDoubleRangeBound, Value) == 0x000008, "Member 'FDoubleRangeBound::Value' has a wrong offset!");

// ScriptStruct CoreUObject.DoubleRange
// 0x0020 (0x0020 - 0x0000)
struct FDoubleRange final
{
public:
	struct FDoubleRangeBound                      LowerBound;                                        // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDoubleRangeBound                      UpperBound;                                        // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FDoubleRange) == 0x000008, "Wrong alignment on FDoubleRange");
static_assert(sizeof(FDoubleRange) == 0x000020, "Wrong size on FDoubleRange");
static_assert(offsetof(FDoubleRange, LowerBound) == 0x000000, "Member 'FDoubleRange::LowerBound' has a wrong offset!");
static_assert(offsetof(FDoubleRange, UpperBound) == 0x000010, "Member 'FDoubleRange::UpperBound' has a wrong offset!");

// ScriptStruct CoreUObject.FallbackStruct
// 0x0001 (0x0001 - 0x0000)
struct FFallbackStruct final
{
public:
	uint8                                         Pad_0[0x1];                                        // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FFallbackStruct) == 0x000001, "Wrong alignment on FFallbackStruct");
static_assert(sizeof(FFallbackStruct) == 0x000001, "Wrong size on FFallbackStruct");

// ScriptStruct CoreUObject.FilePath
// 0x0010 (0x0010 - 0x0000)
struct FFilePath final
{
public:
	class FString                                 FilePath;                                          // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFilePath) == 0x000008, "Wrong alignment on FFilePath");
static_assert(sizeof(FFilePath) == 0x000010, "Wrong size on FFilePath");
static_assert(offsetof(FFilePath, FilePath) == 0x000000, "Member 'FFilePath::FilePath' has a wrong offset!");

// ScriptStruct CoreUObject.FloatInterval
// 0x0008 (0x0008 - 0x0000)
struct FFloatInterval final
{
public:
	float                                         Min;                                               // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Max;                                               // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFloatInterval) == 0x000004, "Wrong alignment on FFloatInterval");
static_assert(sizeof(FFloatInterval) == 0x000008, "Wrong size on FFloatInterval");
static_assert(offsetof(FFloatInterval, Min) == 0x000000, "Member 'FFloatInterval::Min' has a wrong offset!");
static_assert(offsetof(FFloatInterval, Max) == 0x000004, "Member 'FFloatInterval::Max' has a wrong offset!");

// ScriptStruct CoreUObject.FloatRangeBound
// 0x0008 (0x0008 - 0x0000)
struct FFloatRangeBound final
{
public:
	ERangeBoundTypes                              Type;                                              // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Value;                                             // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FFloatRangeBound) == 0x000004, "Wrong alignment on FFloatRangeBound");
static_assert(sizeof(FFloatRangeBound) == 0x000008, "Wrong size on FFloatRangeBound");
static_assert(offsetof(FFloatRangeBound, Type) == 0x000000, "Member 'FFloatRangeBound::Type' has a wrong offset!");
static_assert(offsetof(FFloatRangeBound, Value) == 0x000004, "Member 'FFloatRangeBound::Value' has a wrong offset!");

// ScriptStruct CoreUObject.FloatRange
// 0x0010 (0x0010 - 0x0000)
struct FFloatRange final
{
public:
	struct FFloatRangeBound                       LowerBound;                                        // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FFloatRangeBound                       UpperBound;                                        // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FFloatRange) == 0x000004, "Wrong alignment on FFloatRange");
static_assert(sizeof(FFloatRange) == 0x000010, "Wrong size on FFloatRange");
static_assert(offsetof(FFloatRange, LowerBound) == 0x000000, "Member 'FFloatRange::LowerBound' has a wrong offset!");
static_assert(offsetof(FFloatRange, UpperBound) == 0x000008, "Member 'FFloatRange::UpperBound' has a wrong offset!");

// ScriptStruct CoreUObject.FrameNumber
// 0x0004 (0x0004 - 0x0000)
struct FFrameNumber final
{
public:
	int32                                         Value;                                             // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFrameNumber) == 0x000004, "Wrong alignment on FFrameNumber");
static_assert(sizeof(FFrameNumber) == 0x000004, "Wrong size on FFrameNumber");
static_assert(offsetof(FFrameNumber, Value) == 0x000000, "Member 'FFrameNumber::Value' has a wrong offset!");

// ScriptStruct CoreUObject.FrameNumberRangeBound
// 0x0008 (0x0008 - 0x0000)
struct FFrameNumberRangeBound final
{
public:
	ERangeBoundTypes                              Type;                                              // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFrameNumber                           Value;                                             // 0x0004(0x0004)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FFrameNumberRangeBound) == 0x000004, "Wrong alignment on FFrameNumberRangeBound");
static_assert(sizeof(FFrameNumberRangeBound) == 0x000008, "Wrong size on FFrameNumberRangeBound");
static_assert(offsetof(FFrameNumberRangeBound, Type) == 0x000000, "Member 'FFrameNumberRangeBound::Type' has a wrong offset!");
static_assert(offsetof(FFrameNumberRangeBound, Value) == 0x000004, "Member 'FFrameNumberRangeBound::Value' has a wrong offset!");

// ScriptStruct CoreUObject.FrameNumberRange
// 0x0010 (0x0010 - 0x0000)
struct FFrameNumberRange final
{
public:
	struct FFrameNumberRangeBound                 LowerBound;                                        // 0x0000(0x0008)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FFrameNumberRangeBound                 UpperBound;                                        // 0x0008(0x0008)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FFrameNumberRange) == 0x000004, "Wrong alignment on FFrameNumberRange");
static_assert(sizeof(FFrameNumberRange) == 0x000010, "Wrong size on FFrameNumberRange");
static_assert(offsetof(FFrameNumberRange, LowerBound) == 0x000000, "Member 'FFrameNumberRange::LowerBound' has a wrong offset!");
static_assert(offsetof(FFrameNumberRange, UpperBound) == 0x000008, "Member 'FFrameNumberRange::UpperBound' has a wrong offset!");

// ScriptStruct CoreUObject.FrameRate
// 0x0008 (0x0008 - 0x0000)
struct FFrameRate final
{
public:
	int32                                         Numerator;                                         // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Denominator;                                       // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFrameRate) == 0x000004, "Wrong alignment on FFrameRate");
static_assert(sizeof(FFrameRate) == 0x000008, "Wrong size on FFrameRate");
static_assert(offsetof(FFrameRate, Numerator) == 0x000000, "Member 'FFrameRate::Numerator' has a wrong offset!");
static_assert(offsetof(FFrameRate, Denominator) == 0x000004, "Member 'FFrameRate::Denominator' has a wrong offset!");

// ScriptStruct CoreUObject.FrameTime
// 0x0008 (0x0008 - 0x0000)
struct FFrameTime final
{
public:
	struct FFrameNumber                           FrameNumber;                                       // 0x0000(0x0004)(BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SubFrame;                                          // 0x0004(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FFrameTime) == 0x000004, "Wrong alignment on FFrameTime");
static_assert(sizeof(FFrameTime) == 0x000008, "Wrong size on FFrameTime");
static_assert(offsetof(FFrameTime, FrameNumber) == 0x000000, "Member 'FFrameTime::FrameNumber' has a wrong offset!");
static_assert(offsetof(FFrameTime, SubFrame) == 0x000004, "Member 'FFrameTime::SubFrame' has a wrong offset!");

// ScriptStruct CoreUObject.InputDeviceId
// 0x0004 (0x0004 - 0x0000)
struct FInputDeviceId final
{
public:
	int32                                         InternalId;                                        // 0x0000(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FInputDeviceId) == 0x000004, "Wrong alignment on FInputDeviceId");
static_assert(sizeof(FInputDeviceId) == 0x000004, "Wrong size on FInputDeviceId");
static_assert(offsetof(FInputDeviceId, InternalId) == 0x000000, "Member 'FInputDeviceId::InternalId' has a wrong offset!");

// ScriptStruct CoreUObject.Int32Interval
// 0x0008 (0x0008 - 0x0000)
struct FInt32Interval final
{
public:
	int32                                         Min;                                               // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Max;                                               // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInt32Interval) == 0x000004, "Wrong alignment on FInt32Interval");
static_assert(sizeof(FInt32Interval) == 0x000008, "Wrong size on FInt32Interval");
static_assert(offsetof(FInt32Interval, Min) == 0x000000, "Member 'FInt32Interval::Min' has a wrong offset!");
static_assert(offsetof(FInt32Interval, Max) == 0x000004, "Member 'FInt32Interval::Max' has a wrong offset!");

// ScriptStruct CoreUObject.Int32Point
// 0x0008 (0x0008 - 0x0000)
struct FInt32Point final
{
public:
	int32                                         X;                                                 // 0x0000(0x0004)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Y;                                                 // 0x0004(0x0004)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInt32Point) == 0x000004, "Wrong alignment on FInt32Point");
static_assert(sizeof(FInt32Point) == 0x000008, "Wrong size on FInt32Point");
static_assert(offsetof(FInt32Point, X) == 0x000000, "Member 'FInt32Point::X' has a wrong offset!");
static_assert(offsetof(FInt32Point, Y) == 0x000004, "Member 'FInt32Point::Y' has a wrong offset!");

// ScriptStruct CoreUObject.Int32RangeBound
// 0x0008 (0x0008 - 0x0000)
struct FInt32RangeBound final
{
public:
	ERangeBoundTypes                              Type;                                              // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Value;                                             // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FInt32RangeBound) == 0x000004, "Wrong alignment on FInt32RangeBound");
static_assert(sizeof(FInt32RangeBound) == 0x000008, "Wrong size on FInt32RangeBound");
static_assert(offsetof(FInt32RangeBound, Type) == 0x000000, "Member 'FInt32RangeBound::Type' has a wrong offset!");
static_assert(offsetof(FInt32RangeBound, Value) == 0x000004, "Member 'FInt32RangeBound::Value' has a wrong offset!");

// ScriptStruct CoreUObject.Int32Range
// 0x0010 (0x0010 - 0x0000)
struct FInt32Range final
{
public:
	struct FInt32RangeBound                       LowerBound;                                        // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FInt32RangeBound                       UpperBound;                                        // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FInt32Range) == 0x000004, "Wrong alignment on FInt32Range");
static_assert(sizeof(FInt32Range) == 0x000010, "Wrong size on FInt32Range");
static_assert(offsetof(FInt32Range, LowerBound) == 0x000000, "Member 'FInt32Range::LowerBound' has a wrong offset!");
static_assert(offsetof(FInt32Range, UpperBound) == 0x000008, "Member 'FInt32Range::UpperBound' has a wrong offset!");

// ScriptStruct CoreUObject.Int32Vector
// 0x000C (0x000C - 0x0000)
struct FInt32Vector final
{
public:
	int32                                         X;                                                 // 0x0000(0x0004)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Y;                                                 // 0x0004(0x0004)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Z;                                                 // 0x0008(0x0004)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInt32Vector) == 0x000004, "Wrong alignment on FInt32Vector");
static_assert(sizeof(FInt32Vector) == 0x00000C, "Wrong size on FInt32Vector");
static_assert(offsetof(FInt32Vector, X) == 0x000000, "Member 'FInt32Vector::X' has a wrong offset!");
static_assert(offsetof(FInt32Vector, Y) == 0x000004, "Member 'FInt32Vector::Y' has a wrong offset!");
static_assert(offsetof(FInt32Vector, Z) == 0x000008, "Member 'FInt32Vector::Z' has a wrong offset!");

// ScriptStruct CoreUObject.Int32Vector2
// 0x0008 (0x0008 - 0x0000)
struct FInt32Vector2 final
{
public:
	int32                                         X;                                                 // 0x0000(0x0004)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Y;                                                 // 0x0004(0x0004)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInt32Vector2) == 0x000004, "Wrong alignment on FInt32Vector2");
static_assert(sizeof(FInt32Vector2) == 0x000008, "Wrong size on FInt32Vector2");
static_assert(offsetof(FInt32Vector2, X) == 0x000000, "Member 'FInt32Vector2::X' has a wrong offset!");
static_assert(offsetof(FInt32Vector2, Y) == 0x000004, "Member 'FInt32Vector2::Y' has a wrong offset!");

// ScriptStruct CoreUObject.Int32Vector4
// 0x0010 (0x0010 - 0x0000)
struct FInt32Vector4 final
{
public:
	int32                                         X;                                                 // 0x0000(0x0004)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Y;                                                 // 0x0004(0x0004)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Z;                                                 // 0x0008(0x0004)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         W;                                                 // 0x000C(0x0004)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInt32Vector4) == 0x000004, "Wrong alignment on FInt32Vector4");
static_assert(sizeof(FInt32Vector4) == 0x000010, "Wrong size on FInt32Vector4");
static_assert(offsetof(FInt32Vector4, X) == 0x000000, "Member 'FInt32Vector4::X' has a wrong offset!");
static_assert(offsetof(FInt32Vector4, Y) == 0x000004, "Member 'FInt32Vector4::Y' has a wrong offset!");
static_assert(offsetof(FInt32Vector4, Z) == 0x000008, "Member 'FInt32Vector4::Z' has a wrong offset!");
static_assert(offsetof(FInt32Vector4, W) == 0x00000C, "Member 'FInt32Vector4::W' has a wrong offset!");

// ScriptStruct CoreUObject.Int64Point
// 0x0010 (0x0010 - 0x0000)
struct FInt64Point final
{
public:
	int64                                         X;                                                 // 0x0000(0x0008)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         Y;                                                 // 0x0008(0x0008)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInt64Point) == 0x000008, "Wrong alignment on FInt64Point");
static_assert(sizeof(FInt64Point) == 0x000010, "Wrong size on FInt64Point");
static_assert(offsetof(FInt64Point, X) == 0x000000, "Member 'FInt64Point::X' has a wrong offset!");
static_assert(offsetof(FInt64Point, Y) == 0x000008, "Member 'FInt64Point::Y' has a wrong offset!");

// ScriptStruct CoreUObject.Int64Vector
// 0x0018 (0x0018 - 0x0000)
struct FInt64Vector final
{
public:
	int64                                         X;                                                 // 0x0000(0x0008)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         Y;                                                 // 0x0008(0x0008)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         Z;                                                 // 0x0010(0x0008)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInt64Vector) == 0x000008, "Wrong alignment on FInt64Vector");
static_assert(sizeof(FInt64Vector) == 0x000018, "Wrong size on FInt64Vector");
static_assert(offsetof(FInt64Vector, X) == 0x000000, "Member 'FInt64Vector::X' has a wrong offset!");
static_assert(offsetof(FInt64Vector, Y) == 0x000008, "Member 'FInt64Vector::Y' has a wrong offset!");
static_assert(offsetof(FInt64Vector, Z) == 0x000010, "Member 'FInt64Vector::Z' has a wrong offset!");

// ScriptStruct CoreUObject.Int64Vector2
// 0x0010 (0x0010 - 0x0000)
struct FInt64Vector2 final
{
public:
	int64                                         X;                                                 // 0x0000(0x0008)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         Y;                                                 // 0x0008(0x0008)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInt64Vector2) == 0x000008, "Wrong alignment on FInt64Vector2");
static_assert(sizeof(FInt64Vector2) == 0x000010, "Wrong size on FInt64Vector2");
static_assert(offsetof(FInt64Vector2, X) == 0x000000, "Member 'FInt64Vector2::X' has a wrong offset!");
static_assert(offsetof(FInt64Vector2, Y) == 0x000008, "Member 'FInt64Vector2::Y' has a wrong offset!");

// ScriptStruct CoreUObject.Int64Vector4
// 0x0020 (0x0020 - 0x0000)
struct FInt64Vector4 final
{
public:
	int64                                         X;                                                 // 0x0000(0x0008)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         Y;                                                 // 0x0008(0x0008)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         Z;                                                 // 0x0010(0x0008)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         W;                                                 // 0x0018(0x0008)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInt64Vector4) == 0x000008, "Wrong alignment on FInt64Vector4");
static_assert(sizeof(FInt64Vector4) == 0x000020, "Wrong size on FInt64Vector4");
static_assert(offsetof(FInt64Vector4, X) == 0x000000, "Member 'FInt64Vector4::X' has a wrong offset!");
static_assert(offsetof(FInt64Vector4, Y) == 0x000008, "Member 'FInt64Vector4::Y' has a wrong offset!");
static_assert(offsetof(FInt64Vector4, Z) == 0x000010, "Member 'FInt64Vector4::Z' has a wrong offset!");
static_assert(offsetof(FInt64Vector4, W) == 0x000018, "Member 'FInt64Vector4::W' has a wrong offset!");

// ScriptStruct CoreUObject.InterpCurvePointFloat
// 0x0014 (0x0014 - 0x0000)
struct FInterpCurvePointFloat final
{
public:
	float                                         InVal;                                             // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OutVal;                                            // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ArriveTangent;                                     // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeaveTangent;                                      // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EInterpCurveMode                              InterpMode;                                        // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FInterpCurvePointFloat) == 0x000004, "Wrong alignment on FInterpCurvePointFloat");
static_assert(sizeof(FInterpCurvePointFloat) == 0x000014, "Wrong size on FInterpCurvePointFloat");
static_assert(offsetof(FInterpCurvePointFloat, InVal) == 0x000000, "Member 'FInterpCurvePointFloat::InVal' has a wrong offset!");
static_assert(offsetof(FInterpCurvePointFloat, OutVal) == 0x000004, "Member 'FInterpCurvePointFloat::OutVal' has a wrong offset!");
static_assert(offsetof(FInterpCurvePointFloat, ArriveTangent) == 0x000008, "Member 'FInterpCurvePointFloat::ArriveTangent' has a wrong offset!");
static_assert(offsetof(FInterpCurvePointFloat, LeaveTangent) == 0x00000C, "Member 'FInterpCurvePointFloat::LeaveTangent' has a wrong offset!");
static_assert(offsetof(FInterpCurvePointFloat, InterpMode) == 0x000010, "Member 'FInterpCurvePointFloat::InterpMode' has a wrong offset!");

// ScriptStruct CoreUObject.InterpCurveFloat
// 0x0018 (0x0018 - 0x0000)
struct FInterpCurveFloat final
{
public:
	TArray<struct FInterpCurvePointFloat>         Points;                                            // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bIsLooped;                                         // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LoopKeyOffset;                                     // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInterpCurveFloat) == 0x000008, "Wrong alignment on FInterpCurveFloat");
static_assert(sizeof(FInterpCurveFloat) == 0x000018, "Wrong size on FInterpCurveFloat");
static_assert(offsetof(FInterpCurveFloat, Points) == 0x000000, "Member 'FInterpCurveFloat::Points' has a wrong offset!");
static_assert(offsetof(FInterpCurveFloat, bIsLooped) == 0x000010, "Member 'FInterpCurveFloat::bIsLooped' has a wrong offset!");
static_assert(offsetof(FInterpCurveFloat, LoopKeyOffset) == 0x000014, "Member 'FInterpCurveFloat::LoopKeyOffset' has a wrong offset!");

// ScriptStruct CoreUObject.LinearColor
// 0x0010 (0x0010 - 0x0000)
struct FLinearColor final
{
public:
	float                                         R;                                                 // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         G;                                                 // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         B;                                                 // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         A;                                                 // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLinearColor) == 0x000004, "Wrong alignment on FLinearColor");
static_assert(sizeof(FLinearColor) == 0x000010, "Wrong size on FLinearColor");
static_assert(offsetof(FLinearColor, R) == 0x000000, "Member 'FLinearColor::R' has a wrong offset!");
static_assert(offsetof(FLinearColor, G) == 0x000004, "Member 'FLinearColor::G' has a wrong offset!");
static_assert(offsetof(FLinearColor, B) == 0x000008, "Member 'FLinearColor::B' has a wrong offset!");
static_assert(offsetof(FLinearColor, A) == 0x00000C, "Member 'FLinearColor::A' has a wrong offset!");

// ScriptStruct CoreUObject.InterpCurvePointLinearColor
// 0x0038 (0x0038 - 0x0000)
struct FInterpCurvePointLinearColor final
{
public:
	float                                         InVal;                                             // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           OutVal;                                            // 0x0004(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           ArriveTangent;                                     // 0x0014(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           LeaveTangent;                                      // 0x0024(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EInterpCurveMode                              InterpMode;                                        // 0x0034(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FInterpCurvePointLinearColor) == 0x000004, "Wrong alignment on FInterpCurvePointLinearColor");
static_assert(sizeof(FInterpCurvePointLinearColor) == 0x000038, "Wrong size on FInterpCurvePointLinearColor");
static_assert(offsetof(FInterpCurvePointLinearColor, InVal) == 0x000000, "Member 'FInterpCurvePointLinearColor::InVal' has a wrong offset!");
static_assert(offsetof(FInterpCurvePointLinearColor, OutVal) == 0x000004, "Member 'FInterpCurvePointLinearColor::OutVal' has a wrong offset!");
static_assert(offsetof(FInterpCurvePointLinearColor, ArriveTangent) == 0x000014, "Member 'FInterpCurvePointLinearColor::ArriveTangent' has a wrong offset!");
static_assert(offsetof(FInterpCurvePointLinearColor, LeaveTangent) == 0x000024, "Member 'FInterpCurvePointLinearColor::LeaveTangent' has a wrong offset!");
static_assert(offsetof(FInterpCurvePointLinearColor, InterpMode) == 0x000034, "Member 'FInterpCurvePointLinearColor::InterpMode' has a wrong offset!");

// ScriptStruct CoreUObject.InterpCurveLinearColor
// 0x0018 (0x0018 - 0x0000)
struct FInterpCurveLinearColor final
{
public:
	TArray<struct FInterpCurvePointLinearColor>   Points;                                            // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bIsLooped;                                         // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LoopKeyOffset;                                     // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInterpCurveLinearColor) == 0x000008, "Wrong alignment on FInterpCurveLinearColor");
static_assert(sizeof(FInterpCurveLinearColor) == 0x000018, "Wrong size on FInterpCurveLinearColor");
static_assert(offsetof(FInterpCurveLinearColor, Points) == 0x000000, "Member 'FInterpCurveLinearColor::Points' has a wrong offset!");
static_assert(offsetof(FInterpCurveLinearColor, bIsLooped) == 0x000010, "Member 'FInterpCurveLinearColor::bIsLooped' has a wrong offset!");
static_assert(offsetof(FInterpCurveLinearColor, LoopKeyOffset) == 0x000014, "Member 'FInterpCurveLinearColor::LoopKeyOffset' has a wrong offset!");

// ScriptStruct CoreUObject.IntPoint
// 0x0008 (0x0008 - 0x0000)
struct FIntPoint final
{
public:
	int32                                         X;                                                 // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Y;                                                 // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FIntPoint) == 0x000004, "Wrong alignment on FIntPoint");
static_assert(sizeof(FIntPoint) == 0x000008, "Wrong size on FIntPoint");
static_assert(offsetof(FIntPoint, X) == 0x000000, "Member 'FIntPoint::X' has a wrong offset!");
static_assert(offsetof(FIntPoint, Y) == 0x000004, "Member 'FIntPoint::Y' has a wrong offset!");

// ScriptStruct CoreUObject.IntVector
// 0x000C (0x000C - 0x0000)
struct FIntVector final
{
public:
	int32                                         X;                                                 // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Y;                                                 // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Z;                                                 // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FIntVector) == 0x000004, "Wrong alignment on FIntVector");
static_assert(sizeof(FIntVector) == 0x00000C, "Wrong size on FIntVector");
static_assert(offsetof(FIntVector, X) == 0x000000, "Member 'FIntVector::X' has a wrong offset!");
static_assert(offsetof(FIntVector, Y) == 0x000004, "Member 'FIntVector::Y' has a wrong offset!");
static_assert(offsetof(FIntVector, Z) == 0x000008, "Member 'FIntVector::Z' has a wrong offset!");

// ScriptStruct CoreUObject.IntVector2
// 0x0008 (0x0008 - 0x0000)
struct FIntVector2 final
{
public:
	int32                                         X;                                                 // 0x0000(0x0004)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Y;                                                 // 0x0004(0x0004)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FIntVector2) == 0x000004, "Wrong alignment on FIntVector2");
static_assert(sizeof(FIntVector2) == 0x000008, "Wrong size on FIntVector2");
static_assert(offsetof(FIntVector2, X) == 0x000000, "Member 'FIntVector2::X' has a wrong offset!");
static_assert(offsetof(FIntVector2, Y) == 0x000004, "Member 'FIntVector2::Y' has a wrong offset!");

// ScriptStruct CoreUObject.IntVector4
// 0x0010 (0x0010 - 0x0000)
struct FIntVector4 final
{
public:
	int32                                         X;                                                 // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Y;                                                 // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Z;                                                 // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         W;                                                 // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FIntVector4) == 0x000004, "Wrong alignment on FIntVector4");
static_assert(sizeof(FIntVector4) == 0x000010, "Wrong size on FIntVector4");
static_assert(offsetof(FIntVector4, X) == 0x000000, "Member 'FIntVector4::X' has a wrong offset!");
static_assert(offsetof(FIntVector4, Y) == 0x000004, "Member 'FIntVector4::Y' has a wrong offset!");
static_assert(offsetof(FIntVector4, Z) == 0x000008, "Member 'FIntVector4::Z' has a wrong offset!");
static_assert(offsetof(FIntVector4, W) == 0x00000C, "Member 'FIntVector4::W' has a wrong offset!");

// ScriptStruct CoreUObject.Plane
// 0x0008 (0x0020 - 0x0018)
struct alignas(0x10) FPlane final : public FVector
{
public:
	double                                        W;                                                 // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlane) == 0x000010, "Wrong alignment on FPlane");
static_assert(sizeof(FPlane) == 0x000020, "Wrong size on FPlane");
static_assert(offsetof(FPlane, W) == 0x000018, "Member 'FPlane::W' has a wrong offset!");

// ScriptStruct CoreUObject.Matrix
// 0x0080 (0x0080 - 0x0000)
struct FMatrix final
{
public:
	struct FPlane                                 XPlane;                                            // 0x0000(0x0020)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPlane                                 YPlane;                                            // 0x0020(0x0020)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPlane                                 ZPlane;                                            // 0x0040(0x0020)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPlane                                 WPlane;                                            // 0x0060(0x0020)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMatrix) == 0x000010, "Wrong alignment on FMatrix");
static_assert(sizeof(FMatrix) == 0x000080, "Wrong size on FMatrix");
static_assert(offsetof(FMatrix, XPlane) == 0x000000, "Member 'FMatrix::XPlane' has a wrong offset!");
static_assert(offsetof(FMatrix, YPlane) == 0x000020, "Member 'FMatrix::YPlane' has a wrong offset!");
static_assert(offsetof(FMatrix, ZPlane) == 0x000040, "Member 'FMatrix::ZPlane' has a wrong offset!");
static_assert(offsetof(FMatrix, WPlane) == 0x000060, "Member 'FMatrix::WPlane' has a wrong offset!");

// ScriptStruct CoreUObject.Plane4d
// 0x0008 (0x0020 - 0x0018)
struct alignas(0x10) FPlane4d final : public FVector3d
{
public:
	double                                        W;                                                 // 0x0018(0x0008)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlane4d) == 0x000010, "Wrong alignment on FPlane4d");
static_assert(sizeof(FPlane4d) == 0x000020, "Wrong size on FPlane4d");
static_assert(offsetof(FPlane4d, W) == 0x000018, "Member 'FPlane4d::W' has a wrong offset!");

// ScriptStruct CoreUObject.Matrix44d
// 0x0080 (0x0080 - 0x0000)
struct FMatrix44d final
{
public:
	struct FPlane4d                               XPlane;                                            // 0x0000(0x0020)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPlane4d                               YPlane;                                            // 0x0020(0x0020)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPlane4d                               ZPlane;                                            // 0x0040(0x0020)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPlane4d                               WPlane;                                            // 0x0060(0x0020)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMatrix44d) == 0x000010, "Wrong alignment on FMatrix44d");
static_assert(sizeof(FMatrix44d) == 0x000080, "Wrong size on FMatrix44d");
static_assert(offsetof(FMatrix44d, XPlane) == 0x000000, "Member 'FMatrix44d::XPlane' has a wrong offset!");
static_assert(offsetof(FMatrix44d, YPlane) == 0x000020, "Member 'FMatrix44d::YPlane' has a wrong offset!");
static_assert(offsetof(FMatrix44d, ZPlane) == 0x000040, "Member 'FMatrix44d::ZPlane' has a wrong offset!");
static_assert(offsetof(FMatrix44d, WPlane) == 0x000060, "Member 'FMatrix44d::WPlane' has a wrong offset!");

// ScriptStruct CoreUObject.Plane4f
// 0x0004 (0x0010 - 0x000C)
struct alignas(0x10) FPlane4f final : public FVector3f
{
public:
	float                                         W;                                                 // 0x000C(0x0004)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlane4f) == 0x000010, "Wrong alignment on FPlane4f");
static_assert(sizeof(FPlane4f) == 0x000010, "Wrong size on FPlane4f");
static_assert(offsetof(FPlane4f, W) == 0x00000C, "Member 'FPlane4f::W' has a wrong offset!");

// ScriptStruct CoreUObject.Matrix44f
// 0x0040 (0x0040 - 0x0000)
struct FMatrix44f final
{
public:
	struct FPlane4f                               XPlane;                                            // 0x0000(0x0010)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPlane4f                               YPlane;                                            // 0x0010(0x0010)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPlane4f                               ZPlane;                                            // 0x0020(0x0010)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPlane4f                               WPlane;                                            // 0x0030(0x0010)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMatrix44f) == 0x000010, "Wrong alignment on FMatrix44f");
static_assert(sizeof(FMatrix44f) == 0x000040, "Wrong size on FMatrix44f");
static_assert(offsetof(FMatrix44f, XPlane) == 0x000000, "Member 'FMatrix44f::XPlane' has a wrong offset!");
static_assert(offsetof(FMatrix44f, YPlane) == 0x000010, "Member 'FMatrix44f::YPlane' has a wrong offset!");
static_assert(offsetof(FMatrix44f, ZPlane) == 0x000020, "Member 'FMatrix44f::ZPlane' has a wrong offset!");
static_assert(offsetof(FMatrix44f, WPlane) == 0x000030, "Member 'FMatrix44f::WPlane' has a wrong offset!");

// ScriptStruct CoreUObject.OrientedBox
// 0x0078 (0x0078 - 0x0000)
struct FOrientedBox final
{
public:
	struct FVector                                Center;                                            // 0x0000(0x0018)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                AxisX;                                             // 0x0018(0x0018)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                AxisY;                                             // 0x0030(0x0018)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                AxisZ;                                             // 0x0048(0x0018)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        ExtentX;                                           // 0x0060(0x0008)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        ExtentY;                                           // 0x0068(0x0008)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        ExtentZ;                                           // 0x0070(0x0008)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrientedBox) == 0x000008, "Wrong alignment on FOrientedBox");
static_assert(sizeof(FOrientedBox) == 0x000078, "Wrong size on FOrientedBox");
static_assert(offsetof(FOrientedBox, Center) == 0x000000, "Member 'FOrientedBox::Center' has a wrong offset!");
static_assert(offsetof(FOrientedBox, AxisX) == 0x000018, "Member 'FOrientedBox::AxisX' has a wrong offset!");
static_assert(offsetof(FOrientedBox, AxisY) == 0x000030, "Member 'FOrientedBox::AxisY' has a wrong offset!");
static_assert(offsetof(FOrientedBox, AxisZ) == 0x000048, "Member 'FOrientedBox::AxisZ' has a wrong offset!");
static_assert(offsetof(FOrientedBox, ExtentX) == 0x000060, "Member 'FOrientedBox::ExtentX' has a wrong offset!");
static_assert(offsetof(FOrientedBox, ExtentY) == 0x000068, "Member 'FOrientedBox::ExtentY' has a wrong offset!");
static_assert(offsetof(FOrientedBox, ExtentZ) == 0x000070, "Member 'FOrientedBox::ExtentZ' has a wrong offset!");

// ScriptStruct CoreUObject.PackedNormal
// 0x0004 (0x0004 - 0x0000)
struct FPackedNormal final
{
public:
	uint8                                         X;                                                 // 0x0000(0x0001)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Y;                                                 // 0x0001(0x0001)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Z;                                                 // 0x0002(0x0001)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         W;                                                 // 0x0003(0x0001)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPackedNormal) == 0x000001, "Wrong alignment on FPackedNormal");
static_assert(sizeof(FPackedNormal) == 0x000004, "Wrong size on FPackedNormal");
static_assert(offsetof(FPackedNormal, X) == 0x000000, "Member 'FPackedNormal::X' has a wrong offset!");
static_assert(offsetof(FPackedNormal, Y) == 0x000001, "Member 'FPackedNormal::Y' has a wrong offset!");
static_assert(offsetof(FPackedNormal, Z) == 0x000002, "Member 'FPackedNormal::Z' has a wrong offset!");
static_assert(offsetof(FPackedNormal, W) == 0x000003, "Member 'FPackedNormal::W' has a wrong offset!");

// ScriptStruct CoreUObject.PackedRGB10A2N
// 0x0004 (0x0004 - 0x0000)
struct FPackedRGB10A2N final
{
public:
	int32                                         Packed;                                            // 0x0000(0x0004)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPackedRGB10A2N) == 0x000004, "Wrong alignment on FPackedRGB10A2N");
static_assert(sizeof(FPackedRGB10A2N) == 0x000004, "Wrong size on FPackedRGB10A2N");
static_assert(offsetof(FPackedRGB10A2N, Packed) == 0x000000, "Member 'FPackedRGB10A2N::Packed' has a wrong offset!");

// ScriptStruct CoreUObject.PackedRGBA16N
// 0x0008 (0x0008 - 0x0000)
struct FPackedRGBA16N final
{
public:
	int32                                         XY;                                                // 0x0000(0x0004)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ZW;                                                // 0x0004(0x0004)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPackedRGBA16N) == 0x000004, "Wrong alignment on FPackedRGBA16N");
static_assert(sizeof(FPackedRGBA16N) == 0x000008, "Wrong size on FPackedRGBA16N");
static_assert(offsetof(FPackedRGBA16N, XY) == 0x000000, "Member 'FPackedRGBA16N::XY' has a wrong offset!");
static_assert(offsetof(FPackedRGBA16N, ZW) == 0x000004, "Member 'FPackedRGBA16N::ZW' has a wrong offset!");

// ScriptStruct CoreUObject.PlatformUserId
// 0x0004 (0x0004 - 0x0000)
struct FPlatformUserId final
{
public:
	int32                                         InternalId;                                        // 0x0000(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FPlatformUserId) == 0x000004, "Wrong alignment on FPlatformUserId");
static_assert(sizeof(FPlatformUserId) == 0x000004, "Wrong size on FPlatformUserId");
static_assert(offsetof(FPlatformUserId, InternalId) == 0x000000, "Member 'FPlatformUserId::InternalId' has a wrong offset!");

// ScriptStruct CoreUObject.PlatformInputDeviceState
// 0x0008 (0x0008 - 0x0000)
struct FPlatformInputDeviceState final
{
public:
	struct FPlatformUserId                        OwningPlatformUser;                                // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EInputDeviceConnectionState                   ConnectionState;                                   // 0x0004(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPlatformInputDeviceState) == 0x000004, "Wrong alignment on FPlatformInputDeviceState");
static_assert(sizeof(FPlatformInputDeviceState) == 0x000008, "Wrong size on FPlatformInputDeviceState");
static_assert(offsetof(FPlatformInputDeviceState, OwningPlatformUser) == 0x000000, "Member 'FPlatformInputDeviceState::OwningPlatformUser' has a wrong offset!");
static_assert(offsetof(FPlatformInputDeviceState, ConnectionState) == 0x000004, "Member 'FPlatformInputDeviceState::ConnectionState' has a wrong offset!");

// ScriptStruct CoreUObject.PolyglotTextData
// 0x00B0 (0x00B0 - 0x0000)
struct FPolyglotTextData final
{
public:
	ELocalizedTextSourceCategory                  Category;                                          // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 NativeCulture;                                     // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 NameSpace;                                         // 0x0018(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Key;                                               // 0x0028(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 NativeString;                                      // 0x0038(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FString, class FString>            LocalizedStrings;                                  // 0x0048(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          bIsMinimalPatch;                                   // 0x0098(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_99[0x7];                                       // 0x0099(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   CachedText;                                        // 0x00A0(0x0010)(Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPolyglotTextData) == 0x000008, "Wrong alignment on FPolyglotTextData");
static_assert(sizeof(FPolyglotTextData) == 0x0000B0, "Wrong size on FPolyglotTextData");
static_assert(offsetof(FPolyglotTextData, Category) == 0x000000, "Member 'FPolyglotTextData::Category' has a wrong offset!");
static_assert(offsetof(FPolyglotTextData, NativeCulture) == 0x000008, "Member 'FPolyglotTextData::NativeCulture' has a wrong offset!");
static_assert(offsetof(FPolyglotTextData, NameSpace) == 0x000018, "Member 'FPolyglotTextData::NameSpace' has a wrong offset!");
static_assert(offsetof(FPolyglotTextData, Key) == 0x000028, "Member 'FPolyglotTextData::Key' has a wrong offset!");
static_assert(offsetof(FPolyglotTextData, NativeString) == 0x000038, "Member 'FPolyglotTextData::NativeString' has a wrong offset!");
static_assert(offsetof(FPolyglotTextData, LocalizedStrings) == 0x000048, "Member 'FPolyglotTextData::LocalizedStrings' has a wrong offset!");
static_assert(offsetof(FPolyglotTextData, bIsMinimalPatch) == 0x000098, "Member 'FPolyglotTextData::bIsMinimalPatch' has a wrong offset!");
static_assert(offsetof(FPolyglotTextData, CachedText) == 0x0000A0, "Member 'FPolyglotTextData::CachedText' has a wrong offset!");

// ScriptStruct CoreUObject.PrimaryAssetType
// 0x0008 (0x0008 - 0x0000)
struct FPrimaryAssetType final
{
public:
	class FName                                   Name;                                              // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPrimaryAssetType) == 0x000004, "Wrong alignment on FPrimaryAssetType");
static_assert(sizeof(FPrimaryAssetType) == 0x000008, "Wrong size on FPrimaryAssetType");
static_assert(offsetof(FPrimaryAssetType, Name) == 0x000000, "Member 'FPrimaryAssetType::Name' has a wrong offset!");

// ScriptStruct CoreUObject.PrimaryAssetId
// 0x0010 (0x0010 - 0x0000)
struct FPrimaryAssetId final
{
public:
	struct FPrimaryAssetType                      PrimaryAssetType;                                  // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PrimaryAssetName;                                  // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPrimaryAssetId) == 0x000004, "Wrong alignment on FPrimaryAssetId");
static_assert(sizeof(FPrimaryAssetId) == 0x000010, "Wrong size on FPrimaryAssetId");
static_assert(offsetof(FPrimaryAssetId, PrimaryAssetType) == 0x000000, "Member 'FPrimaryAssetId::PrimaryAssetType' has a wrong offset!");
static_assert(offsetof(FPrimaryAssetId, PrimaryAssetName) == 0x000008, "Member 'FPrimaryAssetId::PrimaryAssetName' has a wrong offset!");

// ScriptStruct CoreUObject.QualifiedFrameTime
// 0x0010 (0x0010 - 0x0000)
struct FQualifiedFrameTime final
{
public:
	struct FFrameTime                             Time;                                              // 0x0000(0x0008)(BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFrameRate                             Rate;                                              // 0x0008(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FQualifiedFrameTime) == 0x000004, "Wrong alignment on FQualifiedFrameTime");
static_assert(sizeof(FQualifiedFrameTime) == 0x000010, "Wrong size on FQualifiedFrameTime");
static_assert(offsetof(FQualifiedFrameTime, Time) == 0x000000, "Member 'FQualifiedFrameTime::Time' has a wrong offset!");
static_assert(offsetof(FQualifiedFrameTime, Rate) == 0x000008, "Member 'FQualifiedFrameTime::Rate' has a wrong offset!");

// ScriptStruct CoreUObject.Quat4d
// 0x0020 (0x0020 - 0x0000)
struct alignas(0x10) FQuat4d final
{
public:
	double                                        X;                                                 // 0x0000(0x0008)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        Y;                                                 // 0x0008(0x0008)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        Z;                                                 // 0x0010(0x0008)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        W;                                                 // 0x0018(0x0008)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FQuat4d) == 0x000010, "Wrong alignment on FQuat4d");
static_assert(sizeof(FQuat4d) == 0x000020, "Wrong size on FQuat4d");
static_assert(offsetof(FQuat4d, X) == 0x000000, "Member 'FQuat4d::X' has a wrong offset!");
static_assert(offsetof(FQuat4d, Y) == 0x000008, "Member 'FQuat4d::Y' has a wrong offset!");
static_assert(offsetof(FQuat4d, Z) == 0x000010, "Member 'FQuat4d::Z' has a wrong offset!");
static_assert(offsetof(FQuat4d, W) == 0x000018, "Member 'FQuat4d::W' has a wrong offset!");

// ScriptStruct CoreUObject.Quat4f
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x10) FQuat4f final
{
public:
	float                                         X;                                                 // 0x0000(0x0004)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Y;                                                 // 0x0004(0x0004)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Z;                                                 // 0x0008(0x0004)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         W;                                                 // 0x000C(0x0004)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FQuat4f) == 0x000010, "Wrong alignment on FQuat4f");
static_assert(sizeof(FQuat4f) == 0x000010, "Wrong size on FQuat4f");
static_assert(offsetof(FQuat4f, X) == 0x000000, "Member 'FQuat4f::X' has a wrong offset!");
static_assert(offsetof(FQuat4f, Y) == 0x000004, "Member 'FQuat4f::Y' has a wrong offset!");
static_assert(offsetof(FQuat4f, Z) == 0x000008, "Member 'FQuat4f::Z' has a wrong offset!");
static_assert(offsetof(FQuat4f, W) == 0x00000C, "Member 'FQuat4f::W' has a wrong offset!");

// ScriptStruct CoreUObject.RandomStream
// 0x0008 (0x0008 - 0x0000)
struct FRandomStream final
{
public:
	int32                                         InitialSeed;                                       // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Seed;                                              // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRandomStream) == 0x000004, "Wrong alignment on FRandomStream");
static_assert(sizeof(FRandomStream) == 0x000008, "Wrong size on FRandomStream");
static_assert(offsetof(FRandomStream, InitialSeed) == 0x000000, "Member 'FRandomStream::InitialSeed' has a wrong offset!");
static_assert(offsetof(FRandomStream, Seed) == 0x000004, "Member 'FRandomStream::Seed' has a wrong offset!");

// ScriptStruct CoreUObject.Ray
// 0x0030 (0x0030 - 0x0000)
struct FRay final
{
public:
	struct FVector                                Origin;                                            // 0x0000(0x0018)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Direction;                                         // 0x0018(0x0018)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRay) == 0x000008, "Wrong alignment on FRay");
static_assert(sizeof(FRay) == 0x000030, "Wrong size on FRay");
static_assert(offsetof(FRay, Origin) == 0x000000, "Member 'FRay::Origin' has a wrong offset!");
static_assert(offsetof(FRay, Direction) == 0x000018, "Member 'FRay::Direction' has a wrong offset!");

// ScriptStruct CoreUObject.Ray3d
// 0x0030 (0x0030 - 0x0000)
struct FRay3d final
{
public:
	struct FVector3d                              Origin;                                            // 0x0000(0x0018)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector3d                              Direction;                                         // 0x0018(0x0018)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRay3d) == 0x000008, "Wrong alignment on FRay3d");
static_assert(sizeof(FRay3d) == 0x000030, "Wrong size on FRay3d");
static_assert(offsetof(FRay3d, Origin) == 0x000000, "Member 'FRay3d::Origin' has a wrong offset!");
static_assert(offsetof(FRay3d, Direction) == 0x000018, "Member 'FRay3d::Direction' has a wrong offset!");

// ScriptStruct CoreUObject.Ray3f
// 0x0018 (0x0018 - 0x0000)
struct FRay3f final
{
public:
	struct FVector3f                              Origin;                                            // 0x0000(0x000C)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector3f                              Direction;                                         // 0x000C(0x000C)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRay3f) == 0x000004, "Wrong alignment on FRay3f");
static_assert(sizeof(FRay3f) == 0x000018, "Wrong size on FRay3f");
static_assert(offsetof(FRay3f, Origin) == 0x000000, "Member 'FRay3f::Origin' has a wrong offset!");
static_assert(offsetof(FRay3f, Direction) == 0x00000C, "Member 'FRay3f::Direction' has a wrong offset!");

// ScriptStruct CoreUObject.Rotator
// 0x0018 (0x0018 - 0x0000)
struct FRotator final
{
public:
	double                                        Pitch;                                             // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        Yaw;                                               // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        Roll;                                              // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRotator) == 0x000008, "Wrong alignment on FRotator");
static_assert(sizeof(FRotator) == 0x000018, "Wrong size on FRotator");
static_assert(offsetof(FRotator, Pitch) == 0x000000, "Member 'FRotator::Pitch' has a wrong offset!");
static_assert(offsetof(FRotator, Yaw) == 0x000008, "Member 'FRotator::Yaw' has a wrong offset!");
static_assert(offsetof(FRotator, Roll) == 0x000010, "Member 'FRotator::Roll' has a wrong offset!");

// ScriptStruct CoreUObject.Rotator3d
// 0x0018 (0x0018 - 0x0000)
struct FRotator3d final
{
public:
	double                                        Pitch;                                             // 0x0000(0x0008)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        Yaw;                                               // 0x0008(0x0008)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        Roll;                                              // 0x0010(0x0008)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRotator3d) == 0x000008, "Wrong alignment on FRotator3d");
static_assert(sizeof(FRotator3d) == 0x000018, "Wrong size on FRotator3d");
static_assert(offsetof(FRotator3d, Pitch) == 0x000000, "Member 'FRotator3d::Pitch' has a wrong offset!");
static_assert(offsetof(FRotator3d, Yaw) == 0x000008, "Member 'FRotator3d::Yaw' has a wrong offset!");
static_assert(offsetof(FRotator3d, Roll) == 0x000010, "Member 'FRotator3d::Roll' has a wrong offset!");

// ScriptStruct CoreUObject.Rotator3f
// 0x000C (0x000C - 0x0000)
struct FRotator3f final
{
public:
	float                                         Pitch;                                             // 0x0000(0x0004)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Yaw;                                               // 0x0004(0x0004)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Roll;                                              // 0x0008(0x0004)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRotator3f) == 0x000004, "Wrong alignment on FRotator3f");
static_assert(sizeof(FRotator3f) == 0x00000C, "Wrong size on FRotator3f");
static_assert(offsetof(FRotator3f, Pitch) == 0x000000, "Member 'FRotator3f::Pitch' has a wrong offset!");
static_assert(offsetof(FRotator3f, Yaw) == 0x000004, "Member 'FRotator3f::Yaw' has a wrong offset!");
static_assert(offsetof(FRotator3f, Roll) == 0x000008, "Member 'FRotator3f::Roll' has a wrong offset!");

// ScriptStruct CoreUObject.SoftClassPath
// 0x0000 (0x0020 - 0x0020)
struct FSoftClassPath final : public FSoftObjectPath
{
};
static_assert(alignof(FSoftClassPath) == 0x000008, "Wrong alignment on FSoftClassPath");
static_assert(sizeof(FSoftClassPath) == 0x000020, "Wrong size on FSoftClassPath");

// ScriptStruct CoreUObject.Sphere
// 0x0020 (0x0020 - 0x0000)
struct FSphere final
{
public:
	struct FVector                                Center;                                            // 0x0000(0x0018)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        W;                                                 // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSphere) == 0x000008, "Wrong alignment on FSphere");
static_assert(sizeof(FSphere) == 0x000020, "Wrong size on FSphere");
static_assert(offsetof(FSphere, Center) == 0x000000, "Member 'FSphere::Center' has a wrong offset!");
static_assert(offsetof(FSphere, W) == 0x000018, "Member 'FSphere::W' has a wrong offset!");

// ScriptStruct CoreUObject.Sphere3d
// 0x0020 (0x0020 - 0x0000)
struct FSphere3d final
{
public:
	struct FVector3d                              Center;                                            // 0x0000(0x0018)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        W;                                                 // 0x0018(0x0008)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSphere3d) == 0x000008, "Wrong alignment on FSphere3d");
static_assert(sizeof(FSphere3d) == 0x000020, "Wrong size on FSphere3d");
static_assert(offsetof(FSphere3d, Center) == 0x000000, "Member 'FSphere3d::Center' has a wrong offset!");
static_assert(offsetof(FSphere3d, W) == 0x000018, "Member 'FSphere3d::W' has a wrong offset!");

// ScriptStruct CoreUObject.Sphere3f
// 0x0010 (0x0010 - 0x0000)
struct FSphere3f final
{
public:
	struct FVector3f                              Center;                                            // 0x0000(0x000C)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         W;                                                 // 0x000C(0x0004)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSphere3f) == 0x000004, "Wrong alignment on FSphere3f");
static_assert(sizeof(FSphere3f) == 0x000010, "Wrong size on FSphere3f");
static_assert(offsetof(FSphere3f, Center) == 0x000000, "Member 'FSphere3f::Center' has a wrong offset!");
static_assert(offsetof(FSphere3f, W) == 0x00000C, "Member 'FSphere3f::W' has a wrong offset!");

// ScriptStruct CoreUObject.TemplateString
// 0x0010 (0x0010 - 0x0000)
struct FTemplateString final
{
public:
	class FString                                 Template;                                          // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTemplateString) == 0x000008, "Wrong alignment on FTemplateString");
static_assert(sizeof(FTemplateString) == 0x000010, "Wrong size on FTemplateString");
static_assert(offsetof(FTemplateString, Template) == 0x000000, "Member 'FTemplateString::Template' has a wrong offset!");

// ScriptStruct CoreUObject.TestUndeclaredScriptStructObjectReferencesTest
// 0x0058 (0x0058 - 0x0000)
struct FTestUndeclaredScriptStructObjectReferencesTest final
{
public:
	class UObject*                                StrongObjectPointer;                               // 0x0000(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UObject>                 SoftObjectPointer;                                 // 0x0008(0x0028)(Transient, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        SoftObjectPath;                                    // 0x0030(0x0020)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UObject>                 WeakObjectPointer;                                 // 0x0050(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTestUndeclaredScriptStructObjectReferencesTest) == 0x000008, "Wrong alignment on FTestUndeclaredScriptStructObjectReferencesTest");
static_assert(sizeof(FTestUndeclaredScriptStructObjectReferencesTest) == 0x000058, "Wrong size on FTestUndeclaredScriptStructObjectReferencesTest");
static_assert(offsetof(FTestUndeclaredScriptStructObjectReferencesTest, StrongObjectPointer) == 0x000000, "Member 'FTestUndeclaredScriptStructObjectReferencesTest::StrongObjectPointer' has a wrong offset!");
static_assert(offsetof(FTestUndeclaredScriptStructObjectReferencesTest, SoftObjectPointer) == 0x000008, "Member 'FTestUndeclaredScriptStructObjectReferencesTest::SoftObjectPointer' has a wrong offset!");
static_assert(offsetof(FTestUndeclaredScriptStructObjectReferencesTest, SoftObjectPath) == 0x000030, "Member 'FTestUndeclaredScriptStructObjectReferencesTest::SoftObjectPath' has a wrong offset!");
static_assert(offsetof(FTestUndeclaredScriptStructObjectReferencesTest, WeakObjectPointer) == 0x000050, "Member 'FTestUndeclaredScriptStructObjectReferencesTest::WeakObjectPointer' has a wrong offset!");

// ScriptStruct CoreUObject.TestUninitializedScriptStructMembersTest
// 0x0018 (0x0018 - 0x0000)
struct FTestUninitializedScriptStructMembersTest final
{
public:
	class UObject*                                UninitializedObjectReference;                      // 0x0000(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                InitializedObjectReference;                        // 0x0008(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UnusedValue;                                       // 0x0010(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTestUninitializedScriptStructMembersTest) == 0x000008, "Wrong alignment on FTestUninitializedScriptStructMembersTest");
static_assert(sizeof(FTestUninitializedScriptStructMembersTest) == 0x000018, "Wrong size on FTestUninitializedScriptStructMembersTest");
static_assert(offsetof(FTestUninitializedScriptStructMembersTest, UninitializedObjectReference) == 0x000000, "Member 'FTestUninitializedScriptStructMembersTest::UninitializedObjectReference' has a wrong offset!");
static_assert(offsetof(FTestUninitializedScriptStructMembersTest, InitializedObjectReference) == 0x000008, "Member 'FTestUninitializedScriptStructMembersTest::InitializedObjectReference' has a wrong offset!");
static_assert(offsetof(FTestUninitializedScriptStructMembersTest, UnusedValue) == 0x000010, "Member 'FTestUninitializedScriptStructMembersTest::UnusedValue' has a wrong offset!");

// ScriptStruct CoreUObject.Timecode
// 0x0014 (0x0014 - 0x0000)
struct FTimecode final
{
public:
	int32                                         Hours;                                             // 0x0000(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Minutes;                                           // 0x0004(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Seconds;                                           // 0x0008(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Frames;                                            // 0x000C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDropFrameFormat;                                  // 0x0010(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTimecode) == 0x000004, "Wrong alignment on FTimecode");
static_assert(sizeof(FTimecode) == 0x000014, "Wrong size on FTimecode");
static_assert(offsetof(FTimecode, Hours) == 0x000000, "Member 'FTimecode::Hours' has a wrong offset!");
static_assert(offsetof(FTimecode, Minutes) == 0x000004, "Member 'FTimecode::Minutes' has a wrong offset!");
static_assert(offsetof(FTimecode, Seconds) == 0x000008, "Member 'FTimecode::Seconds' has a wrong offset!");
static_assert(offsetof(FTimecode, Frames) == 0x00000C, "Member 'FTimecode::Frames' has a wrong offset!");
static_assert(offsetof(FTimecode, bDropFrameFormat) == 0x000010, "Member 'FTimecode::bDropFrameFormat' has a wrong offset!");

// ScriptStruct CoreUObject.Timespan
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x08) FTimespan final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTimespan) == 0x000008, "Wrong alignment on FTimespan");
static_assert(sizeof(FTimespan) == 0x000008, "Wrong size on FTimespan");

// ScriptStruct CoreUObject.Transform
// 0x0060 (0x0060 - 0x0000)
struct FTransform final
{
public:
	struct FQuat                                  Rotation;                                          // 0x0000(0x0020)(Edit, BlueprintVisible, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Translation;                                       // 0x0020(0x0018)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Scale3D;                                           // 0x0040(0x0018)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_58[0x8];                                       // 0x0058(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTransform) == 0x000010, "Wrong alignment on FTransform");
static_assert(sizeof(FTransform) == 0x000060, "Wrong size on FTransform");
static_assert(offsetof(FTransform, Rotation) == 0x000000, "Member 'FTransform::Rotation' has a wrong offset!");
static_assert(offsetof(FTransform, Translation) == 0x000020, "Member 'FTransform::Translation' has a wrong offset!");
static_assert(offsetof(FTransform, Scale3D) == 0x000040, "Member 'FTransform::Scale3D' has a wrong offset!");

// ScriptStruct CoreUObject.Transform3d
// 0x0060 (0x0060 - 0x0000)
struct FTransform3d final
{
public:
	struct FQuat4d                                Rotation;                                          // 0x0000(0x0020)(Edit, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector3d                              Translation;                                       // 0x0020(0x0018)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector3d                              Scale3D;                                           // 0x0040(0x0018)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_58[0x8];                                       // 0x0058(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTransform3d) == 0x000010, "Wrong alignment on FTransform3d");
static_assert(sizeof(FTransform3d) == 0x000060, "Wrong size on FTransform3d");
static_assert(offsetof(FTransform3d, Rotation) == 0x000000, "Member 'FTransform3d::Rotation' has a wrong offset!");
static_assert(offsetof(FTransform3d, Translation) == 0x000020, "Member 'FTransform3d::Translation' has a wrong offset!");
static_assert(offsetof(FTransform3d, Scale3D) == 0x000040, "Member 'FTransform3d::Scale3D' has a wrong offset!");

// ScriptStruct CoreUObject.Transform3f
// 0x0030 (0x0030 - 0x0000)
struct FTransform3f final
{
public:
	struct FQuat4f                                Rotation;                                          // 0x0000(0x0010)(Edit, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector3f                              Translation;                                       // 0x0010(0x000C)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector3f                              Scale3D;                                           // 0x0020(0x000C)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTransform3f) == 0x000010, "Wrong alignment on FTransform3f");
static_assert(sizeof(FTransform3f) == 0x000030, "Wrong size on FTransform3f");
static_assert(offsetof(FTransform3f, Rotation) == 0x000000, "Member 'FTransform3f::Rotation' has a wrong offset!");
static_assert(offsetof(FTransform3f, Translation) == 0x000010, "Member 'FTransform3f::Translation' has a wrong offset!");
static_assert(offsetof(FTransform3f, Scale3D) == 0x000020, "Member 'FTransform3f::Scale3D' has a wrong offset!");

// ScriptStruct CoreUObject.Uint32Point
// 0x0008 (0x0008 - 0x0000)
struct FUint32Point final
{
public:
	int32                                         X;                                                 // 0x0000(0x0004)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Y;                                                 // 0x0004(0x0004)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FUint32Point) == 0x000004, "Wrong alignment on FUint32Point");
static_assert(sizeof(FUint32Point) == 0x000008, "Wrong size on FUint32Point");
static_assert(offsetof(FUint32Point, X) == 0x000000, "Member 'FUint32Point::X' has a wrong offset!");
static_assert(offsetof(FUint32Point, Y) == 0x000004, "Member 'FUint32Point::Y' has a wrong offset!");

// ScriptStruct CoreUObject.Uint32Vector
// 0x000C (0x000C - 0x0000)
struct FUint32Vector final
{
public:
	uint32                                        X;                                                 // 0x0000(0x0004)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        Y;                                                 // 0x0004(0x0004)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        Z;                                                 // 0x0008(0x0004)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FUint32Vector) == 0x000004, "Wrong alignment on FUint32Vector");
static_assert(sizeof(FUint32Vector) == 0x00000C, "Wrong size on FUint32Vector");
static_assert(offsetof(FUint32Vector, X) == 0x000000, "Member 'FUint32Vector::X' has a wrong offset!");
static_assert(offsetof(FUint32Vector, Y) == 0x000004, "Member 'FUint32Vector::Y' has a wrong offset!");
static_assert(offsetof(FUint32Vector, Z) == 0x000008, "Member 'FUint32Vector::Z' has a wrong offset!");

// ScriptStruct CoreUObject.OverriddenPropertyNodeID
// 0x0010 (0x0010 - 0x0000)
struct FOverriddenPropertyNodeID final
{
public:
	class FName                                   Path;                                              // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                Object;                                            // 0x0008(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOverriddenPropertyNodeID) == 0x000008, "Wrong alignment on FOverriddenPropertyNodeID");
static_assert(sizeof(FOverriddenPropertyNodeID) == 0x000010, "Wrong size on FOverriddenPropertyNodeID");
static_assert(offsetof(FOverriddenPropertyNodeID, Path) == 0x000000, "Member 'FOverriddenPropertyNodeID::Path' has a wrong offset!");
static_assert(offsetof(FOverriddenPropertyNodeID, Object) == 0x000008, "Member 'FOverriddenPropertyNodeID::Object' has a wrong offset!");

// ScriptStruct CoreUObject.OverriddenPropertyNode
// 0x0068 (0x0068 - 0x0000)
struct FOverriddenPropertyNode final
{
public:
	struct FOverriddenPropertyNodeID              NodeID;                                            // 0x0000(0x0010)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOverriddenPropertyOperation                  Operation;                                         // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<struct FOverriddenPropertyNodeID, struct FOverriddenPropertyNodeID> SubPropertyNodeKeys;                               // 0x0018(0x0050)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FOverriddenPropertyNode) == 0x000008, "Wrong alignment on FOverriddenPropertyNode");
static_assert(sizeof(FOverriddenPropertyNode) == 0x000068, "Wrong size on FOverriddenPropertyNode");
static_assert(offsetof(FOverriddenPropertyNode, NodeID) == 0x000000, "Member 'FOverriddenPropertyNode::NodeID' has a wrong offset!");
static_assert(offsetof(FOverriddenPropertyNode, Operation) == 0x000010, "Member 'FOverriddenPropertyNode::Operation' has a wrong offset!");
static_assert(offsetof(FOverriddenPropertyNode, SubPropertyNodeKeys) == 0x000018, "Member 'FOverriddenPropertyNode::SubPropertyNodeKeys' has a wrong offset!");

// ScriptStruct CoreUObject.Uint32Vector2
// 0x0008 (0x0008 - 0x0000)
struct FUint32Vector2 final
{
public:
	uint32                                        X;                                                 // 0x0000(0x0004)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        Y;                                                 // 0x0004(0x0004)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FUint32Vector2) == 0x000004, "Wrong alignment on FUint32Vector2");
static_assert(sizeof(FUint32Vector2) == 0x000008, "Wrong size on FUint32Vector2");
static_assert(offsetof(FUint32Vector2, X) == 0x000000, "Member 'FUint32Vector2::X' has a wrong offset!");
static_assert(offsetof(FUint32Vector2, Y) == 0x000004, "Member 'FUint32Vector2::Y' has a wrong offset!");

// ScriptStruct CoreUObject.Uint32Vector4
// 0x0010 (0x0010 - 0x0000)
struct FUint32Vector4 final
{
public:
	uint32                                        X;                                                 // 0x0000(0x0004)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        Y;                                                 // 0x0004(0x0004)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        Z;                                                 // 0x0008(0x0004)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        W;                                                 // 0x000C(0x0004)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FUint32Vector4) == 0x000004, "Wrong alignment on FUint32Vector4");
static_assert(sizeof(FUint32Vector4) == 0x000010, "Wrong size on FUint32Vector4");
static_assert(offsetof(FUint32Vector4, X) == 0x000000, "Member 'FUint32Vector4::X' has a wrong offset!");
static_assert(offsetof(FUint32Vector4, Y) == 0x000004, "Member 'FUint32Vector4::Y' has a wrong offset!");
static_assert(offsetof(FUint32Vector4, Z) == 0x000008, "Member 'FUint32Vector4::Z' has a wrong offset!");
static_assert(offsetof(FUint32Vector4, W) == 0x00000C, "Member 'FUint32Vector4::W' has a wrong offset!");

// ScriptStruct CoreUObject.ObjectCookedMetaDataStore
// 0x0050 (0x0050 - 0x0000)
struct FObjectCookedMetaDataStore final
{
public:
	TMap<class FName, class FString>              ObjectMetaData;                                    // 0x0000(0x0050)(NativeAccessSpecifierPrivate)
};
static_assert(alignof(FObjectCookedMetaDataStore) == 0x000008, "Wrong alignment on FObjectCookedMetaDataStore");
static_assert(sizeof(FObjectCookedMetaDataStore) == 0x000050, "Wrong size on FObjectCookedMetaDataStore");
static_assert(offsetof(FObjectCookedMetaDataStore, ObjectMetaData) == 0x000000, "Member 'FObjectCookedMetaDataStore::ObjectMetaData' has a wrong offset!");

// ScriptStruct CoreUObject.Uint64Point
// 0x0010 (0x0010 - 0x0000)
struct FUint64Point final
{
public:
	int64                                         X;                                                 // 0x0000(0x0008)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         Y;                                                 // 0x0008(0x0008)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FUint64Point) == 0x000008, "Wrong alignment on FUint64Point");
static_assert(sizeof(FUint64Point) == 0x000010, "Wrong size on FUint64Point");
static_assert(offsetof(FUint64Point, X) == 0x000000, "Member 'FUint64Point::X' has a wrong offset!");
static_assert(offsetof(FUint64Point, Y) == 0x000008, "Member 'FUint64Point::Y' has a wrong offset!");

// ScriptStruct CoreUObject.Uint64Vector
// 0x0018 (0x0018 - 0x0000)
struct FUint64Vector final
{
public:
	uint64                                        X;                                                 // 0x0000(0x0008)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint64                                        Y;                                                 // 0x0008(0x0008)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint64                                        Z;                                                 // 0x0010(0x0008)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FUint64Vector) == 0x000008, "Wrong alignment on FUint64Vector");
static_assert(sizeof(FUint64Vector) == 0x000018, "Wrong size on FUint64Vector");
static_assert(offsetof(FUint64Vector, X) == 0x000000, "Member 'FUint64Vector::X' has a wrong offset!");
static_assert(offsetof(FUint64Vector, Y) == 0x000008, "Member 'FUint64Vector::Y' has a wrong offset!");
static_assert(offsetof(FUint64Vector, Z) == 0x000010, "Member 'FUint64Vector::Z' has a wrong offset!");

// ScriptStruct CoreUObject.Uint64Vector2
// 0x0010 (0x0010 - 0x0000)
struct FUint64Vector2 final
{
public:
	uint64                                        X;                                                 // 0x0000(0x0008)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint64                                        Y;                                                 // 0x0008(0x0008)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FUint64Vector2) == 0x000008, "Wrong alignment on FUint64Vector2");
static_assert(sizeof(FUint64Vector2) == 0x000010, "Wrong size on FUint64Vector2");
static_assert(offsetof(FUint64Vector2, X) == 0x000000, "Member 'FUint64Vector2::X' has a wrong offset!");
static_assert(offsetof(FUint64Vector2, Y) == 0x000008, "Member 'FUint64Vector2::Y' has a wrong offset!");

// ScriptStruct CoreUObject.Uint64Vector4
// 0x0020 (0x0020 - 0x0000)
struct FUint64Vector4 final
{
public:
	uint64                                        X;                                                 // 0x0000(0x0008)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint64                                        Y;                                                 // 0x0008(0x0008)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint64                                        Z;                                                 // 0x0010(0x0008)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint64                                        W;                                                 // 0x0018(0x0008)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FUint64Vector4) == 0x000008, "Wrong alignment on FUint64Vector4");
static_assert(sizeof(FUint64Vector4) == 0x000020, "Wrong size on FUint64Vector4");
static_assert(offsetof(FUint64Vector4, X) == 0x000000, "Member 'FUint64Vector4::X' has a wrong offset!");
static_assert(offsetof(FUint64Vector4, Y) == 0x000008, "Member 'FUint64Vector4::Y' has a wrong offset!");
static_assert(offsetof(FUint64Vector4, Z) == 0x000010, "Member 'FUint64Vector4::Z' has a wrong offset!");
static_assert(offsetof(FUint64Vector4, W) == 0x000018, "Member 'FUint64Vector4::W' has a wrong offset!");

// ScriptStruct CoreUObject.UintPoint
// 0x0008 (0x0008 - 0x0000)
struct FUintPoint final
{
public:
	int32                                         X;                                                 // 0x0000(0x0004)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Y;                                                 // 0x0004(0x0004)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FUintPoint) == 0x000004, "Wrong alignment on FUintPoint");
static_assert(sizeof(FUintPoint) == 0x000008, "Wrong size on FUintPoint");
static_assert(offsetof(FUintPoint, X) == 0x000000, "Member 'FUintPoint::X' has a wrong offset!");
static_assert(offsetof(FUintPoint, Y) == 0x000004, "Member 'FUintPoint::Y' has a wrong offset!");

// ScriptStruct CoreUObject.UintVector
// 0x000C (0x000C - 0x0000)
struct FUintVector final
{
public:
	uint32                                        X;                                                 // 0x0000(0x0004)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        Y;                                                 // 0x0004(0x0004)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        Z;                                                 // 0x0008(0x0004)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FUintVector) == 0x000004, "Wrong alignment on FUintVector");
static_assert(sizeof(FUintVector) == 0x00000C, "Wrong size on FUintVector");
static_assert(offsetof(FUintVector, X) == 0x000000, "Member 'FUintVector::X' has a wrong offset!");
static_assert(offsetof(FUintVector, Y) == 0x000004, "Member 'FUintVector::Y' has a wrong offset!");
static_assert(offsetof(FUintVector, Z) == 0x000008, "Member 'FUintVector::Z' has a wrong offset!");

// ScriptStruct CoreUObject.UintVector2
// 0x0008 (0x0008 - 0x0000)
struct FUintVector2 final
{
public:
	uint32                                        X;                                                 // 0x0000(0x0004)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        Y;                                                 // 0x0004(0x0004)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FUintVector2) == 0x000004, "Wrong alignment on FUintVector2");
static_assert(sizeof(FUintVector2) == 0x000008, "Wrong size on FUintVector2");
static_assert(offsetof(FUintVector2, X) == 0x000000, "Member 'FUintVector2::X' has a wrong offset!");
static_assert(offsetof(FUintVector2, Y) == 0x000004, "Member 'FUintVector2::Y' has a wrong offset!");

// ScriptStruct CoreUObject.UintVector4
// 0x0010 (0x0010 - 0x0000)
struct FUintVector4 final
{
public:
	uint32                                        X;                                                 // 0x0000(0x0004)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        Y;                                                 // 0x0004(0x0004)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        Z;                                                 // 0x0008(0x0004)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        W;                                                 // 0x000C(0x0004)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FUintVector4) == 0x000004, "Wrong alignment on FUintVector4");
static_assert(sizeof(FUintVector4) == 0x000010, "Wrong size on FUintVector4");
static_assert(offsetof(FUintVector4, X) == 0x000000, "Member 'FUintVector4::X' has a wrong offset!");
static_assert(offsetof(FUintVector4, Y) == 0x000004, "Member 'FUintVector4::Y' has a wrong offset!");
static_assert(offsetof(FUintVector4, Z) == 0x000008, "Member 'FUintVector4::Z' has a wrong offset!");
static_assert(offsetof(FUintVector4, W) == 0x00000C, "Member 'FUintVector4::W' has a wrong offset!");

// ScriptStruct CoreUObject.Vector4
// 0x0020 (0x0020 - 0x0000)
struct alignas(0x10) FVector4 final
{
public:
	double                                        X;                                                 // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        Y;                                                 // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        Z;                                                 // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        W;                                                 // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVector4) == 0x000010, "Wrong alignment on FVector4");
static_assert(sizeof(FVector4) == 0x000020, "Wrong size on FVector4");
static_assert(offsetof(FVector4, X) == 0x000000, "Member 'FVector4::X' has a wrong offset!");
static_assert(offsetof(FVector4, Y) == 0x000008, "Member 'FVector4::Y' has a wrong offset!");
static_assert(offsetof(FVector4, Z) == 0x000010, "Member 'FVector4::Z' has a wrong offset!");
static_assert(offsetof(FVector4, W) == 0x000018, "Member 'FVector4::W' has a wrong offset!");

// ScriptStruct CoreUObject.Vector4f
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x10) FVector4f final
{
public:
	float                                         X;                                                 // 0x0000(0x0004)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Y;                                                 // 0x0004(0x0004)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Z;                                                 // 0x0008(0x0004)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         W;                                                 // 0x000C(0x0004)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVector4f) == 0x000010, "Wrong alignment on FVector4f");
static_assert(sizeof(FVector4f) == 0x000010, "Wrong size on FVector4f");
static_assert(offsetof(FVector4f, X) == 0x000000, "Member 'FVector4f::X' has a wrong offset!");
static_assert(offsetof(FVector4f, Y) == 0x000004, "Member 'FVector4f::Y' has a wrong offset!");
static_assert(offsetof(FVector4f, Z) == 0x000008, "Member 'FVector4f::Z' has a wrong offset!");
static_assert(offsetof(FVector4f, W) == 0x00000C, "Member 'FVector4f::W' has a wrong offset!");

// ScriptStruct CoreUObject.OverriddenPropertySet
// 0x0060 (0x0060 - 0x0000)
struct FOverriddenPropertySet final
{
public:
	class UObject*                                Owner;                                             // 0x0000(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSet<struct FOverriddenPropertyNode>          OverriddenPropertyNodes;                           // 0x0008(0x0050)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_58[0x8];                                       // 0x0058(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOverriddenPropertySet) == 0x000008, "Wrong alignment on FOverriddenPropertySet");
static_assert(sizeof(FOverriddenPropertySet) == 0x000060, "Wrong size on FOverriddenPropertySet");
static_assert(offsetof(FOverriddenPropertySet, Owner) == 0x000000, "Member 'FOverriddenPropertySet::Owner' has a wrong offset!");
static_assert(offsetof(FOverriddenPropertySet, OverriddenPropertyNodes) == 0x000008, "Member 'FOverriddenPropertySet::OverriddenPropertyNodes' has a wrong offset!");

// ScriptStruct CoreUObject.FieldCookedMetaDataStore
// 0x0050 (0x0050 - 0x0000)
struct FFieldCookedMetaDataStore final
{
public:
	TMap<class FName, class FString>              FieldMetaData;                                     // 0x0000(0x0050)(NativeAccessSpecifierPrivate)
};
static_assert(alignof(FFieldCookedMetaDataStore) == 0x000008, "Wrong alignment on FFieldCookedMetaDataStore");
static_assert(sizeof(FFieldCookedMetaDataStore) == 0x000050, "Wrong size on FFieldCookedMetaDataStore");
static_assert(offsetof(FFieldCookedMetaDataStore, FieldMetaData) == 0x000000, "Member 'FFieldCookedMetaDataStore::FieldMetaData' has a wrong offset!");

// ScriptStruct CoreUObject.StructCookedMetaDataStore
// 0x00A0 (0x00A0 - 0x0000)
struct FStructCookedMetaDataStore final
{
public:
	struct FObjectCookedMetaDataStore             ObjectMetaData;                                    // 0x0000(0x0050)(NativeAccessSpecifierPrivate)
	TMap<class FName, struct FFieldCookedMetaDataStore> PropertiesMetaData;                                // 0x0050(0x0050)(NativeAccessSpecifierPrivate)
};
static_assert(alignof(FStructCookedMetaDataStore) == 0x000008, "Wrong alignment on FStructCookedMetaDataStore");
static_assert(sizeof(FStructCookedMetaDataStore) == 0x0000A0, "Wrong size on FStructCookedMetaDataStore");
static_assert(offsetof(FStructCookedMetaDataStore, ObjectMetaData) == 0x000000, "Member 'FStructCookedMetaDataStore::ObjectMetaData' has a wrong offset!");
static_assert(offsetof(FStructCookedMetaDataStore, PropertiesMetaData) == 0x000050, "Member 'FStructCookedMetaDataStore::PropertiesMetaData' has a wrong offset!");

}

