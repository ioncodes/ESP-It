#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: B_CreativePlayerController

#include "Basic.hpp"

#include "B_CreativePlayerController_classes.hpp"
#include "B_CreativePlayerController_parameters.hpp"


namespace SDK
{

// Function B_CreativePlayerController.B_CreativePlayerController_C.OnGroupAmountChanged__DelegateSignature
// (Public, Delegate, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           AddedOrRemovedActor                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool                                    WasAdded                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AB_CreativePlayerController_C::OnGroupAmountChanged__DelegateSignature(class AActor* AddedOrRemovedActor, bool WasAdded)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_CreativePlayerController_C", "OnGroupAmountChanged__DelegateSignature");

	Params::B_CreativePlayerController_C_OnGroupAmountChanged__DelegateSignature Parms{};

	Parms.AddedOrRemovedActor = AddedOrRemovedActor;
	Parms.WasAdded = WasAdded;

	UObject::ProcessEvent(Func, &Parms);
}


// Function B_CreativePlayerController.B_CreativePlayerController_C.OnPlayerModeChanged__DelegateSignature
// (Public, Delegate, BlueprintCallable, BlueprintEvent)

void AB_CreativePlayerController_C::OnPlayerModeChanged__DelegateSignature()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_CreativePlayerController_C", "OnPlayerModeChanged__DelegateSignature");

	UObject::ProcessEvent(Func, nullptr);
}


// Function B_CreativePlayerController.B_CreativePlayerController_C.ActorLimitReachedOwning
// (Net, NetReliable, NetClient, BlueprintCallable, BlueprintEvent)

void AB_CreativePlayerController_C::ActorLimitReachedOwning()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_CreativePlayerController_C", "ActorLimitReachedOwning");

	UObject::ProcessEvent(Func, nullptr);
}


// Function B_CreativePlayerController.B_CreativePlayerController_C.AddOrRemoveSwitchConnection
// (Protected, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           HitActor                                               (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash)

void AB_CreativePlayerController_C::AddOrRemoveSwitchConnection(const class AActor*& HitActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_CreativePlayerController_C", "AddOrRemoveSwitchConnection");

	Params::B_CreativePlayerController_C_AddOrRemoveSwitchConnection Parms{};

	Parms.HitActor = HitActor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function B_CreativePlayerController.B_CreativePlayerController_C.AddPrefab
// (Protected, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FPrefabToSave                    PrefabToAdd                                            (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)

void AB_CreativePlayerController_C::AddPrefab(struct FPrefabToSave& PrefabToAdd)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_CreativePlayerController_C", "AddPrefab");

	Params::B_CreativePlayerController_C_AddPrefab Parms{};

	Parms.PrefabToAdd = std::move(PrefabToAdd);

	UObject::ProcessEvent(Func, &Parms);

	PrefabToAdd = std::move(Parms.PrefabToAdd);
}


// Function B_CreativePlayerController.B_CreativePlayerController_C.AddPrefabServer
// (Net, NetReliable, NetServer, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FPrefabToSave                    PrefabToAdd                                            (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)

void AB_CreativePlayerController_C::AddPrefabServer(const struct FPrefabToSave& PrefabToAdd)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_CreativePlayerController_C", "AddPrefabServer");

	Params::B_CreativePlayerController_C_AddPrefabServer Parms{};

	Parms.PrefabToAdd = std::move(PrefabToAdd);

	UObject::ProcessEvent(Func, &Parms);
}


// Function B_CreativePlayerController.B_CreativePlayerController_C.AddSelectedTargetsToSwitch
// (Protected, BlueprintCallable, BlueprintEvent)

void AB_CreativePlayerController_C::AddSelectedTargetsToSwitch()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_CreativePlayerController_C", "AddSelectedTargetsToSwitch");

	UObject::ProcessEvent(Func, nullptr);
}


// Function B_CreativePlayerController.B_CreativePlayerController_C.AddSelectedTargetToSwitch
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           TargetActor                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class ABP_Switch_C*                     TargetSwitch                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void AB_CreativePlayerController_C::AddSelectedTargetToSwitch(class AActor* TargetActor, class ABP_Switch_C* TargetSwitch)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_CreativePlayerController_C", "AddSelectedTargetToSwitch");

	Params::B_CreativePlayerController_C_AddSelectedTargetToSwitch Parms{};

	Parms.TargetActor = TargetActor;
	Parms.TargetSwitch = TargetSwitch;

	UObject::ProcessEvent(Func, &Parms);
}


// Function B_CreativePlayerController.B_CreativePlayerController_C.AddTargetToSwitch
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           ActorToAdd                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class ABP_Switch_C*                     SWITCH                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// TArray<class AActor*>                   TempTargetList                                         (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)

void AB_CreativePlayerController_C::AddTargetToSwitch(class AActor* ActorToAdd, class ABP_Switch_C* SWITCH, TArray<class AActor*>& TempTargetList)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_CreativePlayerController_C", "AddTargetToSwitch");

	Params::B_CreativePlayerController_C_AddTargetToSwitch Parms{};

	Parms.ActorToAdd = ActorToAdd;
	Parms.SWITCH = SWITCH;
	Parms.TempTargetList = std::move(TempTargetList);

	UObject::ProcessEvent(Func, &Parms);

	TempTargetList = std::move(Parms.TempTargetList);
}


// Function B_CreativePlayerController.B_CreativePlayerController_C.AddTargetToSwitchServer
// (Net, NetReliable, NetServer, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           ActorToAdd                                             (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class ABP_Switch_C*                     SWITCH                                                 (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// TArray<class AActor*>                   OldTargetList                                          (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)

void AB_CreativePlayerController_C::AddTargetToSwitchServer(const class AActor* ActorToAdd, const class ABP_Switch_C* SWITCH, const TArray<class AActor*>& OldTargetList)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_CreativePlayerController_C", "AddTargetToSwitchServer");

	Params::B_CreativePlayerController_C_AddTargetToSwitchServer Parms{};

	Parms.ActorToAdd = ActorToAdd;
	Parms.SWITCH = SWITCH;
	Parms.OldTargetList = std::move(OldTargetList);

	UObject::ProcessEvent(Func, &Parms);
}


// Function B_CreativePlayerController.B_CreativePlayerController_C.BeginPlayClient
// (Net, NetReliable, NetClient, BlueprintCallable, BlueprintEvent)

void AB_CreativePlayerController_C::BeginPlayClient()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_CreativePlayerController_C", "BeginPlayClient");

	UObject::ProcessEvent(Func, nullptr);
}


// Function B_CreativePlayerController.B_CreativePlayerController_C.BeginTakingScreenshot
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    WantsToSubmittToWorkshop_0                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AB_CreativePlayerController_C::BeginTakingScreenshot(bool WantsToSubmittToWorkshop_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_CreativePlayerController_C", "BeginTakingScreenshot");

	Params::B_CreativePlayerController_C_BeginTakingScreenshot Parms{};

	Parms.WantsToSubmittToWorkshop_0 = WantsToSubmittToWorkshop_0;

	UObject::ProcessEvent(Func, &Parms);
}


// Function B_CreativePlayerController.B_CreativePlayerController_C.CanPlayTestBeToggledSafely
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    CanBeToggled                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AB_CreativePlayerController_C::CanPlayTestBeToggledSafely(bool* CanBeToggled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_CreativePlayerController_C", "CanPlayTestBeToggledSafely");

	Params::B_CreativePlayerController_C_CanPlayTestBeToggledSafely Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (CanBeToggled != nullptr)
		*CanBeToggled = Parms.CanBeToggled;
}


// Function B_CreativePlayerController.B_CreativePlayerController_C.ChangeBrightnessServer
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ABP_PlaceableLight_C*             PlaceableLight                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// double                                  ChangeValue                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AB_CreativePlayerController_C::ChangeBrightnessServer(class ABP_PlaceableLight_C* PlaceableLight, double ChangeValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_CreativePlayerController_C", "ChangeBrightnessServer");

	Params::B_CreativePlayerController_C_ChangeBrightnessServer Parms{};

	Parms.PlaceableLight = PlaceableLight;
	Parms.ChangeValue = ChangeValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function B_CreativePlayerController.B_CreativePlayerController_C.ChangeLightColorServer
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector                          Color                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class ABP_PlaceableLight_C*             TargetLight                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void AB_CreativePlayerController_C::ChangeLightColorServer(const struct FVector& Color, class ABP_PlaceableLight_C* TargetLight)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_CreativePlayerController_C", "ChangeLightColorServer");

	Params::B_CreativePlayerController_C_ChangeLightColorServer Parms{};

	Parms.Color = std::move(Color);
	Parms.TargetLight = TargetLight;

	UObject::ProcessEvent(Func, &Parms);
}


// Function B_CreativePlayerController.B_CreativePlayerController_C.ChangeModifyMode
// (Protected, BlueprintCallable, BlueprintEvent)

void AB_CreativePlayerController_C::ChangeModifyMode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_CreativePlayerController_C", "ChangeModifyMode");

	UObject::ProcessEvent(Func, nullptr);
}


// Function B_CreativePlayerController.B_CreativePlayerController_C.ChangePlayerMode
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// E_CreativePlayerMode                    NewMode                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AB_CreativePlayerController_C::ChangePlayerMode(E_CreativePlayerMode NewMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_CreativePlayerController_C", "ChangePlayerMode");

	Params::B_CreativePlayerController_C_ChangePlayerMode Parms{};

	Parms.NewMode = NewMode;

	UObject::ProcessEvent(Func, &Parms);
}


// Function B_CreativePlayerController.B_CreativePlayerController_C.ChangePlayerModeByShortcutKey
// (Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// E_CreativePlayerMode                    NewMode                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AB_CreativePlayerController_C::ChangePlayerModeByShortcutKey(E_CreativePlayerMode NewMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_CreativePlayerController_C", "ChangePlayerModeByShortcutKey");

	Params::B_CreativePlayerController_C_ChangePlayerModeByShortcutKey Parms{};

	Parms.NewMode = NewMode;

	UObject::ProcessEvent(Func, &Parms);
}


// Function B_CreativePlayerController.B_CreativePlayerController_C.ChangeToSpecificModifyMode
// (Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// E_ModifyMode                            ModifyMode_0                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AB_CreativePlayerController_C::ChangeToSpecificModifyMode(E_ModifyMode ModifyMode_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_CreativePlayerController_C", "ChangeToSpecificModifyMode");

	Params::B_CreativePlayerController_C_ChangeToSpecificModifyMode Parms{};

	Parms.ModifyMode_0 = ModifyMode_0;

	UObject::ProcessEvent(Func, &Parms);
}


// Function B_CreativePlayerController.B_CreativePlayerController_C.CheckActorAmountLimits
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class AB_CreativeGameState_C*           CreativeGameState                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// TArray<class AActor*>                   ActorsToDuplicate                                      (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// bool                                    BelowLimit                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AB_CreativePlayerController_C::CheckActorAmountLimits(class AB_CreativeGameState_C* CreativeGameState, TArray<class AActor*>& ActorsToDuplicate, bool* BelowLimit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_CreativePlayerController_C", "CheckActorAmountLimits");

	Params::B_CreativePlayerController_C_CheckActorAmountLimits Parms{};

	Parms.CreativeGameState = CreativeGameState;
	Parms.ActorsToDuplicate = std::move(ActorsToDuplicate);

	UObject::ProcessEvent(Func, &Parms);

	ActorsToDuplicate = std::move(Parms.ActorsToDuplicate);

	if (BelowLimit != nullptr)
		*BelowLimit = Parms.BelowLimit;
}


// Function B_CreativePlayerController.B_CreativePlayerController_C.CheckSizeMultipleAfterAnchorSizeChange
// (Private, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<class AActor*>                   ActorsToCheck                                          (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)

void AB_CreativePlayerController_C::CheckSizeMultipleAfterAnchorSizeChange(TArray<class AActor*>& ActorsToCheck)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_CreativePlayerController_C", "CheckSizeMultipleAfterAnchorSizeChange");

	Params::B_CreativePlayerController_C_CheckSizeMultipleAfterAnchorSizeChange Parms{};

	Parms.ActorsToCheck = std::move(ActorsToCheck);

	UObject::ProcessEvent(Func, &Parms);

	ActorsToCheck = std::move(Parms.ActorsToCheck);
}


// Function B_CreativePlayerController.B_CreativePlayerController_C.ClampScaleOfTargetOrAnchorActor
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class AActor*                           TargetActor_Optional_                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// double                                  WantedScale                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double                                  ClampedScale                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AB_CreativePlayerController_C::ClampScaleOfTargetOrAnchorActor(class AActor* TargetActor_Optional_, double WantedScale, double* ClampedScale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_CreativePlayerController_C", "ClampScaleOfTargetOrAnchorActor");

	Params::B_CreativePlayerController_C_ClampScaleOfTargetOrAnchorActor Parms{};

	Parms.TargetActor_Optional_ = TargetActor_Optional_;
	Parms.WantedScale = WantedScale;

	UObject::ProcessEvent(Func, &Parms);

	if (ClampedScale != nullptr)
		*ClampedScale = Parms.ClampedScale;
}


// Function B_CreativePlayerController.B_CreativePlayerController_C.ClearSwitchConnections
// (Protected, BlueprintCallable, BlueprintEvent)

void AB_CreativePlayerController_C::ClearSwitchConnections()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_CreativePlayerController_C", "ClearSwitchConnections");

	UObject::ProcessEvent(Func, nullptr);
}


// Function B_CreativePlayerController.B_CreativePlayerController_C.CloseAllMenusExceptEditUi
// (Public, BlueprintCallable, BlueprintEvent)

void AB_CreativePlayerController_C::CloseAllMenusExceptEditUi()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_CreativePlayerController_C", "CloseAllMenusExceptEditUi");

	UObject::ProcessEvent(Func, nullptr);
}


// Function B_CreativePlayerController.B_CreativePlayerController_C.CloseEscMenu
// (Protected, BlueprintCallable, BlueprintEvent)

void AB_CreativePlayerController_C::CloseEscMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_CreativePlayerController_C", "CloseEscMenu");

	UObject::ProcessEvent(Func, nullptr);
}


// Function B_CreativePlayerController.B_CreativePlayerController_C.CloseScreensOnPlayTestDeathClient
// (Net, NetReliable, NetClient, BlueprintCallable, BlueprintEvent)

void AB_CreativePlayerController_C::CloseScreensOnPlayTestDeathClient()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_CreativePlayerController_C", "CloseScreensOnPlayTestDeathClient");

	UObject::ProcessEvent(Func, nullptr);
}


// Function B_CreativePlayerController.B_CreativePlayerController_C.CloseTabScreen
// (Protected, BlueprintCallable, BlueprintEvent)

void AB_CreativePlayerController_C::CloseTabScreen()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_CreativePlayerController_C", "CloseTabScreen");

	UObject::ProcessEvent(Func, nullptr);
}


// Function B_CreativePlayerController.B_CreativePlayerController_C.ConfirmDuplicate
// (Protected, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<class AActor*>                   ActorsToSelect                                         (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// bool                                    Drag                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AB_CreativePlayerController_C::ConfirmDuplicate(TArray<class AActor*>& ActorsToSelect, bool Drag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_CreativePlayerController_C", "ConfirmDuplicate");

	Params::B_CreativePlayerController_C_ConfirmDuplicate Parms{};

	Parms.ActorsToSelect = std::move(ActorsToSelect);
	Parms.Drag = Drag;

	UObject::ProcessEvent(Func, &Parms);

	ActorsToSelect = std::move(Parms.ActorsToSelect);
}


// Function B_CreativePlayerController.B_CreativePlayerController_C.ConfirmDuplicateMultipleServer
// (Net, NetReliable, HasOutParams, NetClient, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<class AActor*>                   ActorsToSelect                                         (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// bool                                    Drag                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AB_CreativePlayerController_C::ConfirmDuplicateMultipleServer(const TArray<class AActor*>& ActorsToSelect, bool Drag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_CreativePlayerController_C", "ConfirmDuplicateMultipleServer");

	Params::B_CreativePlayerController_C_ConfirmDuplicateMultipleServer Parms{};

	Parms.ActorsToSelect = std::move(ActorsToSelect);
	Parms.Drag = Drag;

	UObject::ProcessEvent(Func, &Parms);
}


// Function B_CreativePlayerController.B_CreativePlayerController_C.CopySelectedActors
// (Public, BlueprintCallable, BlueprintEvent)

void AB_CreativePlayerController_C::CopySelectedActors()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_CreativePlayerController_C", "CopySelectedActors");

	UObject::ProcessEvent(Func, nullptr);
}


// Function B_CreativePlayerController.B_CreativePlayerController_C.DeleteActorsToPlace
// (Public, BlueprintCallable, BlueprintEvent)

void AB_CreativePlayerController_C::DeleteActorsToPlace()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_CreativePlayerController_C", "DeleteActorsToPlace");

	UObject::ProcessEvent(Func, nullptr);
}


// Function B_CreativePlayerController.B_CreativePlayerController_C.DeleteMultiple
// (Protected, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<class AActor*>                   ActorsToDelete                                         (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)

void AB_CreativePlayerController_C::DeleteMultiple(TArray<class AActor*>& ActorsToDelete)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_CreativePlayerController_C", "DeleteMultiple");

	Params::B_CreativePlayerController_C_DeleteMultiple Parms{};

	Parms.ActorsToDelete = std::move(ActorsToDelete);

	UObject::ProcessEvent(Func, &Parms);

	ActorsToDelete = std::move(Parms.ActorsToDelete);
}


// Function B_CreativePlayerController.B_CreativePlayerController_C.DeleteMultipleServer
// (Net, NetReliable, NetServer, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<class AActor*>                   ActorsToDelete                                         (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)

void AB_CreativePlayerController_C::DeleteMultipleServer(const TArray<class AActor*>& ActorsToDelete)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_CreativePlayerController_C", "DeleteMultipleServer");

	Params::B_CreativePlayerController_C_DeleteMultipleServer Parms{};

	Parms.ActorsToDelete = std::move(ActorsToDelete);

	UObject::ProcessEvent(Func, &Parms);
}


// Function B_CreativePlayerController.B_CreativePlayerController_C.DeletePrefab
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FPrefabToSave                    PrefabToDelete                                         (BlueprintVisible, BlueprintReadOnly, Parm)

void AB_CreativePlayerController_C::DeletePrefab(const struct FPrefabToSave& PrefabToDelete)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_CreativePlayerController_C", "DeletePrefab");

	Params::B_CreativePlayerController_C_DeletePrefab Parms{};

	Parms.PrefabToDelete = std::move(PrefabToDelete);

	UObject::ProcessEvent(Func, &Parms);
}


// Function B_CreativePlayerController.B_CreativePlayerController_C.DeselectMultiple
// (Public, BlueprintCallable, BlueprintEvent)

void AB_CreativePlayerController_C::DeselectMultiple()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_CreativePlayerController_C", "DeselectMultiple");

	UObject::ProcessEvent(Func, nullptr);
}


// Function B_CreativePlayerController.B_CreativePlayerController_C.DeselectSingleActor
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           ActorToDeselect                                        (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash)

void AB_CreativePlayerController_C::DeselectSingleActor(const class AActor*& ActorToDeselect)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_CreativePlayerController_C", "DeselectSingleActor");

	Params::B_CreativePlayerController_C_DeselectSingleActor Parms{};

	Parms.ActorToDeselect = ActorToDeselect;

	UObject::ProcessEvent(Func, &Parms);
}


// Function B_CreativePlayerController.B_CreativePlayerController_C.DetermineClampActorScale
// (Private, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class AActor*                           ActorToCheck                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// double                                  InputScale                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double                                  ClampedScale                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AB_CreativePlayerController_C::DetermineClampActorScale(class AActor* ActorToCheck, double InputScale, double* ClampedScale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_CreativePlayerController_C", "DetermineClampActorScale");

	Params::B_CreativePlayerController_C_DetermineClampActorScale Parms{};

	Parms.ActorToCheck = ActorToCheck;
	Parms.InputScale = InputScale;

	UObject::ProcessEvent(Func, &Parms);

	if (ClampedScale != nullptr)
		*ClampedScale = Parms.ClampedScale;
}


// Function B_CreativePlayerController.B_CreativePlayerController_C.DetermineTranslationByMousePosition
// (Protected, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// float                                   Length                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AB_CreativePlayerController_C::DetermineTranslationByMousePosition(float* Length)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_CreativePlayerController_C", "DetermineTranslationByMousePosition");

	Params::B_CreativePlayerController_C_DetermineTranslationByMousePosition Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Length != nullptr)
		*Length = Parms.Length;
}


// Function B_CreativePlayerController.B_CreativePlayerController_C.DuplicateMultipleServer
// (Net, NetReliable, NetServer, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<class AActor*>                   ActorsToDuplicate                                      (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// bool                                    Drag                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AB_CreativePlayerController_C::DuplicateMultipleServer(const TArray<class AActor*>& ActorsToDuplicate, bool Drag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_CreativePlayerController_C", "DuplicateMultipleServer");

	Params::B_CreativePlayerController_C_DuplicateMultipleServer Parms{};

	Parms.ActorsToDuplicate = std::move(ActorsToDuplicate);
	Parms.Drag = Drag;

	UObject::ProcessEvent(Func, &Parms);
}


// Function B_CreativePlayerController.B_CreativePlayerController_C.DuplicateSelected
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Drag                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AB_CreativePlayerController_C::DuplicateSelected(bool Drag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_CreativePlayerController_C", "DuplicateSelected");

	Params::B_CreativePlayerController_C_DuplicateSelected Parms{};

	Parms.Drag = Drag;

	UObject::ProcessEvent(Func, &Parms);
}


// Function B_CreativePlayerController.B_CreativePlayerController_C.EndTakingScreenShot
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Success                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AB_CreativePlayerController_C::EndTakingScreenShot(bool Success)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_CreativePlayerController_C", "EndTakingScreenShot");

	Params::B_CreativePlayerController_C_EndTakingScreenShot Parms{};

	Parms.Success = Success;

	UObject::ProcessEvent(Func, &Parms);
}


// Function B_CreativePlayerController.B_CreativePlayerController_C.ExecuteUbergraph_B_CreativePlayerController
// (Final, UbergraphFunction, HasDefaults)
// Parameters:
// int32                                   EntryPoint                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AB_CreativePlayerController_C::ExecuteUbergraph_B_CreativePlayerController(int32 EntryPoint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_CreativePlayerController_C", "ExecuteUbergraph_B_CreativePlayerController");

	Params::B_CreativePlayerController_C_ExecuteUbergraph_B_CreativePlayerController Parms{};

	Parms.EntryPoint = EntryPoint;

	UObject::ProcessEvent(Func, &Parms);
}


// Function B_CreativePlayerController.B_CreativePlayerController_C.FireSelectActor
// (Public, BlueprintCallable, BlueprintEvent)

void AB_CreativePlayerController_C::FireSelectActor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_CreativePlayerController_C", "FireSelectActor");

	UObject::ProcessEvent(Func, nullptr);
}


// Function B_CreativePlayerController.B_CreativePlayerController_C.GetMouseTraceStartAndEndPoints
// (Protected, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// double                                  Distance                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          StartPoint                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          EndPoint                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AB_CreativePlayerController_C::GetMouseTraceStartAndEndPoints(double Distance, struct FVector* StartPoint, struct FVector* EndPoint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_CreativePlayerController_C", "GetMouseTraceStartAndEndPoints");

	Params::B_CreativePlayerController_C_GetMouseTraceStartAndEndPoints Parms{};

	Parms.Distance = Distance;

	UObject::ProcessEvent(Func, &Parms);

	if (StartPoint != nullptr)
		*StartPoint = std::move(Parms.StartPoint);

	if (EndPoint != nullptr)
		*EndPoint = std::move(Parms.EndPoint);
}


// Function B_CreativePlayerController.B_CreativePlayerController_C.GetPrefabInfo
// (Protected, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class AActor*                           Actor                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool                                    HasExtraInfo                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Activated                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    StartAwake                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    IsFreezed                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    BreaksAfterUse                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          Color                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AB_CreativePlayerController_C::GetPrefabInfo(class AActor* Actor, bool HasExtraInfo, bool* Activated, bool* StartAwake, bool* IsFreezed, bool* BreaksAfterUse, struct FVector* Color)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_CreativePlayerController_C", "GetPrefabInfo");

	Params::B_CreativePlayerController_C_GetPrefabInfo Parms{};

	Parms.Actor = Actor;
	Parms.HasExtraInfo = HasExtraInfo;

	UObject::ProcessEvent(Func, &Parms);

	if (Activated != nullptr)
		*Activated = Parms.Activated;

	if (StartAwake != nullptr)
		*StartAwake = Parms.StartAwake;

	if (IsFreezed != nullptr)
		*IsFreezed = Parms.IsFreezed;

	if (BreaksAfterUse != nullptr)
		*BreaksAfterUse = Parms.BreaksAfterUse;

	if (Color != nullptr)
		*Color = std::move(Parms.Color);
}


// Function B_CreativePlayerController.B_CreativePlayerController_C.GetRotationFromCurrentMode
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// double                                  Horizontal                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double                                  Vertical                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FTransform                       EditingTransform                                       (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FRotator                         Rotation                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void AB_CreativePlayerController_C::GetRotationFromCurrentMode(double Horizontal, double Vertical, const struct FTransform& EditingTransform, struct FRotator* Rotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_CreativePlayerController_C", "GetRotationFromCurrentMode");

	Params::B_CreativePlayerController_C_GetRotationFromCurrentMode Parms{};

	Parms.Horizontal = Horizontal;
	Parms.Vertical = Vertical;
	Parms.EditingTransform = std::move(EditingTransform);

	UObject::ProcessEvent(Func, &Parms);

	if (Rotation != nullptr)
		*Rotation = std::move(Parms.Rotation);
}


// Function B_CreativePlayerController.B_CreativePlayerController_C.GetSelectedTransform
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// struct FTransform                       Transform                                              (Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AB_CreativePlayerController_C::GetSelectedTransform(struct FTransform* Transform)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_CreativePlayerController_C", "GetSelectedTransform");

	Params::B_CreativePlayerController_C_GetSelectedTransform Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Transform != nullptr)
		*Transform = std::move(Parms.Transform);
}


// Function B_CreativePlayerController.B_CreativePlayerController_C.GetSwitchTargetsFromPrefabToPlace
// (Protected, HasDefaults, BlueprintCallable, BlueprintEvent)

void AB_CreativePlayerController_C::GetSwitchTargetsFromPrefabToPlace()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_CreativePlayerController_C", "GetSwitchTargetsFromPrefabToPlace");

	UObject::ProcessEvent(Func, nullptr);
}


// Function B_CreativePlayerController.B_CreativePlayerController_C.GetTranslationFromCurrentMode
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// double                                  Horizontal                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double                                  Vertical                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FTransform                       EditingTransform                                       (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          Translation                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AB_CreativePlayerController_C::GetTranslationFromCurrentMode(double Horizontal, double Vertical, const struct FTransform& EditingTransform, struct FVector* Translation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_CreativePlayerController_C", "GetTranslationFromCurrentMode");

	Params::B_CreativePlayerController_C_GetTranslationFromCurrentMode Parms{};

	Parms.Horizontal = Horizontal;
	Parms.Vertical = Vertical;
	Parms.EditingTransform = std::move(EditingTransform);

	UObject::ProcessEvent(Func, &Parms);

	if (Translation != nullptr)
		*Translation = std::move(Parms.Translation);
}


// Function B_CreativePlayerController.B_CreativePlayerController_C.HandleDelete
// (Public, BlueprintCallable, BlueprintEvent)

void AB_CreativePlayerController_C::HandleDelete()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_CreativePlayerController_C", "HandleDelete");

	UObject::ProcessEvent(Func, nullptr);
}


// Function B_CreativePlayerController.B_CreativePlayerController_C.HandleDragOrDuplicate
// (Public, BlueprintCallable, BlueprintEvent)

void AB_CreativePlayerController_C::HandleDragOrDuplicate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_CreativePlayerController_C", "HandleDragOrDuplicate");

	UObject::ProcessEvent(Func, nullptr);
}


// Function B_CreativePlayerController.B_CreativePlayerController_C.HandleMiddleMouseButton
// (Protected, BlueprintCallable, BlueprintEvent)

void AB_CreativePlayerController_C::HandleMiddleMouseButton()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_CreativePlayerController_C", "HandleMiddleMouseButton");

	UObject::ProcessEvent(Func, nullptr);
}


// Function B_CreativePlayerController.B_CreativePlayerController_C.HandleMouseWheelAxis
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// double                                  Axis                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AB_CreativePlayerController_C::HandleMouseWheelAxis(double Axis)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_CreativePlayerController_C", "HandleMouseWheelAxis");

	Params::B_CreativePlayerController_C_HandleMouseWheelAxis Parms{};

	Parms.Axis = Axis;

	UObject::ProcessEvent(Func, &Parms);
}


// Function B_CreativePlayerController.B_CreativePlayerController_C.HandleResetScale
// (Public, BlueprintCallable, BlueprintEvent)

void AB_CreativePlayerController_C::HandleResetScale()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_CreativePlayerController_C", "HandleResetScale");

	UObject::ProcessEvent(Func, nullptr);
}


// Function B_CreativePlayerController.B_CreativePlayerController_C.HasSelectedSomething
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    HasSelectedActor                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AB_CreativePlayerController_C::HasSelectedSomething(bool* HasSelectedActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_CreativePlayerController_C", "HasSelectedSomething");

	Params::B_CreativePlayerController_C_HasSelectedSomething Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (HasSelectedActor != nullptr)
		*HasSelectedActor = Parms.HasSelectedActor;
}


// Function B_CreativePlayerController.B_CreativePlayerController_C.IncreasePropAndPlaceableActorAmount
// (Protected, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// TArray<class AActor*>                   ActorsToTest                                           (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// int32                                   PropAmount                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   PlaceableActorsAmount                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AB_CreativePlayerController_C::IncreasePropAndPlaceableActorAmount(TArray<class AActor*>& ActorsToTest, int32* PropAmount, int32* PlaceableActorsAmount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_CreativePlayerController_C", "IncreasePropAndPlaceableActorAmount");

	Params::B_CreativePlayerController_C_IncreasePropAndPlaceableActorAmount Parms{};

	Parms.ActorsToTest = std::move(ActorsToTest);

	UObject::ProcessEvent(Func, &Parms);

	ActorsToTest = std::move(Parms.ActorsToTest);

	if (PropAmount != nullptr)
		*PropAmount = Parms.PropAmount;

	if (PlaceableActorsAmount != nullptr)
		*PlaceableActorsAmount = Parms.PlaceableActorsAmount;
}


// Function B_CreativePlayerController.B_CreativePlayerController_C.InpActEvt_Action_K2Node_InputActionEvent_4
// (BlueprintEvent)
// Parameters:
// struct FKey                             Key                                                    (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)

void AB_CreativePlayerController_C::InpActEvt_Action_K2Node_InputActionEvent_4(const struct FKey& Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_CreativePlayerController_C", "InpActEvt_Action_K2Node_InputActionEvent_4");

	Params::B_CreativePlayerController_C_InpActEvt_Action_K2Node_InputActionEvent_4 Parms{};

	Parms.Key = std::move(Key);

	UObject::ProcessEvent(Func, &Parms);
}


// Function B_CreativePlayerController.B_CreativePlayerController_C.InpActEvt_ActivateUtilitySkill_K2Node_InputActionEvent_10
// (BlueprintEvent)
// Parameters:
// struct FKey                             Key                                                    (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)

void AB_CreativePlayerController_C::InpActEvt_ActivateUtilitySkill_K2Node_InputActionEvent_10(const struct FKey& Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_CreativePlayerController_C", "InpActEvt_ActivateUtilitySkill_K2Node_InputActionEvent_10");

	Params::B_CreativePlayerController_C_InpActEvt_ActivateUtilitySkill_K2Node_InputActionEvent_10 Parms{};

	Parms.Key = std::move(Key);

	UObject::ProcessEvent(Func, &Parms);
}


// Function B_CreativePlayerController.B_CreativePlayerController_C.InpActEvt_Delete_K2Node_InputKeyEvent_12
// (BlueprintEvent)
// Parameters:
// struct FKey                             Key                                                    (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)

void AB_CreativePlayerController_C::InpActEvt_Delete_K2Node_InputKeyEvent_12(const struct FKey& Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_CreativePlayerController_C", "InpActEvt_Delete_K2Node_InputKeyEvent_12");

	Params::B_CreativePlayerController_C_InpActEvt_Delete_K2Node_InputKeyEvent_12 Parms{};

	Parms.Key = std::move(Key);

	UObject::ProcessEvent(Func, &Parms);
}


// Function B_CreativePlayerController.B_CreativePlayerController_C.InpActEvt_DragRightMouseButton_K2Node_InputActionEvent_5
// (BlueprintEvent)
// Parameters:
// struct FKey                             Key                                                    (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)

void AB_CreativePlayerController_C::InpActEvt_DragRightMouseButton_K2Node_InputActionEvent_5(const struct FKey& Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_CreativePlayerController_C", "InpActEvt_DragRightMouseButton_K2Node_InputActionEvent_5");

	Params::B_CreativePlayerController_C_InpActEvt_DragRightMouseButton_K2Node_InputActionEvent_5 Parms{};

	Parms.Key = std::move(Key);

	UObject::ProcessEvent(Func, &Parms);
}


// Function B_CreativePlayerController.B_CreativePlayerController_C.InpActEvt_DragRightMouseButton_K2Node_InputActionEvent_6
// (BlueprintEvent)
// Parameters:
// struct FKey                             Key                                                    (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)

void AB_CreativePlayerController_C::InpActEvt_DragRightMouseButton_K2Node_InputActionEvent_6(const struct FKey& Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_CreativePlayerController_C", "InpActEvt_DragRightMouseButton_K2Node_InputActionEvent_6");

	Params::B_CreativePlayerController_C_InpActEvt_DragRightMouseButton_K2Node_InputActionEvent_6 Parms{};

	Parms.Key = std::move(Key);

	UObject::ProcessEvent(Func, &Parms);
}


// Function B_CreativePlayerController.B_CreativePlayerController_C.InpActEvt_Fire_K2Node_InputActionEvent_11
// (BlueprintEvent)
// Parameters:
// struct FKey                             Key                                                    (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)

void AB_CreativePlayerController_C::InpActEvt_Fire_K2Node_InputActionEvent_11(const struct FKey& Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_CreativePlayerController_C", "InpActEvt_Fire_K2Node_InputActionEvent_11");

	Params::B_CreativePlayerController_C_InpActEvt_Fire_K2Node_InputActionEvent_11 Parms{};

	Parms.Key = std::move(Key);

	UObject::ProcessEvent(Func, &Parms);
}


// Function B_CreativePlayerController.B_CreativePlayerController_C.InpActEvt_Fire_K2Node_InputActionEvent_12
// (BlueprintEvent)
// Parameters:
// struct FKey                             Key                                                    (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)

void AB_CreativePlayerController_C::InpActEvt_Fire_K2Node_InputActionEvent_12(const struct FKey& Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_CreativePlayerController_C", "InpActEvt_Fire_K2Node_InputActionEvent_12");

	Params::B_CreativePlayerController_C_InpActEvt_Fire_K2Node_InputActionEvent_12 Parms{};

	Parms.Key = std::move(Key);

	UObject::ProcessEvent(Func, &Parms);
}


// Function B_CreativePlayerController.B_CreativePlayerController_C.InpActEvt_Five_K2Node_InputKeyEvent_2
// (BlueprintEvent)
// Parameters:
// struct FKey                             Key                                                    (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)

void AB_CreativePlayerController_C::InpActEvt_Five_K2Node_InputKeyEvent_2(const struct FKey& Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_CreativePlayerController_C", "InpActEvt_Five_K2Node_InputKeyEvent_2");

	Params::B_CreativePlayerController_C_InpActEvt_Five_K2Node_InputKeyEvent_2 Parms{};

	Parms.Key = std::move(Key);

	UObject::ProcessEvent(Func, &Parms);
}


// Function B_CreativePlayerController.B_CreativePlayerController_C.InpActEvt_Four_K2Node_InputKeyEvent_3
// (BlueprintEvent)
// Parameters:
// struct FKey                             Key                                                    (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)

void AB_CreativePlayerController_C::InpActEvt_Four_K2Node_InputKeyEvent_3(const struct FKey& Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_CreativePlayerController_C", "InpActEvt_Four_K2Node_InputKeyEvent_3");

	Params::B_CreativePlayerController_C_InpActEvt_Four_K2Node_InputKeyEvent_3 Parms{};

	Parms.Key = std::move(Key);

	UObject::ProcessEvent(Func, &Parms);
}


// Function B_CreativePlayerController.B_CreativePlayerController_C.InpActEvt_LeftAlt_K2Node_InputKeyEvent_6
// (BlueprintEvent)
// Parameters:
// struct FKey                             Key                                                    (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)

void AB_CreativePlayerController_C::InpActEvt_LeftAlt_K2Node_InputKeyEvent_6(const struct FKey& Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_CreativePlayerController_C", "InpActEvt_LeftAlt_K2Node_InputKeyEvent_6");

	Params::B_CreativePlayerController_C_InpActEvt_LeftAlt_K2Node_InputKeyEvent_6 Parms{};

	Parms.Key = std::move(Key);

	UObject::ProcessEvent(Func, &Parms);
}


// Function B_CreativePlayerController.B_CreativePlayerController_C.InpActEvt_LeftAlt_K2Node_InputKeyEvent_7
// (BlueprintEvent)
// Parameters:
// struct FKey                             Key                                                    (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)

void AB_CreativePlayerController_C::InpActEvt_LeftAlt_K2Node_InputKeyEvent_7(const struct FKey& Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_CreativePlayerController_C", "InpActEvt_LeftAlt_K2Node_InputKeyEvent_7");

	Params::B_CreativePlayerController_C_InpActEvt_LeftAlt_K2Node_InputKeyEvent_7 Parms{};

	Parms.Key = std::move(Key);

	UObject::ProcessEvent(Func, &Parms);
}


// Function B_CreativePlayerController.B_CreativePlayerController_C.InpActEvt_LeftShift_K2Node_InputKeyEvent_10
// (BlueprintEvent)
// Parameters:
// struct FKey                             Key                                                    (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)

void AB_CreativePlayerController_C::InpActEvt_LeftShift_K2Node_InputKeyEvent_10(const struct FKey& Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_CreativePlayerController_C", "InpActEvt_LeftShift_K2Node_InputKeyEvent_10");

	Params::B_CreativePlayerController_C_InpActEvt_LeftShift_K2Node_InputKeyEvent_10 Parms{};

	Parms.Key = std::move(Key);

	UObject::ProcessEvent(Func, &Parms);
}


// Function B_CreativePlayerController.B_CreativePlayerController_C.InpActEvt_LeftShift_K2Node_InputKeyEvent_11
// (BlueprintEvent)
// Parameters:
// struct FKey                             Key                                                    (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)

void AB_CreativePlayerController_C::InpActEvt_LeftShift_K2Node_InputKeyEvent_11(const struct FKey& Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_CreativePlayerController_C", "InpActEvt_LeftShift_K2Node_InputKeyEvent_11");

	Params::B_CreativePlayerController_C_InpActEvt_LeftShift_K2Node_InputKeyEvent_11 Parms{};

	Parms.Key = std::move(Key);

	UObject::ProcessEvent(Func, &Parms);
}


// Function B_CreativePlayerController.B_CreativePlayerController_C.InpActEvt_Menu_K2Node_InputActionEvent_9
// (BlueprintEvent)
// Parameters:
// struct FKey                             Key                                                    (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)

void AB_CreativePlayerController_C::InpActEvt_Menu_K2Node_InputActionEvent_9(const struct FKey& Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_CreativePlayerController_C", "InpActEvt_Menu_K2Node_InputActionEvent_9");

	Params::B_CreativePlayerController_C_InpActEvt_Menu_K2Node_InputActionEvent_9 Parms{};

	Parms.Key = std::move(Key);

	UObject::ProcessEvent(Func, &Parms);
}


// Function B_CreativePlayerController.B_CreativePlayerController_C.InpActEvt_MiddleMouseButton_K2Node_InputKeyEvent_9
// (BlueprintEvent)
// Parameters:
// struct FKey                             Key                                                    (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)

void AB_CreativePlayerController_C::InpActEvt_MiddleMouseButton_K2Node_InputKeyEvent_9(const struct FKey& Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_CreativePlayerController_C", "InpActEvt_MiddleMouseButton_K2Node_InputKeyEvent_9");

	Params::B_CreativePlayerController_C_InpActEvt_MiddleMouseButton_K2Node_InputKeyEvent_9 Parms{};

	Parms.Key = std::move(Key);

	UObject::ProcessEvent(Func, &Parms);
}


// Function B_CreativePlayerController.B_CreativePlayerController_C.InpActEvt_PlayerList_K2Node_InputActionEvent_7
// (BlueprintEvent)
// Parameters:
// struct FKey                             Key                                                    (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)

void AB_CreativePlayerController_C::InpActEvt_PlayerList_K2Node_InputActionEvent_7(const struct FKey& Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_CreativePlayerController_C", "InpActEvt_PlayerList_K2Node_InputActionEvent_7");

	Params::B_CreativePlayerController_C_InpActEvt_PlayerList_K2Node_InputActionEvent_7 Parms{};

	Parms.Key = std::move(Key);

	UObject::ProcessEvent(Func, &Parms);
}


// Function B_CreativePlayerController.B_CreativePlayerController_C.InpActEvt_PlayerList_K2Node_InputActionEvent_8
// (BlueprintEvent)
// Parameters:
// struct FKey                             Key                                                    (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)

void AB_CreativePlayerController_C::InpActEvt_PlayerList_K2Node_InputActionEvent_8(const struct FKey& Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_CreativePlayerController_C", "InpActEvt_PlayerList_K2Node_InputActionEvent_8");

	Params::B_CreativePlayerController_C_InpActEvt_PlayerList_K2Node_InputActionEvent_8 Parms{};

	Parms.Key = std::move(Key);

	UObject::ProcessEvent(Func, &Parms);
}


// Function B_CreativePlayerController.B_CreativePlayerController_C.InpActEvt_R_K2Node_InputKeyEvent_8
// (BlueprintEvent)
// Parameters:
// struct FKey                             Key                                                    (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)

void AB_CreativePlayerController_C::InpActEvt_R_K2Node_InputKeyEvent_8(const struct FKey& Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_CreativePlayerController_C", "InpActEvt_R_K2Node_InputKeyEvent_8");

	Params::B_CreativePlayerController_C_InpActEvt_R_K2Node_InputKeyEvent_8 Parms{};

	Parms.Key = std::move(Key);

	UObject::ProcessEvent(Func, &Parms);
}


// Function B_CreativePlayerController.B_CreativePlayerController_C.InpActEvt_RightAlt_K2Node_InputKeyEvent_4
// (BlueprintEvent)
// Parameters:
// struct FKey                             Key                                                    (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)

void AB_CreativePlayerController_C::InpActEvt_RightAlt_K2Node_InputKeyEvent_4(const struct FKey& Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_CreativePlayerController_C", "InpActEvt_RightAlt_K2Node_InputKeyEvent_4");

	Params::B_CreativePlayerController_C_InpActEvt_RightAlt_K2Node_InputKeyEvent_4 Parms{};

	Parms.Key = std::move(Key);

	UObject::ProcessEvent(Func, &Parms);
}


// Function B_CreativePlayerController.B_CreativePlayerController_C.InpActEvt_RightAlt_K2Node_InputKeyEvent_5
// (BlueprintEvent)
// Parameters:
// struct FKey                             Key                                                    (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)

void AB_CreativePlayerController_C::InpActEvt_RightAlt_K2Node_InputKeyEvent_5(const struct FKey& Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_CreativePlayerController_C", "InpActEvt_RightAlt_K2Node_InputKeyEvent_5");

	Params::B_CreativePlayerController_C_InpActEvt_RightAlt_K2Node_InputKeyEvent_5 Parms{};

	Parms.Key = std::move(Key);

	UObject::ProcessEvent(Func, &Parms);
}


// Function B_CreativePlayerController.B_CreativePlayerController_C.InpActEvt_Six_K2Node_InputKeyEvent_1
// (BlueprintEvent)
// Parameters:
// struct FKey                             Key                                                    (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)

void AB_CreativePlayerController_C::InpActEvt_Six_K2Node_InputKeyEvent_1(const struct FKey& Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_CreativePlayerController_C", "InpActEvt_Six_K2Node_InputKeyEvent_1");

	Params::B_CreativePlayerController_C_InpActEvt_Six_K2Node_InputKeyEvent_1 Parms{};

	Parms.Key = std::move(Key);

	UObject::ProcessEvent(Func, &Parms);
}


// Function B_CreativePlayerController.B_CreativePlayerController_C.InpActEvt_TypeChatMessage_K2Node_InputActionEvent_0
// (BlueprintEvent)
// Parameters:
// struct FKey                             Key                                                    (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)

void AB_CreativePlayerController_C::InpActEvt_TypeChatMessage_K2Node_InputActionEvent_0(const struct FKey& Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_CreativePlayerController_C", "InpActEvt_TypeChatMessage_K2Node_InputActionEvent_0");

	Params::B_CreativePlayerController_C_InpActEvt_TypeChatMessage_K2Node_InputActionEvent_0 Parms{};

	Parms.Key = std::move(Key);

	UObject::ProcessEvent(Func, &Parms);
}


// Function B_CreativePlayerController.B_CreativePlayerController_C.InpActEvt_TypeChatMessage_K2Node_InputActionEvent_1
// (BlueprintEvent)
// Parameters:
// struct FKey                             Key                                                    (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)

void AB_CreativePlayerController_C::InpActEvt_TypeChatMessage_K2Node_InputActionEvent_1(const struct FKey& Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_CreativePlayerController_C", "InpActEvt_TypeChatMessage_K2Node_InputActionEvent_1");

	Params::B_CreativePlayerController_C_InpActEvt_TypeChatMessage_K2Node_InputActionEvent_1 Parms{};

	Parms.Key = std::move(Key);

	UObject::ProcessEvent(Func, &Parms);
}


// Function B_CreativePlayerController.B_CreativePlayerController_C.InpActEvt_TypeTeamChatMessage_K2Node_InputActionEvent_2
// (BlueprintEvent)
// Parameters:
// struct FKey                             Key                                                    (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)

void AB_CreativePlayerController_C::InpActEvt_TypeTeamChatMessage_K2Node_InputActionEvent_2(const struct FKey& Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_CreativePlayerController_C", "InpActEvt_TypeTeamChatMessage_K2Node_InputActionEvent_2");

	Params::B_CreativePlayerController_C_InpActEvt_TypeTeamChatMessage_K2Node_InputActionEvent_2 Parms{};

	Parms.Key = std::move(Key);

	UObject::ProcessEvent(Func, &Parms);
}


// Function B_CreativePlayerController.B_CreativePlayerController_C.InpActEvt_TypeTeamChatMessage_K2Node_InputActionEvent_3
// (BlueprintEvent)
// Parameters:
// struct FKey                             Key                                                    (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)

void AB_CreativePlayerController_C::InpActEvt_TypeTeamChatMessage_K2Node_InputActionEvent_3(const struct FKey& Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_CreativePlayerController_C", "InpActEvt_TypeTeamChatMessage_K2Node_InputActionEvent_3");

	Params::B_CreativePlayerController_C_InpActEvt_TypeTeamChatMessage_K2Node_InputActionEvent_3 Parms{};

	Parms.Key = std::move(Key);

	UObject::ProcessEvent(Func, &Parms);
}


// Function B_CreativePlayerController.B_CreativePlayerController_C.InpActEvt_Zero_K2Node_InputKeyEvent_0
// (BlueprintEvent)
// Parameters:
// struct FKey                             Key                                                    (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)

void AB_CreativePlayerController_C::InpActEvt_Zero_K2Node_InputKeyEvent_0(const struct FKey& Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_CreativePlayerController_C", "InpActEvt_Zero_K2Node_InputKeyEvent_0");

	Params::B_CreativePlayerController_C_InpActEvt_Zero_K2Node_InputKeyEvent_0 Parms{};

	Parms.Key = std::move(Key);

	UObject::ProcessEvent(Func, &Parms);
}


// Function B_CreativePlayerController.B_CreativePlayerController_C.InpAxisEvt_LookUp_K2Node_InputAxisEvent_1
// (BlueprintEvent)
// Parameters:
// float                                   AxisValue                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AB_CreativePlayerController_C::InpAxisEvt_LookUp_K2Node_InputAxisEvent_1(float AxisValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_CreativePlayerController_C", "InpAxisEvt_LookUp_K2Node_InputAxisEvent_1");

	Params::B_CreativePlayerController_C_InpAxisEvt_LookUp_K2Node_InputAxisEvent_1 Parms{};

	Parms.AxisValue = AxisValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function B_CreativePlayerController.B_CreativePlayerController_C.InpAxisEvt_Turn_K2Node_InputAxisEvent_0
// (BlueprintEvent)
// Parameters:
// float                                   AxisValue                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AB_CreativePlayerController_C::InpAxisEvt_Turn_K2Node_InputAxisEvent_0(float AxisValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_CreativePlayerController_C", "InpAxisEvt_Turn_K2Node_InputAxisEvent_0");

	Params::B_CreativePlayerController_C_InpAxisEvt_Turn_K2Node_InputAxisEvent_0 Parms{};

	Parms.AxisValue = AxisValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function B_CreativePlayerController.B_CreativePlayerController_C.InpAxisKeyEvt_MouseWheelAxis_K2Node_InputAxisKeyEvent_0
// (BlueprintEvent)
// Parameters:
// float                                   AxisValue                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AB_CreativePlayerController_C::InpAxisKeyEvt_MouseWheelAxis_K2Node_InputAxisKeyEvent_0(float AxisValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_CreativePlayerController_C", "InpAxisKeyEvt_MouseWheelAxis_K2Node_InputAxisKeyEvent_0");

	Params::B_CreativePlayerController_C_InpAxisKeyEvt_MouseWheelAxis_K2Node_InputAxisKeyEvent_0 Parms{};

	Parms.AxisValue = AxisValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function B_CreativePlayerController.B_CreativePlayerController_C.IsPlacingPrefab
// (Protected, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    Placing_Group                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AB_CreativePlayerController_C::IsPlacingPrefab(bool* Placing_Group)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_CreativePlayerController_C", "IsPlacingPrefab");

	Params::B_CreativePlayerController_C_IsPlacingPrefab Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Placing_Group != nullptr)
		*Placing_Group = Parms.Placing_Group;
}


// Function B_CreativePlayerController.B_CreativePlayerController_C.IsPlayerPawnInvalid
// (Protected, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool AB_CreativePlayerController_C::IsPlayerPawnInvalid()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_CreativePlayerController_C", "IsPlayerPawnInvalid");

	Params::B_CreativePlayerController_C_IsPlayerPawnInvalid Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function B_CreativePlayerController.B_CreativePlayerController_C.IsSwitchAlreadyConnectedToNetwork
// (Private, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class ABP_Switch_C*                     SwitchUnderTest                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class ABP_Switch_C*                     PossibleParent                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool                                    AlreadyConnected                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AB_CreativePlayerController_C::IsSwitchAlreadyConnectedToNetwork(class ABP_Switch_C* SwitchUnderTest, class ABP_Switch_C* PossibleParent, bool* AlreadyConnected)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_CreativePlayerController_C", "IsSwitchAlreadyConnectedToNetwork");

	Params::B_CreativePlayerController_C_IsSwitchAlreadyConnectedToNetwork Parms{};

	Parms.SwitchUnderTest = SwitchUnderTest;
	Parms.PossibleParent = PossibleParent;

	UObject::ProcessEvent(Func, &Parms);

	if (AlreadyConnected != nullptr)
		*AlreadyConnected = Parms.AlreadyConnected;
}


// Function B_CreativePlayerController.B_CreativePlayerController_C.MakePrefab
// (Protected, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// struct FPrefabToSave                    Prefab                                                 (Parm, OutParm)

void AB_CreativePlayerController_C::MakePrefab(struct FPrefabToSave* Prefab)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_CreativePlayerController_C", "MakePrefab");

	Params::B_CreativePlayerController_C_MakePrefab Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Prefab != nullptr)
		*Prefab = std::move(Parms.Prefab);
}


// Function B_CreativePlayerController.B_CreativePlayerController_C.OpenEditUi
// (Public, BlueprintCallable, BlueprintEvent)

void AB_CreativePlayerController_C::OpenEditUi()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_CreativePlayerController_C", "OpenEditUi");

	UObject::ProcessEvent(Func, nullptr);
}


// Function B_CreativePlayerController.B_CreativePlayerController_C.OpenTabScreen
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    IsPlayTest                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    IsRequiredScreen                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AB_CreativePlayerController_C::OpenTabScreen(bool IsPlayTest, bool IsRequiredScreen)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_CreativePlayerController_C", "OpenTabScreen");

	Params::B_CreativePlayerController_C_OpenTabScreen Parms{};

	Parms.IsPlayTest = IsPlayTest;
	Parms.IsRequiredScreen = IsRequiredScreen;

	UObject::ProcessEvent(Func, &Parms);
}


// Function B_CreativePlayerController.B_CreativePlayerController_C.PlaceActor
// (Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UClass*                           ActorClass                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// struct FTransform                       SpawnTransform                                         (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    HasPrefabInfo                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Activated                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    StartAwake                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    IsFreezed                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    BreaksAfterUse                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          Color                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AB_CreativePlayerController_C::PlaceActor(class UClass* ActorClass, const struct FTransform& SpawnTransform, bool HasPrefabInfo, bool Activated, bool StartAwake, bool IsFreezed, bool BreaksAfterUse, const struct FVector& Color)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_CreativePlayerController_C", "PlaceActor");

	Params::B_CreativePlayerController_C_PlaceActor Parms{};

	Parms.ActorClass = ActorClass;
	Parms.SpawnTransform = std::move(SpawnTransform);
	Parms.HasPrefabInfo = HasPrefabInfo;
	Parms.Activated = Activated;
	Parms.StartAwake = StartAwake;
	Parms.IsFreezed = IsFreezed;
	Parms.BreaksAfterUse = BreaksAfterUse;
	Parms.Color = std::move(Color);

	UObject::ProcessEvent(Func, &Parms);
}


// Function B_CreativePlayerController.B_CreativePlayerController_C.PlaceActorMulti
// (Net, NetReliable, NetMulticast, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector                          Location                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class AActor*                           PlacedActor                                            (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash)

void AB_CreativePlayerController_C::PlaceActorMulti(const struct FVector& Location, const class AActor*& PlacedActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_CreativePlayerController_C", "PlaceActorMulti");

	Params::B_CreativePlayerController_C_PlaceActorMulti Parms{};

	Parms.Location = std::move(Location);
	Parms.PlacedActor = PlacedActor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function B_CreativePlayerController.B_CreativePlayerController_C.PlaceActors
// (Protected, HasDefaults, BlueprintCallable, BlueprintEvent)

void AB_CreativePlayerController_C::PlaceActors()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_CreativePlayerController_C", "PlaceActors");

	UObject::ProcessEvent(Func, nullptr);
}


// Function B_CreativePlayerController.B_CreativePlayerController_C.PlaceActorServer
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UClass*                           ActorClass                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// struct FTransform                       SpawnTransform                                         (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    HasPrefabInfo                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Activated                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    StartAwake                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    IsFreezed                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    BreaksAfterUse                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          Color                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AB_CreativePlayerController_C::PlaceActorServer(class UClass* ActorClass, const struct FTransform& SpawnTransform, bool HasPrefabInfo, bool Activated, bool StartAwake, bool IsFreezed, bool BreaksAfterUse, const struct FVector& Color)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_CreativePlayerController_C", "PlaceActorServer");

	Params::B_CreativePlayerController_C_PlaceActorServer Parms{};

	Parms.ActorClass = ActorClass;
	Parms.SpawnTransform = std::move(SpawnTransform);
	Parms.HasPrefabInfo = HasPrefabInfo;
	Parms.Activated = Activated;
	Parms.StartAwake = StartAwake;
	Parms.IsFreezed = IsFreezed;
	Parms.BreaksAfterUse = BreaksAfterUse;
	Parms.Color = std::move(Color);

	UObject::ProcessEvent(Func, &Parms);
}


// Function B_CreativePlayerController.B_CreativePlayerController_C.PlaceSelectedActors
// (Public, BlueprintCallable, BlueprintEvent)

void AB_CreativePlayerController_C::PlaceSelectedActors()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_CreativePlayerController_C", "PlaceSelectedActors");

	UObject::ProcessEvent(Func, nullptr);
}


// Function B_CreativePlayerController.B_CreativePlayerController_C.PlayDeleteSoundMulti
// (Net, NetReliable, NetMulticast, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector                          Location                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AB_CreativePlayerController_C::PlayDeleteSoundMulti(const struct FVector& Location)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_CreativePlayerController_C", "PlayDeleteSoundMulti");

	Params::B_CreativePlayerController_C_PlayDeleteSoundMulti Parms{};

	Parms.Location = std::move(Location);

	UObject::ProcessEvent(Func, &Parms);
}


// Function B_CreativePlayerController.B_CreativePlayerController_C.PlayerDeselectMultipleForEditingServer
// (Net, NetReliable, NetServer, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<class AActor*>                   ToUnselect                                             (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)

void AB_CreativePlayerController_C::PlayerDeselectMultipleForEditingServer(const TArray<class AActor*>& ToUnselect)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_CreativePlayerController_C", "PlayerDeselectMultipleForEditingServer");

	Params::B_CreativePlayerController_C_PlayerDeselectMultipleForEditingServer Parms{};

	Parms.ToUnselect = std::move(ToUnselect);

	UObject::ProcessEvent(Func, &Parms);
}


// Function B_CreativePlayerController.B_CreativePlayerController_C.ReceiveBeginPlay
// (Event, Protected, BlueprintEvent)

void AB_CreativePlayerController_C::ReceiveBeginPlay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_CreativePlayerController_C", "ReceiveBeginPlay");

	UObject::ProcessEvent(Func, nullptr);
}


// Function B_CreativePlayerController.B_CreativePlayerController_C.ReceiveTick
// (Event, Public, BlueprintEvent)
// Parameters:
// float                                   DeltaSeconds                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AB_CreativePlayerController_C::ReceiveTick(float DeltaSeconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_CreativePlayerController_C", "ReceiveTick");

	Params::B_CreativePlayerController_C_ReceiveTick Parms{};

	Parms.DeltaSeconds = DeltaSeconds;

	UObject::ProcessEvent(Func, &Parms);
}


// Function B_CreativePlayerController.B_CreativePlayerController_C.RefreshPawn
// (Protected, HasDefaults, BlueprintCallable, BlueprintEvent)

void AB_CreativePlayerController_C::RefreshPawn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_CreativePlayerController_C", "RefreshPawn");

	UObject::ProcessEvent(Func, nullptr);
}


// Function B_CreativePlayerController.B_CreativePlayerController_C.RemoveSelectedTargetFromSwitch
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           TargetActor                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class ABP_Switch_C*                     TargetSwitch                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void AB_CreativePlayerController_C::RemoveSelectedTargetFromSwitch(class AActor* TargetActor, class ABP_Switch_C* TargetSwitch)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_CreativePlayerController_C", "RemoveSelectedTargetFromSwitch");

	Params::B_CreativePlayerController_C_RemoveSelectedTargetFromSwitch Parms{};

	Parms.TargetActor = TargetActor;
	Parms.TargetSwitch = TargetSwitch;

	UObject::ProcessEvent(Func, &Parms);
}


// Function B_CreativePlayerController.B_CreativePlayerController_C.RemoveSelectedTargetsFromSwitch
// (Protected, BlueprintCallable, BlueprintEvent)

void AB_CreativePlayerController_C::RemoveSelectedTargetsFromSwitch()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_CreativePlayerController_C", "RemoveSelectedTargetsFromSwitch");

	UObject::ProcessEvent(Func, nullptr);
}


// Function B_CreativePlayerController.B_CreativePlayerController_C.RemoveTargetFromSwitch
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           Actor_to_Remove                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class ABP_Switch_C*                     SWITCH                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// TArray<class AActor*>                   TempTargetList                                         (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)

void AB_CreativePlayerController_C::RemoveTargetFromSwitch(class AActor* Actor_to_Remove, class ABP_Switch_C* SWITCH, TArray<class AActor*>& TempTargetList)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_CreativePlayerController_C", "RemoveTargetFromSwitch");

	Params::B_CreativePlayerController_C_RemoveTargetFromSwitch Parms{};

	Parms.Actor_to_Remove = Actor_to_Remove;
	Parms.SWITCH = SWITCH;
	Parms.TempTargetList = std::move(TempTargetList);

	UObject::ProcessEvent(Func, &Parms);

	TempTargetList = std::move(Parms.TempTargetList);
}


// Function B_CreativePlayerController.B_CreativePlayerController_C.RemoveTargetFromSwitchServer
// (Net, NetReliable, NetServer, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           ActorToRemove                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class ABP_Switch_C*                     SWITCH                                                 (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash)
// TArray<class AActor*>                   OldTargetList                                          (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)

void AB_CreativePlayerController_C::RemoveTargetFromSwitchServer(class AActor* ActorToRemove, const class ABP_Switch_C*& SWITCH, const TArray<class AActor*>& OldTargetList)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_CreativePlayerController_C", "RemoveTargetFromSwitchServer");

	Params::B_CreativePlayerController_C_RemoveTargetFromSwitchServer Parms{};

	Parms.ActorToRemove = ActorToRemove;
	Parms.SWITCH = SWITCH;
	Parms.OldTargetList = std::move(OldTargetList);

	UObject::ProcessEvent(Func, &Parms);
}


// Function B_CreativePlayerController.B_CreativePlayerController_C.ResetPawnTilt
// (Public, BlueprintCallable, BlueprintEvent)

void AB_CreativePlayerController_C::ResetPawnTilt()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_CreativePlayerController_C", "ResetPawnTilt");

	UObject::ProcessEvent(Func, nullptr);
}


// Function B_CreativePlayerController.B_CreativePlayerController_C.RespawnPlayerPawn
// (Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// ETeamID                                 Team                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AB_CreativePlayerController_C::RespawnPlayerPawn(ETeamID Team)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_CreativePlayerController_C", "RespawnPlayerPawn");

	Params::B_CreativePlayerController_C_RespawnPlayerPawn Parms{};

	Parms.Team = Team;

	UObject::ProcessEvent(Func, &Parms);
}


// Function B_CreativePlayerController.B_CreativePlayerController_C.RespawnPlayerPawnServer
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)
// Parameters:
// ETeamID                                 Team                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AB_CreativePlayerController_C::RespawnPlayerPawnServer(ETeamID Team)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_CreativePlayerController_C", "RespawnPlayerPawnServer");

	Params::B_CreativePlayerController_C_RespawnPlayerPawnServer Parms{};

	Parms.Team = Team;

	UObject::ProcessEvent(Func, &Parms);
}


// Function B_CreativePlayerController.B_CreativePlayerController_C.SaveMousePosition
// (Protected, BlueprintCallable, BlueprintEvent)

void AB_CreativePlayerController_C::SaveMousePosition()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_CreativePlayerController_C", "SaveMousePosition");

	UObject::ProcessEvent(Func, nullptr);
}


// Function B_CreativePlayerController.B_CreativePlayerController_C.SelectActor
// (Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           TargetActor                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void AB_CreativePlayerController_C::SelectActor(class AActor* TargetActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_CreativePlayerController_C", "SelectActor");

	Params::B_CreativePlayerController_C_SelectActor Parms{};

	Parms.TargetActor = TargetActor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function B_CreativePlayerController.B_CreativePlayerController_C.SelectActorSever
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           ActorToEdit                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void AB_CreativePlayerController_C::SelectActorSever(class AActor* ActorToEdit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_CreativePlayerController_C", "SelectActorSever");

	Params::B_CreativePlayerController_C_SelectActorSever Parms{};

	Parms.ActorToEdit = ActorToEdit;

	UObject::ProcessEvent(Func, &Parms);
}


// Function B_CreativePlayerController.B_CreativePlayerController_C.SelectMultiple
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           HitActor                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void AB_CreativePlayerController_C::SelectMultiple(class AActor* HitActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_CreativePlayerController_C", "SelectMultiple");

	Params::B_CreativePlayerController_C_SelectMultiple Parms{};

	Parms.HitActor = HitActor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function B_CreativePlayerController.B_CreativePlayerController_C.SetActorDefaultRotation
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           ActorToEdit                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void AB_CreativePlayerController_C::SetActorDefaultRotation(class AActor* ActorToEdit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_CreativePlayerController_C", "SetActorDefaultRotation");

	Params::B_CreativePlayerController_C_SetActorDefaultRotation Parms{};

	Parms.ActorToEdit = ActorToEdit;

	UObject::ProcessEvent(Func, &Parms);
}


// Function B_CreativePlayerController.B_CreativePlayerController_C.SetActorDefaultScale
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           ActorToEdit                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void AB_CreativePlayerController_C::SetActorDefaultScale(class AActor* ActorToEdit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_CreativePlayerController_C", "SetActorDefaultScale");

	Params::B_CreativePlayerController_C_SetActorDefaultScale Parms{};

	Parms.ActorToEdit = ActorToEdit;

	UObject::ProcessEvent(Func, &Parms);
}


// Function B_CreativePlayerController.B_CreativePlayerController_C.SetActorToPlace
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UClass*                           ActorClass                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void AB_CreativePlayerController_C::SetActorToPlace(class UClass* ActorClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_CreativePlayerController_C", "SetActorToPlace");

	Params::B_CreativePlayerController_C_SetActorToPlace Parms{};

	Parms.ActorClass = ActorClass;

	UObject::ProcessEvent(Func, &Parms);
}


// Function B_CreativePlayerController.B_CreativePlayerController_C.SetCollisionWallAppearance
// (Protected, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    NeedsToBeSeen                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AB_CreativePlayerController_C::SetCollisionWallAppearance(bool NeedsToBeSeen)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_CreativePlayerController_C", "SetCollisionWallAppearance");

	Params::B_CreativePlayerController_C_SetCollisionWallAppearance Parms{};

	Parms.NeedsToBeSeen = NeedsToBeSeen;

	UObject::ProcessEvent(Func, &Parms);
}


// Function B_CreativePlayerController.B_CreativePlayerController_C.SetMousePositionToMiddleOfScreen
// (Public, BlueprintCallable, BlueprintEvent)

void AB_CreativePlayerController_C::SetMousePositionToMiddleOfScreen()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_CreativePlayerController_C", "SetMousePositionToMiddleOfScreen");

	UObject::ProcessEvent(Func, nullptr);
}


// Function B_CreativePlayerController.B_CreativePlayerController_C.SetMouseToSavedPosition
// (Protected, BlueprintCallable, BlueprintEvent)

void AB_CreativePlayerController_C::SetMouseToSavedPosition()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_CreativePlayerController_C", "SetMouseToSavedPosition");

	UObject::ProcessEvent(Func, nullptr);
}


// Function B_CreativePlayerController.B_CreativePlayerController_C.SetPrefabToPlace
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FPrefabToSave                    Prefab                                                 (BlueprintVisible, BlueprintReadOnly, Parm)

void AB_CreativePlayerController_C::SetPrefabToPlace(const struct FPrefabToSave& Prefab)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_CreativePlayerController_C", "SetPrefabToPlace");

	Params::B_CreativePlayerController_C_SetPrefabToPlace Parms{};

	Parms.Prefab = std::move(Prefab);

	UObject::ProcessEvent(Func, &Parms);
}


// Function B_CreativePlayerController.B_CreativePlayerController_C.SetScopeMode
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Active                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AB_CreativePlayerController_C::SetScopeMode(bool Active)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_CreativePlayerController_C", "SetScopeMode");

	Params::B_CreativePlayerController_C_SetScopeMode Parms{};

	Parms.Active = Active;

	UObject::ProcessEvent(Func, &Parms);
}


// Function B_CreativePlayerController.B_CreativePlayerController_C.ShowPlayerListMenu
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    WasRelease                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AB_CreativePlayerController_C::ShowPlayerListMenu(bool WasRelease)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_CreativePlayerController_C", "ShowPlayerListMenu");

	Params::B_CreativePlayerController_C_ShowPlayerListMenu Parms{};

	Parms.WasRelease = WasRelease;

	UObject::ProcessEvent(Func, &Parms);
}


// Function B_CreativePlayerController.B_CreativePlayerController_C.ShowTeamSelectClient
// (Net, NetReliable, NetClient, BlueprintCallable, BlueprintEvent)

void AB_CreativePlayerController_C::ShowTeamSelectClient()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_CreativePlayerController_C", "ShowTeamSelectClient");

	UObject::ProcessEvent(Func, nullptr);
}


// Function B_CreativePlayerController.B_CreativePlayerController_C.SpawnDuplicatedActors
// (Protected, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<class AActor*>                   ActorsToDuplicate                                      (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)

void AB_CreativePlayerController_C::SpawnDuplicatedActors(TArray<class AActor*>& ActorsToDuplicate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_CreativePlayerController_C", "SpawnDuplicatedActors");

	Params::B_CreativePlayerController_C_SpawnDuplicatedActors Parms{};

	Parms.ActorsToDuplicate = std::move(ActorsToDuplicate);

	UObject::ProcessEvent(Func, &Parms);

	ActorsToDuplicate = std::move(Parms.ActorsToDuplicate);
}


// Function B_CreativePlayerController.B_CreativePlayerController_C.StartDraggingSelectedActor
// (Public, BlueprintCallable, BlueprintEvent)

void AB_CreativePlayerController_C::StartDraggingSelectedActor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_CreativePlayerController_C", "StartDraggingSelectedActor");

	UObject::ProcessEvent(Func, nullptr);
}


// Function B_CreativePlayerController.B_CreativePlayerController_C.StopModifyingAndDraggingActor
// (Protected, BlueprintCallable, BlueprintEvent)

void AB_CreativePlayerController_C::StopModifyingAndDraggingActor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_CreativePlayerController_C", "StopModifyingAndDraggingActor");

	UObject::ProcessEvent(Func, nullptr);
}


// Function B_CreativePlayerController.B_CreativePlayerController_C.StopPlacingAndEnableUiUse
// (Protected, BlueprintCallable, BlueprintEvent)

void AB_CreativePlayerController_C::StopPlacingAndEnableUiUse()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_CreativePlayerController_C", "StopPlacingAndEnableUiUse");

	UObject::ProcessEvent(Func, nullptr);
}


// Function B_CreativePlayerController.B_CreativePlayerController_C.SwitchConnectionAlreadyDrawn
// (Protected, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class AActor*                           TestStartActor                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class AActor*                           TestEndActor                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool                                    AlreadyDrawn                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AB_CreativePlayerController_C::SwitchConnectionAlreadyDrawn(class AActor* TestStartActor, class AActor* TestEndActor, bool* AlreadyDrawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_CreativePlayerController_C", "SwitchConnectionAlreadyDrawn");

	Params::B_CreativePlayerController_C_SwitchConnectionAlreadyDrawn Parms{};

	Parms.TestStartActor = TestStartActor;
	Parms.TestEndActor = TestEndActor;

	UObject::ProcessEvent(Func, &Parms);

	if (AlreadyDrawn != nullptr)
		*AlreadyDrawn = Parms.AlreadyDrawn;
}


// Function B_CreativePlayerController.B_CreativePlayerController_C.TickEditAndPlayTestHighlights
// (Protected, BlueprintCallable, BlueprintEvent)

void AB_CreativePlayerController_C::TickEditAndPlayTestHighlights()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_CreativePlayerController_C", "TickEditAndPlayTestHighlights");

	UObject::ProcessEvent(Func, nullptr);
}


// Function B_CreativePlayerController.B_CreativePlayerController_C.TickEditHighlights
// (Protected, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           TargetActor                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class AActor*                           OutTargetActor                                         (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void AB_CreativePlayerController_C::TickEditHighlights(class AActor* TargetActor, class AActor** OutTargetActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_CreativePlayerController_C", "TickEditHighlights");

	Params::B_CreativePlayerController_C_TickEditHighlights Parms{};

	Parms.TargetActor = TargetActor;

	UObject::ProcessEvent(Func, &Parms);

	if (OutTargetActor != nullptr)
		*OutTargetActor = Parms.OutTargetActor;
}


// Function B_CreativePlayerController.B_CreativePlayerController_C.TickModifyingProp
// (Protected, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// double                                  Horizontal                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double                                  Vertical                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AB_CreativePlayerController_C::TickModifyingProp(double Horizontal, double Vertical)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_CreativePlayerController_C", "TickModifyingProp");

	Params::B_CreativePlayerController_C_TickModifyingProp Parms{};

	Parms.Horizontal = Horizontal;
	Parms.Vertical = Vertical;

	UObject::ProcessEvent(Func, &Parms);
}


// Function B_CreativePlayerController.B_CreativePlayerController_C.TickVisuals
// (Public, BlueprintCallable, BlueprintEvent)

void AB_CreativePlayerController_C::TickVisuals()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_CreativePlayerController_C", "TickVisuals");

	UObject::ProcessEvent(Func, nullptr);
}


// Function B_CreativePlayerController.B_CreativePlayerController_C.ToggleActionActor
// (Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           ActorToToggle                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void AB_CreativePlayerController_C::ToggleActionActor(class AActor* ActorToToggle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_CreativePlayerController_C", "ToggleActionActor");

	Params::B_CreativePlayerController_C_ToggleActionActor Parms{};

	Parms.ActorToToggle = ActorToToggle;

	UObject::ProcessEvent(Func, &Parms);
}


// Function B_CreativePlayerController.B_CreativePlayerController_C.ToggleEscMenu
// (Public, BlueprintCallable, BlueprintEvent)

void AB_CreativePlayerController_C::ToggleEscMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_CreativePlayerController_C", "ToggleEscMenu");

	UObject::ProcessEvent(Func, nullptr);
}


// Function B_CreativePlayerController.B_CreativePlayerController_C.ToggleFreeMouse
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    DisableTurn                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AB_CreativePlayerController_C::ToggleFreeMouse(bool DisableTurn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_CreativePlayerController_C", "ToggleFreeMouse");

	Params::B_CreativePlayerController_C_ToggleFreeMouse Parms{};

	Parms.DisableTurn = DisableTurn;

	UObject::ProcessEvent(Func, &Parms);
}


// Function B_CreativePlayerController.B_CreativePlayerController_C.ToggleGravityApplication
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    UsePhysicsNow                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AB_CreativePlayerController_C::ToggleGravityApplication(bool UsePhysicsNow)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_CreativePlayerController_C", "ToggleGravityApplication");

	Params::B_CreativePlayerController_C_ToggleGravityApplication Parms{};

	Parms.UsePhysicsNow = UsePhysicsNow;

	UObject::ProcessEvent(Func, &Parms);
}


// Function B_CreativePlayerController.B_CreativePlayerController_C.TogglePlayTest
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// E_CreativePlayerMode                    NewMode                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AB_CreativePlayerController_C::TogglePlayTest(E_CreativePlayerMode NewMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_CreativePlayerController_C", "TogglePlayTest");

	Params::B_CreativePlayerController_C_TogglePlayTest Parms{};

	Parms.NewMode = NewMode;

	UObject::ProcessEvent(Func, &Parms);
}


// Function B_CreativePlayerController.B_CreativePlayerController_C.ToggleSwitchBreaksAfterUse
// (Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ABP_Switch_C*                     SWITCH                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool                                    BreaksAfterUse                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AB_CreativePlayerController_C::ToggleSwitchBreaksAfterUse(class ABP_Switch_C* SWITCH, bool BreaksAfterUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_CreativePlayerController_C", "ToggleSwitchBreaksAfterUse");

	Params::B_CreativePlayerController_C_ToggleSwitchBreaksAfterUse Parms{};

	Parms.SWITCH = SWITCH;
	Parms.BreaksAfterUse = BreaksAfterUse;

	UObject::ProcessEvent(Func, &Parms);
}


// Function B_CreativePlayerController.B_CreativePlayerController_C.ToggleSwitchBreaksServer
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ABP_Switch_C*                     SWITCH                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool                                    BreaksAfterUse                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AB_CreativePlayerController_C::ToggleSwitchBreaksServer(class ABP_Switch_C* SWITCH, bool BreaksAfterUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_CreativePlayerController_C", "ToggleSwitchBreaksServer");

	Params::B_CreativePlayerController_C_ToggleSwitchBreaksServer Parms{};

	Parms.SWITCH = SWITCH;
	Parms.BreaksAfterUse = BreaksAfterUse;

	UObject::ProcessEvent(Func, &Parms);
}


// Function B_CreativePlayerController.B_CreativePlayerController_C.TraceActorToPlace
// (Protected, HasDefaults, BlueprintCallable, BlueprintEvent)

void AB_CreativePlayerController_C::TraceActorToPlace()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_CreativePlayerController_C", "TraceActorToPlace");

	UObject::ProcessEvent(Func, nullptr);
}


// Function B_CreativePlayerController.B_CreativePlayerController_C.TransformTrace
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class APawn*                            Pawn_0                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class AActor*                           Actor                                                  (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// E_Axis                                  ModifyingAxis                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AB_CreativePlayerController_C::TransformTrace(class APawn* Pawn_0, class AActor** Actor, E_Axis* ModifyingAxis)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_CreativePlayerController_C", "TransformTrace");

	Params::B_CreativePlayerController_C_TransformTrace Parms{};

	Parms.Pawn_0 = Pawn_0;

	UObject::ProcessEvent(Func, &Parms);

	if (Actor != nullptr)
		*Actor = Parms.Actor;

	if (ModifyingAxis != nullptr)
		*ModifyingAxis = Parms.ModifyingAxis;
}


// Function B_CreativePlayerController.B_CreativePlayerController_C.TurnPropMeshIntoPlaceModeMesh
// (Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UPrimitiveComponent*              CurrentMesh                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void AB_CreativePlayerController_C::TurnPropMeshIntoPlaceModeMesh(class UPrimitiveComponent* CurrentMesh)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_CreativePlayerController_C", "TurnPropMeshIntoPlaceModeMesh");

	Params::B_CreativePlayerController_C_TurnPropMeshIntoPlaceModeMesh Parms{};

	Parms.CurrentMesh = CurrentMesh;

	UObject::ProcessEvent(Func, &Parms);
}


// Function B_CreativePlayerController.B_CreativePlayerController_C.UpdateActionBoolServer
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           Actor                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool                                    Activated                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AB_CreativePlayerController_C::UpdateActionBoolServer(class AActor* Actor, bool Activated)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_CreativePlayerController_C", "UpdateActionBoolServer");

	Params::B_CreativePlayerController_C_UpdateActionBoolServer Parms{};

	Parms.Actor = Actor;
	Parms.Activated = Activated;

	UObject::ProcessEvent(Func, &Parms);
}


// Function B_CreativePlayerController.B_CreativePlayerController_C.UpdateActorTransformServer
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           SelectedActor                                          (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// struct FTransform                       Transform                                              (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AB_CreativePlayerController_C::UpdateActorTransformServer(const class AActor* SelectedActor, const struct FTransform& Transform)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_CreativePlayerController_C", "UpdateActorTransformServer");

	Params::B_CreativePlayerController_C_UpdateActorTransformServer Parms{};

	Parms.SelectedActor = SelectedActor;
	Parms.Transform = std::move(Transform);

	UObject::ProcessEvent(Func, &Parms);
}


// Function B_CreativePlayerController.B_CreativePlayerController_C.UpdateDraggedPropRotation
// (Protected, BlueprintCallable, BlueprintEvent)

void AB_CreativePlayerController_C::UpdateDraggedPropRotation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_CreativePlayerController_C", "UpdateDraggedPropRotation");

	UObject::ProcessEvent(Func, nullptr);
}


// Function B_CreativePlayerController.B_CreativePlayerController_C.UpdateFreezeServer
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AB_StaticMeshProp_C*              TargetProp_0                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool                                    Freeze                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AB_CreativePlayerController_C::UpdateFreezeServer(class AB_StaticMeshProp_C* TargetProp_0, bool Freeze)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_CreativePlayerController_C", "UpdateFreezeServer");

	Params::B_CreativePlayerController_C_UpdateFreezeServer Parms{};

	Parms.TargetProp_0 = TargetProp_0;
	Parms.Freeze = Freeze;

	UObject::ProcessEvent(Func, &Parms);
}


// Function B_CreativePlayerController.B_CreativePlayerController_C.UpdateGizmoActor
// (Protected, HasDefaults, BlueprintCallable, BlueprintEvent)

void AB_CreativePlayerController_C::UpdateGizmoActor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_CreativePlayerController_C", "UpdateGizmoActor");

	UObject::ProcessEvent(Func, nullptr);
}


// Function B_CreativePlayerController.B_CreativePlayerController_C.UpdateGizmoVisibility
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void AB_CreativePlayerController_C::UpdateGizmoVisibility()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_CreativePlayerController_C", "UpdateGizmoVisibility");

	UObject::ProcessEvent(Func, nullptr);
}


// Function B_CreativePlayerController.B_CreativePlayerController_C.UpdateMaterialServer
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ABP_PlaceableStaticProp_C*        TargetStructure                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class UB_BasePlaceableMaterialOverwrite_C*MaterialOverwrite                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class UMaterialInterface*               NewMaterial                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// int32                                   Index_0                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AB_CreativePlayerController_C::UpdateMaterialServer(class ABP_PlaceableStaticProp_C* TargetStructure, class UB_BasePlaceableMaterialOverwrite_C* MaterialOverwrite, class UMaterialInterface* NewMaterial, int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_CreativePlayerController_C", "UpdateMaterialServer");

	Params::B_CreativePlayerController_C_UpdateMaterialServer Parms{};

	Parms.TargetStructure = TargetStructure;
	Parms.MaterialOverwrite = MaterialOverwrite;
	Parms.NewMaterial = NewMaterial;
	Parms.Index_0 = Index_0;

	UObject::ProcessEvent(Func, &Parms);
}


// Function B_CreativePlayerController.B_CreativePlayerController_C.UpdatePlayerModeByPlayTestState
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    HasPlayTestStarted                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AB_CreativePlayerController_C::UpdatePlayerModeByPlayTestState(bool HasPlayTestStarted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_CreativePlayerController_C", "UpdatePlayerModeByPlayTestState");

	Params::B_CreativePlayerController_C_UpdatePlayerModeByPlayTestState Parms{};

	Parms.HasPlayTestStarted = HasPlayTestStarted;

	UObject::ProcessEvent(Func, &Parms);
}


// Function B_CreativePlayerController.B_CreativePlayerController_C.UpdatePrefabSizeToPlace
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// double                                  Axis                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AB_CreativePlayerController_C::UpdatePrefabSizeToPlace(double Axis)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_CreativePlayerController_C", "UpdatePrefabSizeToPlace");

	Params::B_CreativePlayerController_C_UpdatePrefabSizeToPlace Parms{};

	Parms.Axis = Axis;

	UObject::ProcessEvent(Func, &Parms);
}


// Function B_CreativePlayerController.B_CreativePlayerController_C.UpdateSelectedActorsTransforms
// (Protected, HasDefaults, BlueprintCallable, BlueprintEvent)

void AB_CreativePlayerController_C::UpdateSelectedActorsTransforms()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_CreativePlayerController_C", "UpdateSelectedActorsTransforms");

	UObject::ProcessEvent(Func, nullptr);
}


// Function B_CreativePlayerController.B_CreativePlayerController_C.UpdateSkills
// (Protected, BlueprintCallable, BlueprintEvent)

void AB_CreativePlayerController_C::UpdateSkills()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_CreativePlayerController_C", "UpdateSkills");

	UObject::ProcessEvent(Func, nullptr);
}


// Function B_CreativePlayerController.B_CreativePlayerController_C.UpdateStartAwakeServer
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AB_StaticMeshProp_C*              TargetProp_0                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool                                    StartAwake                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AB_CreativePlayerController_C::UpdateStartAwakeServer(class AB_StaticMeshProp_C* TargetProp_0, bool StartAwake)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_CreativePlayerController_C", "UpdateStartAwakeServer");

	Params::B_CreativePlayerController_C_UpdateStartAwakeServer Parms{};

	Parms.TargetProp_0 = TargetProp_0;
	Parms.StartAwake = StartAwake;

	UObject::ProcessEvent(Func, &Parms);
}


// Function B_CreativePlayerController.B_CreativePlayerController_C.UpdateVisibleSwitchConnections
// (Protected, BlueprintCallable, BlueprintEvent)

void AB_CreativePlayerController_C::UpdateVisibleSwitchConnections()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_CreativePlayerController_C", "UpdateVisibleSwitchConnections");

	UObject::ProcessEvent(Func, nullptr);
}


// Function B_CreativePlayerController.B_CreativePlayerController_C.useEnterKeyInputForEditUi
// (Protected, BlueprintCallable, BlueprintEvent)

void AB_CreativePlayerController_C::UseEnterKeyInputForEditUi()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_CreativePlayerController_C", "useEnterKeyInputForEditUi");

	UObject::ProcessEvent(Func, nullptr);
}


// Function B_CreativePlayerController.B_CreativePlayerController_C.VisualizeSingleSwitchConnection
// (Protected, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           StartActor                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class AActor*                           EndActor                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void AB_CreativePlayerController_C::VisualizeSingleSwitchConnection(class AActor* StartActor, class AActor* EndActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_CreativePlayerController_C", "VisualizeSingleSwitchConnection");

	Params::B_CreativePlayerController_C_VisualizeSingleSwitchConnection Parms{};

	Parms.StartActor = StartActor;
	Parms.EndActor = EndActor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function B_CreativePlayerController.B_CreativePlayerController_C.VisualizeSwitchConnections
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           InspectedActor                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void AB_CreativePlayerController_C::VisualizeSwitchConnections(class AActor* InspectedActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_CreativePlayerController_C", "VisualizeSwitchConnections");

	Params::B_CreativePlayerController_C_VisualizeSwitchConnections Parms{};

	Parms.InspectedActor = InspectedActor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function B_CreativePlayerController.B_CreativePlayerController_C.GetAnchorActor
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class AActor*                           AnchorActor                                            (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void AB_CreativePlayerController_C::GetAnchorActor(class AActor** AnchorActor) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_CreativePlayerController_C", "GetAnchorActor");

	Params::B_CreativePlayerController_C_GetAnchorActor Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (AnchorActor != nullptr)
		*AnchorActor = Parms.AnchorActor;
}


// Function B_CreativePlayerController.B_CreativePlayerController_C.GetNameForSingleActorOrGroup
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// bool                                    IsGroupName                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class AActor*                           TargetActor                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class FText                             FullName                                               (Parm, OutParm)

void AB_CreativePlayerController_C::GetNameForSingleActorOrGroup(bool IsGroupName, class AActor* TargetActor, class FText* FullName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_CreativePlayerController_C", "GetNameForSingleActorOrGroup");

	Params::B_CreativePlayerController_C_GetNameForSingleActorOrGroup Parms{};

	Parms.IsGroupName = IsGroupName;
	Parms.TargetActor = TargetActor;

	UObject::ProcessEvent(Func, &Parms);

	if (FullName != nullptr)
		*FullName = std::move(Parms.FullName);
}


// Function B_CreativePlayerController.B_CreativePlayerController_C.IsPlacing
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// bool                                    IsPlacing_0                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AB_CreativePlayerController_C::IsPlacing(bool* IsPlacing_0) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_CreativePlayerController_C", "IsPlacing");

	Params::B_CreativePlayerController_C_IsPlacing Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (IsPlacing_0 != nullptr)
		*IsPlacing_0 = Parms.IsPlacing_0;
}

}

