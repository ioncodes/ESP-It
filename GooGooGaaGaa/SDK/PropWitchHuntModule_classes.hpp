#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: PropWitchHuntModule

#include "Basic.hpp"

#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "PropWitchHuntModule_structs.hpp"
#include "NetCore_structs.hpp"
#include "OnlineSubsystemUtils_classes.hpp"
#include "AdvancedSessions_classes.hpp"


namespace SDK
{

// Class PropWitchHuntModule.ActionActorSubsystem
// 0x0000 (0x0030 - 0x0030)
class UActionActorSubsystem : public UGameInstanceSubsystem
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActionActorSubsystem">();
	}
	static class UActionActorSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActionActorSubsystem>();
	}
};
static_assert(alignof(UActionActorSubsystem) == 0x000008, "Wrong alignment on UActionActorSubsystem");
static_assert(sizeof(UActionActorSubsystem) == 0x000030, "Wrong size on UActionActorSubsystem");

// Class PropWitchHuntModule.AsyncLibDummy
// 0x0000 (0x0028 - 0x0028)
class UAsyncLibDummy final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AsyncLibDummy">();
	}
	static class UAsyncLibDummy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAsyncLibDummy>();
	}
};
static_assert(alignof(UAsyncLibDummy) == 0x000008, "Wrong alignment on UAsyncLibDummy");
static_assert(sizeof(UAsyncLibDummy) == 0x000028, "Wrong size on UAsyncLibDummy");

// Class PropWitchHuntModule.AudioSaving
// 0x0018 (0x0040 - 0x0028)
class UAudioSaving final : public USaveGame
{
public:
	float                                         MasterVolume;                                      // 0x0028(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SoundVolume;                                       // 0x002C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MusicVolume;                                       // 0x0030(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AmbientVolume;                                     // 0x0034(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UserInterfaceVolume;                               // 0x0038(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VoiceChatVolume;                                   // 0x003C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AudioSaving">();
	}
	static class UAudioSaving* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAudioSaving>();
	}
};
static_assert(alignof(UAudioSaving) == 0x000008, "Wrong alignment on UAudioSaving");
static_assert(sizeof(UAudioSaving) == 0x000040, "Wrong size on UAudioSaving");
static_assert(offsetof(UAudioSaving, MasterVolume) == 0x000028, "Member 'UAudioSaving::MasterVolume' has a wrong offset!");
static_assert(offsetof(UAudioSaving, SoundVolume) == 0x00002C, "Member 'UAudioSaving::SoundVolume' has a wrong offset!");
static_assert(offsetof(UAudioSaving, MusicVolume) == 0x000030, "Member 'UAudioSaving::MusicVolume' has a wrong offset!");
static_assert(offsetof(UAudioSaving, AmbientVolume) == 0x000034, "Member 'UAudioSaving::AmbientVolume' has a wrong offset!");
static_assert(offsetof(UAudioSaving, UserInterfaceVolume) == 0x000038, "Member 'UAudioSaving::UserInterfaceVolume' has a wrong offset!");
static_assert(offsetof(UAudioSaving, VoiceChatVolume) == 0x00003C, "Member 'UAudioSaving::VoiceChatVolume' has a wrong offset!");

// Class PropWitchHuntModule.BaseGameMode
// 0x0008 (0x0388 - 0x0380)
class ABaseGameMode : public AGameMode
{
public:
	uint8                                         Pad_1EC5[0x8];                                     // 0x0380(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseGameMode">();
	}
	static class ABaseGameMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABaseGameMode>();
	}
};
static_assert(alignof(ABaseGameMode) == 0x000008, "Wrong alignment on ABaseGameMode");
static_assert(sizeof(ABaseGameMode) == 0x000388, "Wrong size on ABaseGameMode");

// Class PropWitchHuntModule.BaseManager
// 0x0008 (0x0030 - 0x0028)
class UBaseManager : public UObject
{
public:
	class UGameInstance*                          GameInstance;                                      // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void Initialize(class UGameInstance* InGameInstance);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseManager">();
	}
	static class UBaseManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBaseManager>();
	}
};
static_assert(alignof(UBaseManager) == 0x000008, "Wrong alignment on UBaseManager");
static_assert(sizeof(UBaseManager) == 0x000030, "Wrong size on UBaseManager");
static_assert(offsetof(UBaseManager, GameInstance) == 0x000028, "Member 'UBaseManager::GameInstance' has a wrong offset!");

// Class PropWitchHuntModule.BaseSkill
// 0x0010 (0x00B0 - 0x00A0)
class UBaseSkill : public UActorComponent
{
public:
	ESkillInputType                               InputType;                                         // 0x00A0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseCustomServerActivationEvent;                    // 0x00A1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseCustomServerPressEvent;                         // 0x00A2(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CheckCanActivateOnPress;                           // 0x00A3(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Cooldown;                                          // 0x00A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentCooldown;                                   // 0x00A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SkillIsHold;                                       // 0x00AC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         WantedClientSkillActivations;                      // 0x00AD(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          IgnoreReleaseSinceLastPressFailed;                 // 0x00AE(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1EC6[0x1];                                     // 0x00AF(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ActivateMulti();
	void ActivateServer();
	bool CanActivate();
	void HandleSkillActivated();
	void OnActivateSkillClient();
	void OnActivateSkillMulti();
	void OnActivateSkillServer();
	void OnCasterDie();
	void OnSkillDownMulti();
	void OnSkillPressClient();
	void OnSkillPressServer();
	void OnSkillReleaseClient();
	void OnSkillReleaseServer();
	void OnSkillUpMulti();
	void Press();
	void PressMulti();
	void PressServer();
	void Release();
	void ReleaseMulti();
	void ReleaseServer();
	void SetCurrentCooldown(float NewCooldown);
	void SetCurrentCooldownClient(float NewCooldown);
	void SetCurrentCooldownServer(float NewCooldown);
	void TryActivateClient();
	void TryActivateServer();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseSkill">();
	}
	static class UBaseSkill* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBaseSkill>();
	}
};
static_assert(alignof(UBaseSkill) == 0x000008, "Wrong alignment on UBaseSkill");
static_assert(sizeof(UBaseSkill) == 0x0000B0, "Wrong size on UBaseSkill");
static_assert(offsetof(UBaseSkill, InputType) == 0x0000A0, "Member 'UBaseSkill::InputType' has a wrong offset!");
static_assert(offsetof(UBaseSkill, UseCustomServerActivationEvent) == 0x0000A1, "Member 'UBaseSkill::UseCustomServerActivationEvent' has a wrong offset!");
static_assert(offsetof(UBaseSkill, UseCustomServerPressEvent) == 0x0000A2, "Member 'UBaseSkill::UseCustomServerPressEvent' has a wrong offset!");
static_assert(offsetof(UBaseSkill, CheckCanActivateOnPress) == 0x0000A3, "Member 'UBaseSkill::CheckCanActivateOnPress' has a wrong offset!");
static_assert(offsetof(UBaseSkill, Cooldown) == 0x0000A4, "Member 'UBaseSkill::Cooldown' has a wrong offset!");
static_assert(offsetof(UBaseSkill, CurrentCooldown) == 0x0000A8, "Member 'UBaseSkill::CurrentCooldown' has a wrong offset!");
static_assert(offsetof(UBaseSkill, SkillIsHold) == 0x0000AC, "Member 'UBaseSkill::SkillIsHold' has a wrong offset!");
static_assert(offsetof(UBaseSkill, WantedClientSkillActivations) == 0x0000AD, "Member 'UBaseSkill::WantedClientSkillActivations' has a wrong offset!");
static_assert(offsetof(UBaseSkill, IgnoreReleaseSinceLastPressFailed) == 0x0000AE, "Member 'UBaseSkill::IgnoreReleaseSinceLastPressFailed' has a wrong offset!");

// Class PropWitchHuntModule.BeaconHostManagerActor
// 0x0008 (0x02A0 - 0x0298)
class ABeaconHostManagerActor final : public AActor
{
public:
	uint8                                         Pad_1EC7[0x8];                                     // 0x0298(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class AWitchItBeaconHostObject* GetBeaconHost();
	bool InitializeBeaconHost();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BeaconHostManagerActor">();
	}
	static class ABeaconHostManagerActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABeaconHostManagerActor>();
	}
};
static_assert(alignof(ABeaconHostManagerActor) == 0x000008, "Wrong alignment on ABeaconHostManagerActor");
static_assert(sizeof(ABeaconHostManagerActor) == 0x0002A0, "Wrong size on ABeaconHostManagerActor");

// Class PropWitchHuntModule.BeaconSubsystem
// 0x0070 (0x00A0 - 0x0030)
class UBeaconSubsystem final : public UGameInstanceSubsystem
{
public:
	TArray<class AWitchItBeaconClient*>           BeaconClients;                                     // 0x0030(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TMap<class FString, class AWitchItBeaconClient*> BeaconClientsOnClient;                             // 0x0040(0x0050)(NativeAccessSpecifierPrivate)
	class AOnlineBeaconHost*                      BeaconHost;                                        // 0x0090(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AWitchItBeaconHostObject*               BeaconHostObject;                                  // 0x0098(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	class AWitchItBeaconClient* ConnectToHost(const class FString& HostAddress);
	void DestroyHostingBeacon();
	void DisconnectAllClients();
	void StartHostingBeacon();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BeaconSubsystem">();
	}
	static class UBeaconSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBeaconSubsystem>();
	}
};
static_assert(alignof(UBeaconSubsystem) == 0x000008, "Wrong alignment on UBeaconSubsystem");
static_assert(sizeof(UBeaconSubsystem) == 0x0000A0, "Wrong size on UBeaconSubsystem");
static_assert(offsetof(UBeaconSubsystem, BeaconClients) == 0x000030, "Member 'UBeaconSubsystem::BeaconClients' has a wrong offset!");
static_assert(offsetof(UBeaconSubsystem, BeaconClientsOnClient) == 0x000040, "Member 'UBeaconSubsystem::BeaconClientsOnClient' has a wrong offset!");
static_assert(offsetof(UBeaconSubsystem, BeaconHost) == 0x000090, "Member 'UBeaconSubsystem::BeaconHost' has a wrong offset!");
static_assert(offsetof(UBeaconSubsystem, BeaconHostObject) == 0x000098, "Member 'UBeaconSubsystem::BeaconHostObject' has a wrong offset!");

// Class PropWitchHuntModule.BitmaskLibrary
// 0x0000 (0x0028 - 0x0028)
class UBitmaskLibrary final : public UBlueprintFunctionLibrary
{
public:
	static int32 ClearBit(int32 Value, int32 Pos);
	static bool IsBitSet(int32 Value, int32 Pos);
	static int32 LeftShift(int32 BaseValue, int32 Shift);
	static int32 RightShift(int32 BaseValue, int32 Shift);
	static int32 SetBit(int32 Value, int32 Pos);
	static int32 ToggleBit(int32 Value, int32 Pos);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BitmaskLibrary">();
	}
	static class UBitmaskLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBitmaskLibrary>();
	}
};
static_assert(alignof(UBitmaskLibrary) == 0x000008, "Wrong alignment on UBitmaskLibrary");
static_assert(sizeof(UBitmaskLibrary) == 0x000028, "Wrong size on UBitmaskLibrary");

// Class PropWitchHuntModule.BpAudioSettingsLibrary
// 0x0000 (0x0028 - 0x0028)
class UBpAudioSettingsLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void LoadSoundVolumes(float* Master, float* Sound, float* Music, float* Ambient, float* UserInterface, float* VoiceChat);
	static void SaveSoundVolumes(const float& Master, const float& Sound, const float& Music, const float& Ambient, const float& UserInterface, const float& VoiceChat);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BpAudioSettingsLibrary">();
	}
	static class UBpAudioSettingsLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBpAudioSettingsLibrary>();
	}
};
static_assert(alignof(UBpAudioSettingsLibrary) == 0x000008, "Wrong alignment on UBpAudioSettingsLibrary");
static_assert(sizeof(UBpAudioSettingsLibrary) == 0x000028, "Wrong size on UBpAudioSettingsLibrary");

// Class PropWitchHuntModule.BpInputSettingsLibrary
// 0x0000 (0x0028 - 0x0028)
class UBpInputSettingsLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void AddActionKeyBinding(const struct FInputActionKeyMapping& ActionToAdd);
	static void AddAxisKeyBinding(const struct FInputAxisKeyMapping& AxisToAdd);
	static void ChangeActionKeyBinding(const struct FInputActionKeyMapping& ActionToChange, const struct FKey& NewKey);
	static void ChangeAxisKeyBinding(const struct FInputAxisKeyMapping& AxisToChange, const struct FKey& NewKey);
	static float GetControllerSensivity();
	static struct FKey GetGamepadAcceptKey();
	static struct FKey GetGamepadBackKey();
	static EInputMode GetInputMode(const class APlayerController* PlayerController);
	static void GetKeyBindingsForAction(const class FName& ActionName, TArray<struct FInputActionKeyMapping>* Bindings);
	static void GetKeyBindingsForAxis(const class FName& AxisName, float Scale, TArray<struct FInputAxisKeyMapping>* Bindings);
	static float GetMouseSensivity();
	static void InvertControllerToggle();
	static void InvertMouseToggle();
	static bool IsControllerYInverted();
	static bool IsMouseYInverted();
	static void LoadInputSettings(class APlayerController* PlayerController, const TArray<class FName>& IgnoreAxisConfigs, const TArray<class FName>& IgnoreActionMappings, const TArray<class FName>& IgnoreAxisMappings);
	static void RemoveActionKeyBinding(const struct FInputActionKeyMapping& ActionToRemove);
	static void RemoveAxisKeyBinding(const struct FInputAxisKeyMapping& AxisToRemove);
	static void RestoreDefaultKeyBindings();
	static void SaveInputSettings(class APlayerController* PlayerController);
	static void SetControllerSensivity(float ControllerSensivity);
	static void SetMouseSensivity(float MouseSensivity);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BpInputSettingsLibrary">();
	}
	static class UBpInputSettingsLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBpInputSettingsLibrary>();
	}
};
static_assert(alignof(UBpInputSettingsLibrary) == 0x000008, "Wrong alignment on UBpInputSettingsLibrary");
static_assert(sizeof(UBpInputSettingsLibrary) == 0x000028, "Wrong size on UBpInputSettingsLibrary");

// Class PropWitchHuntModule.BpVideoSettingsLibrary
// 0x0000 (0x0028 - 0x0028)
class UBpVideoSettingsLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void ChangeScreenResolution(const struct FSupportedResolution& Resolution, EWindowMode WindowMode);
	static int32 GetAutoExposureMethod();
	static float GetGamma();
	static bool GetMotionBlur();
	static void GetOverallQualitySettings(EOverallQualityLevel* OverallQualityLevel);
	static void GetScreenResolution(struct FSupportedResolution* Resolution, EWindowMode* WindowMode);
	static bool GetSmoothFramerate();
	static void GetSupportedScreenResolutions(TArray<struct FSupportedResolution>* Resolutions);
	static void GetVideoQualitySettings(int32* AntiAliasing, int32* Effects, int32* PostProcess, int32* Resolution, int32* Shadow, int32* Texture, int32* ViewDistance);
	static bool IsVSyncEnabled();
	static void SaveEngineConfig();
	static void SaveVideoModeAndQuality();
	static void SetAutoExposureMethod(int32 AutoExposureMethod);
	static void SetGamma(float Gamma);
	static void SetMotionBlur(bool MotionBlur);
	static void SetOverallQualitySettings(EOverallQualityLevel OverallQualityLevel);
	static void SetScreenResolution(const struct FSupportedResolution& Resolution, EWindowMode WindowMode);
	static void SetSmoothFramerate(bool SmoothFramerate);
	static void SetVideoQualitySettings(const int32 AntiAliasing, const int32 Effects, const int32 PostProcess, const int32 Resolution, const int32 Shadow, const int32 Texture, const int32 ViewDistance);
	static void SetVSyncEnabled(bool Enabled);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BpVideoSettingsLibrary">();
	}
	static class UBpVideoSettingsLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBpVideoSettingsLibrary>();
	}
};
static_assert(alignof(UBpVideoSettingsLibrary) == 0x000008, "Wrong alignment on UBpVideoSettingsLibrary");
static_assert(sizeof(UBpVideoSettingsLibrary) == 0x000028, "Wrong size on UBpVideoSettingsLibrary");

// Class PropWitchHuntModule.CommandLineFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UCommandLineFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class FString GetValue(const class FString& Key, bool* bFound);
	static bool HasToken(const class FString& Token);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CommandLineFunctionLibrary">();
	}
	static class UCommandLineFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCommandLineFunctionLibrary>();
	}
};
static_assert(alignof(UCommandLineFunctionLibrary) == 0x000008, "Wrong alignment on UCommandLineFunctionLibrary");
static_assert(sizeof(UCommandLineFunctionLibrary) == 0x000028, "Wrong size on UCommandLineFunctionLibrary");

// Class PropWitchHuntModule.CustomLogSubsystem
// 0x0018 (0x0048 - 0x0030)
class UCustomLogSubsystem final : public UEngineSubsystem
{
public:
	uint8                                         Pad_1ED0[0x18];                                    // 0x0030(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddLogTarget(const class FString& Host, int32 Port, const class FString& Tag);
	void Log(const class FText& TextToLog, class FName Category);
	void LogString(const class FString& StringToLog, class FName Category);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomLogSubsystem">();
	}
	static class UCustomLogSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomLogSubsystem>();
	}
};
static_assert(alignof(UCustomLogSubsystem) == 0x000008, "Wrong alignment on UCustomLogSubsystem");
static_assert(sizeof(UCustomLogSubsystem) == 0x000048, "Wrong size on UCustomLogSubsystem");

// Class PropWitchHuntModule.DeserializeItemsCallbackProxy
// 0x0058 (0x0088 - 0x0030)
class UDeserializeItemsCallbackProxy final : public UOnlineBlueprintCallProxyBase
{
public:
	FMulticastInlineDelegateProperty_             OnSuccess;                                         // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnFailure;                                         // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_1ED2[0x38];                                    // 0x0050(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UDeserializeItemsCallbackProxy* DeserializeItems(class UObject* WorldContextObject, class APlayerController* PlayerController, const struct FBlueprintItemSerialization& ItemSerialization);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DeserializeItemsCallbackProxy">();
	}
	static class UDeserializeItemsCallbackProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDeserializeItemsCallbackProxy>();
	}
};
static_assert(alignof(UDeserializeItemsCallbackProxy) == 0x000008, "Wrong alignment on UDeserializeItemsCallbackProxy");
static_assert(sizeof(UDeserializeItemsCallbackProxy) == 0x000088, "Wrong size on UDeserializeItemsCallbackProxy");
static_assert(offsetof(UDeserializeItemsCallbackProxy, OnSuccess) == 0x000030, "Member 'UDeserializeItemsCallbackProxy::OnSuccess' has a wrong offset!");
static_assert(offsetof(UDeserializeItemsCallbackProxy, OnFailure) == 0x000040, "Member 'UDeserializeItemsCallbackProxy::OnFailure' has a wrong offset!");

// Class PropWitchHuntModule.DeveloperModeSubsystem
// 0x0138 (0x0168 - 0x0030)
class UDeveloperModeSubsystem final : public UEngineSubsystem
{
public:
	uint8                                         Pad_1ED3[0xF0];                                    // 0x0030(0x00F0)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsDevModeEnabled;                                 // 0x0120(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1ED4[0x7];                                     // 0x0121(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnDeveloperModeChanged;                            // 0x0128(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnBoolSettingValueChanged;                         // 0x0138(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnStringSettingValueChanged;                       // 0x0148(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnInt32SettingValueChanged;                        // 0x0158(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	bool CouldEnableDeveloperMode();
	void DisableDeveloperMode();
	bool EnableDeveloperMode();
	bool GetBoolSetting(class FName SettingName, bool* bHasValue);
	int32 GetInt32Setting(class FName SettingName, bool* bHasValue);
	class FString GetStringSetting(class FName SettingName, bool* bHasValue);
	bool HasAnySetting(class FName SettingName);
	void SetBoolSetting(class FName SettingName, bool bValue);
	void SetInt32Setting(class FName SettingName, int32 Value);
	void SetStringSetting(class FName SettingName, const class FString& Value);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DeveloperModeSubsystem">();
	}
	static class UDeveloperModeSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDeveloperModeSubsystem>();
	}
};
static_assert(alignof(UDeveloperModeSubsystem) == 0x000008, "Wrong alignment on UDeveloperModeSubsystem");
static_assert(sizeof(UDeveloperModeSubsystem) == 0x000168, "Wrong size on UDeveloperModeSubsystem");
static_assert(offsetof(UDeveloperModeSubsystem, bIsDevModeEnabled) == 0x000120, "Member 'UDeveloperModeSubsystem::bIsDevModeEnabled' has a wrong offset!");
static_assert(offsetof(UDeveloperModeSubsystem, OnDeveloperModeChanged) == 0x000128, "Member 'UDeveloperModeSubsystem::OnDeveloperModeChanged' has a wrong offset!");
static_assert(offsetof(UDeveloperModeSubsystem, OnBoolSettingValueChanged) == 0x000138, "Member 'UDeveloperModeSubsystem::OnBoolSettingValueChanged' has a wrong offset!");
static_assert(offsetof(UDeveloperModeSubsystem, OnStringSettingValueChanged) == 0x000148, "Member 'UDeveloperModeSubsystem::OnStringSettingValueChanged' has a wrong offset!");
static_assert(offsetof(UDeveloperModeSubsystem, OnInt32SettingValueChanged) == 0x000158, "Member 'UDeveloperModeSubsystem::OnInt32SettingValueChanged' has a wrong offset!");

// Class PropWitchHuntModule.DownloadStringCallbackProxy
// 0x0058 (0x0088 - 0x0030)
class UDownloadStringCallbackProxy final : public UOnlineBlueprintCallProxyBase
{
public:
	FMulticastInlineDelegateProperty_             OnSuccess;                                         // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnFailure;                                         // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_1EDA[0x38];                                    // 0x0050(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UDownloadStringCallbackProxy* DownloadString(class UObject* WorldContextObject, const class FString& URL);
	static class UDownloadStringCallbackProxy* UploadString(class UObject* WorldContextObject, const class FString& URL, const class FString& StringToPost);
	static class UDownloadStringCallbackProxy* UploadStringQuery(class UObject* WorldContextObject, const class FString& URL, const class FString& StringToPost, const int32 QueryID);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DownloadStringCallbackProxy">();
	}
	static class UDownloadStringCallbackProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDownloadStringCallbackProxy>();
	}
};
static_assert(alignof(UDownloadStringCallbackProxy) == 0x000008, "Wrong alignment on UDownloadStringCallbackProxy");
static_assert(sizeof(UDownloadStringCallbackProxy) == 0x000088, "Wrong size on UDownloadStringCallbackProxy");
static_assert(offsetof(UDownloadStringCallbackProxy, OnSuccess) == 0x000030, "Member 'UDownloadStringCallbackProxy::OnSuccess' has a wrong offset!");
static_assert(offsetof(UDownloadStringCallbackProxy, OnFailure) == 0x000040, "Member 'UDownloadStringCallbackProxy::OnFailure' has a wrong offset!");

// Class PropWitchHuntModule.FileHelperBlueprint
// 0x0000 (0x0028 - 0x0028)
class UFileHelperBlueprint final : public UBlueprintFunctionLibrary
{
public:
	static class FString GetUnrealPath(EUnrealPath UnrealPath);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FileHelperBlueprint">();
	}
	static class UFileHelperBlueprint* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFileHelperBlueprint>();
	}
};
static_assert(alignof(UFileHelperBlueprint) == 0x000008, "Wrong alignment on UFileHelperBlueprint");
static_assert(sizeof(UFileHelperBlueprint) == 0x000028, "Wrong size on UFileHelperBlueprint");

// Class PropWitchHuntModule.GetAllItemsCallbackProxy
// 0x00A0 (0x00D0 - 0x0030)
class UGetAllItemsCallbackProxy final : public UOnlineBlueprintCallProxyBase
{
public:
	FMulticastInlineDelegateProperty_             OnSuccess;                                         // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnFailure;                                         // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_1EDD[0x80];                                    // 0x0050(0x0080)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UGetAllItemsCallbackProxy* ConsumeItem(class UObject* WorldContextObject, class APlayerController* PlayerController, const struct FBlueprintOnlineItem& ItemToConsume, int32 Quantity);
	static class UGetAllItemsCallbackProxy* ExchangeItems(class UObject* WorldContextObject, class APlayerController* PlayerController, const TArray<int32>& OutDefinitionIds, const TArray<struct FBlueprintOnlineItem>& InItems);
	static class UGetAllItemsCallbackProxy* GenerateItems(class UObject* WorldContextObject, class APlayerController* PlayerController, const TArray<int32>& ItemDefinitionIds);
	static class UGetAllItemsCallbackProxy* GetAllItems(class UObject* WorldContextObject, class APlayerController* PlayerController);
	static int32 GetItemDefinitionId(const struct FBlueprintOnlineItem& Item);
	static int32 GetItemFlags(const struct FBlueprintOnlineItem& Item);
	static class FString GetItemId(const struct FBlueprintOnlineItem& Item);
	static int32 GetItemQuantity(const struct FBlueprintOnlineItem& Item);
	static class UGetAllItemsCallbackProxy* GrantPromoItems(class UObject* WorldContextObject, class APlayerController* PlayerController);
	static void SetItemDefinitionId(struct FBlueprintOnlineItem& Item, int32 DefinitionId);
	static void SetItemFlags(struct FBlueprintOnlineItem& Item, int32 Param_Flags);
	static void SetItemQuantity(struct FBlueprintOnlineItem& Item, int32 Quantity);
	static class UGetAllItemsCallbackProxy* TriggerItemDrop(class UObject* WorldContextObject, class APlayerController* PlayerController, int32 ItemDefinitionId);

	void RequestInventoryResponse(class UVaRestRequestJSON* Request);
	void RequestItemExchangeResponse(class UVaRestRequestJSON* Request);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GetAllItemsCallbackProxy">();
	}
	static class UGetAllItemsCallbackProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGetAllItemsCallbackProxy>();
	}
};
static_assert(alignof(UGetAllItemsCallbackProxy) == 0x000008, "Wrong alignment on UGetAllItemsCallbackProxy");
static_assert(sizeof(UGetAllItemsCallbackProxy) == 0x0000D0, "Wrong size on UGetAllItemsCallbackProxy");
static_assert(offsetof(UGetAllItemsCallbackProxy, OnSuccess) == 0x000030, "Member 'UGetAllItemsCallbackProxy::OnSuccess' has a wrong offset!");
static_assert(offsetof(UGetAllItemsCallbackProxy, OnFailure) == 0x000040, "Member 'UGetAllItemsCallbackProxy::OnFailure' has a wrong offset!");

// Class PropWitchHuntModule.Hunter
// 0x0000 (0x0680 - 0x0680)
class AHunter : public ACharacter
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Hunter">();
	}
	static class AHunter* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHunter>();
	}
};
static_assert(alignof(AHunter) == 0x000010, "Wrong alignment on AHunter");
static_assert(sizeof(AHunter) == 0x000680, "Wrong size on AHunter");

// Class PropWitchHuntModule.ImageLoader
// 0x0010 (0x0038 - 0x0028)
class UImageLoader final : public UObject
{
public:
	uint8                                         Pad_1EE6[0x10];                                    // 0x0028(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UTexture2D* LoadImageFromDisk(class UObject* Param_Outer, const class FString& ImagePath);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ImageLoader">();
	}
	static class UImageLoader* GetDefaultObj()
	{
		return GetDefaultObjImpl<UImageLoader>();
	}
};
static_assert(alignof(UImageLoader) == 0x000008, "Wrong alignment on UImageLoader");
static_assert(sizeof(UImageLoader) == 0x000038, "Wrong size on UImageLoader");

// Class PropWitchHuntModule.InputSaving
// 0x0040 (0x0068 - 0x0028)
class UInputSaving final : public USaveGame
{
public:
	TArray<struct FInputAxisConfigEntry>          AxisConfig;                                        // 0x0028(0x0010)(ZeroConstructor, Config, NativeAccessSpecifierPublic)
	TArray<struct FInputActionKeyMapping>         ActionMappings;                                    // 0x0038(0x0010)(ZeroConstructor, Config, NativeAccessSpecifierPublic)
	TArray<struct FInputAxisKeyMapping>           AxisMappings;                                      // 0x0048(0x0010)(ZeroConstructor, Config, NativeAccessSpecifierPublic)
	TArray<class FName>                           InvertedAxis;                                      // 0x0058(0x0010)(ZeroConstructor, Config, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InputSaving">();
	}
	static class UInputSaving* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInputSaving>();
	}
};
static_assert(alignof(UInputSaving) == 0x000008, "Wrong alignment on UInputSaving");
static_assert(sizeof(UInputSaving) == 0x000068, "Wrong size on UInputSaving");
static_assert(offsetof(UInputSaving, AxisConfig) == 0x000028, "Member 'UInputSaving::AxisConfig' has a wrong offset!");
static_assert(offsetof(UInputSaving, ActionMappings) == 0x000038, "Member 'UInputSaving::ActionMappings' has a wrong offset!");
static_assert(offsetof(UInputSaving, AxisMappings) == 0x000048, "Member 'UInputSaving::AxisMappings' has a wrong offset!");
static_assert(offsetof(UInputSaving, InvertedAxis) == 0x000058, "Member 'UInputSaving::InvertedAxis' has a wrong offset!");

// Class PropWitchHuntModule.Integer64Library
// 0x0000 (0x0028 - 0x0028)
class UInteger64Library final : public UBlueprintFunctionLibrary
{
public:
	static class FString ToString(int64 Value);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Integer64Library">();
	}
	static class UInteger64Library* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInteger64Library>();
	}
};
static_assert(alignof(UInteger64Library) == 0x000008, "Wrong alignment on UInteger64Library");
static_assert(sizeof(UInteger64Library) == 0x000028, "Wrong size on UInteger64Library");

// Class PropWitchHuntModule.Logger
// 0x0000 (0x0028 - 0x0028)
class ULogger final : public UBlueprintFunctionLibrary
{
public:
	static void LogError(const class FString& Text);
	static void LogInfo(const class FString& Text);
	static void LogWarning(const class FString& Text);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Logger">();
	}
	static class ULogger* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULogger>();
	}
};
static_assert(alignof(ULogger) == 0x000008, "Wrong alignment on ULogger");
static_assert(sizeof(ULogger) == 0x000028, "Wrong size on ULogger");

// Class PropWitchHuntModule.MatchParameters
// 0x0008 (0x0030 - 0x0028)
class UMatchParameters : public UObject
{
public:
	class UDataTable*                             UIParameterData;                                   // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchParameters">();
	}
	static class UMatchParameters* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchParameters>();
	}
};
static_assert(alignof(UMatchParameters) == 0x000008, "Wrong alignment on UMatchParameters");
static_assert(sizeof(UMatchParameters) == 0x000030, "Wrong size on UMatchParameters");
static_assert(offsetof(UMatchParameters, UIParameterData) == 0x000028, "Member 'UMatchParameters::UIParameterData' has a wrong offset!");

// Class PropWitchHuntModule.MatchParametersSubsystem
// 0x0000 (0x0030 - 0x0030)
class UMatchParametersSubsystem : public UWorldSubsystem
{
public:
	void InitializeSubsystem();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchParametersSubsystem">();
	}
	static class UMatchParametersSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchParametersSubsystem>();
	}
};
static_assert(alignof(UMatchParametersSubsystem) == 0x000008, "Wrong alignment on UMatchParametersSubsystem");
static_assert(sizeof(UMatchParametersSubsystem) == 0x000030, "Wrong size on UMatchParametersSubsystem");

// Class PropWitchHuntModule.ModParameters
// 0x0048 (0x0070 - 0x0028)
class UModParameters : public UObject
{
public:
	bool                                          IsEnabled;                                         // 0x0028(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1EE7[0x7];                                     // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   Name_ModParameters;                                // 0x0030(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   ToolTip;                                           // 0x0048(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class UTexture2D*                             Icon;                                              // 0x0060(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             UIParameterData;                                   // 0x0068(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ModParameters">();
	}
	static class UModParameters* GetDefaultObj()
	{
		return GetDefaultObjImpl<UModParameters>();
	}
};
static_assert(alignof(UModParameters) == 0x000008, "Wrong alignment on UModParameters");
static_assert(sizeof(UModParameters) == 0x000070, "Wrong size on UModParameters");
static_assert(offsetof(UModParameters, IsEnabled) == 0x000028, "Member 'UModParameters::IsEnabled' has a wrong offset!");
static_assert(offsetof(UModParameters, Name_ModParameters) == 0x000030, "Member 'UModParameters::Name_ModParameters' has a wrong offset!");
static_assert(offsetof(UModParameters, ToolTip) == 0x000048, "Member 'UModParameters::ToolTip' has a wrong offset!");
static_assert(offsetof(UModParameters, Icon) == 0x000060, "Member 'UModParameters::Icon' has a wrong offset!");
static_assert(offsetof(UModParameters, UIParameterData) == 0x000068, "Member 'UModParameters::UIParameterData' has a wrong offset!");

// Class PropWitchHuntModule.ModParametersSubsystem
// 0x0000 (0x0030 - 0x0030)
class UModParametersSubsystem : public UWorldSubsystem
{
public:
	void InitializeSubsystem();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ModParametersSubsystem">();
	}
	static class UModParametersSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UModParametersSubsystem>();
	}
};
static_assert(alignof(UModParametersSubsystem) == 0x000008, "Wrong alignment on UModParametersSubsystem");
static_assert(sizeof(UModParametersSubsystem) == 0x000030, "Wrong size on UModParametersSubsystem");

// Class PropWitchHuntModule.BeaconPingCallbackProxy
// 0x0080 (0x00B0 - 0x0030)
class UBeaconPingCallbackProxy final : public UOnlineBlueprintCallProxyBase
{
public:
	FMulticastInlineDelegateProperty_             OnSuccess;                                         // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnFailure;                                         // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTimeout;                                         // 0x0050(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_1EE8[0x50];                                    // 0x0060(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UBeaconPingCallbackProxy* BeaconPingString(class UObject* WorldContextObject, const class FString& TargetAddress, const class FString& SessionId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BeaconPingCallbackProxy">();
	}
	static class UBeaconPingCallbackProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBeaconPingCallbackProxy>();
	}
};
static_assert(alignof(UBeaconPingCallbackProxy) == 0x000008, "Wrong alignment on UBeaconPingCallbackProxy");
static_assert(sizeof(UBeaconPingCallbackProxy) == 0x0000B0, "Wrong size on UBeaconPingCallbackProxy");
static_assert(offsetof(UBeaconPingCallbackProxy, OnSuccess) == 0x000030, "Member 'UBeaconPingCallbackProxy::OnSuccess' has a wrong offset!");
static_assert(offsetof(UBeaconPingCallbackProxy, OnFailure) == 0x000040, "Member 'UBeaconPingCallbackProxy::OnFailure' has a wrong offset!");
static_assert(offsetof(UBeaconPingCallbackProxy, OnTimeout) == 0x000050, "Member 'UBeaconPingCallbackProxy::OnTimeout' has a wrong offset!");

// Class PropWitchHuntModule.OnlineSubsystemLibrary
// 0x0000 (0x0028 - 0x0028)
class UOnlineSubsystemLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class FString GetBRGPassword(class UObject* WorldContextObject);
	static class FString GetBRGUsername(class UObject* WorldContextObject);
	static bool HasAnyRealOnlineSubsystem();
	static bool IsPlayerBlocked(const struct FBPUniqueNetId& LocalPlayerNetId, const struct FBPUniqueNetId& PlayerNetId);
	static bool UseBRGOnlineSubsystem();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OnlineSubsystemLibrary">();
	}
	static class UOnlineSubsystemLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOnlineSubsystemLibrary>();
	}
};
static_assert(alignof(UOnlineSubsystemLibrary) == 0x000008, "Wrong alignment on UOnlineSubsystemLibrary");
static_assert(sizeof(UOnlineSubsystemLibrary) == 0x000028, "Wrong size on UOnlineSubsystemLibrary");

// Class PropWitchHuntModule.ParametersSubsystem
// 0x0000 (0x0030 - 0x0030)
class UParametersSubsystem : public UWorldSubsystem
{
public:
	void InitializeSubsystem();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParametersSubsystem">();
	}
	static class UParametersSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParametersSubsystem>();
	}
};
static_assert(alignof(UParametersSubsystem) == 0x000008, "Wrong alignment on UParametersSubsystem");
static_assert(sizeof(UParametersSubsystem) == 0x000030, "Wrong size on UParametersSubsystem");

// Class PropWitchHuntModule.PhysicalSoundComponent
// 0x0058 (0x00F8 - 0x00A0)
class UPhysicalSoundComponent : public UActorComponent
{
public:
	TArray<struct FVector>                        LatestVelocities;                                  // 0x00A0(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPrivate)
	double                                        CurrentSlideImpact;                                // 0x00B0(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	double                                        SlideThresholdVelocity;                            // 0x00B8(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	double                                        CollisionThresholdVelocity;                        // 0x00C0(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	double                                        CollisionSoundCooldown;                            // 0x00C8(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          IsCollisionSoundOnCooldown;                        // 0x00D0(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1EEA[0x7];                                     // 0x00D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           CollisionSoundCooldownTimerHandle;                 // 0x00D8(0x0008)(BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAudioComponent*                        CurrentSlideSound;                                 // 0x00E0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              CollisionSound;                                    // 0x00E8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              SlideSound;                                        // 0x00F0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void ClearCooldown();
	struct FVector GetLatestVelocity(int32 TicksToGoBack);
	void OnMeshHit(class AActor* SelfActor, class AActor* OtherActor, const struct FVector& NormalImpulse, const struct FHitResult& Hit);
	void PlayCollisionSound(double VolumeMultiplier);
	double PlaySound(const struct FVector& HitImpactNormal, class AActor* OtherActor);
	bool ShouldCollisionSoundPlay(double DotProduct, double ClampedVelocity);
	bool ShouldSlideSoundPlay(double DotProduct, double ClampedVelocity);
	void StartSlideSound();
	void StopSlideSound(bool bImmediately);
	void StoreVelocity();
	void UpdateSlideSound(double DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PhysicalSoundComponent">();
	}
	static class UPhysicalSoundComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPhysicalSoundComponent>();
	}
};
static_assert(alignof(UPhysicalSoundComponent) == 0x000008, "Wrong alignment on UPhysicalSoundComponent");
static_assert(sizeof(UPhysicalSoundComponent) == 0x0000F8, "Wrong size on UPhysicalSoundComponent");
static_assert(offsetof(UPhysicalSoundComponent, LatestVelocities) == 0x0000A0, "Member 'UPhysicalSoundComponent::LatestVelocities' has a wrong offset!");
static_assert(offsetof(UPhysicalSoundComponent, CurrentSlideImpact) == 0x0000B0, "Member 'UPhysicalSoundComponent::CurrentSlideImpact' has a wrong offset!");
static_assert(offsetof(UPhysicalSoundComponent, SlideThresholdVelocity) == 0x0000B8, "Member 'UPhysicalSoundComponent::SlideThresholdVelocity' has a wrong offset!");
static_assert(offsetof(UPhysicalSoundComponent, CollisionThresholdVelocity) == 0x0000C0, "Member 'UPhysicalSoundComponent::CollisionThresholdVelocity' has a wrong offset!");
static_assert(offsetof(UPhysicalSoundComponent, CollisionSoundCooldown) == 0x0000C8, "Member 'UPhysicalSoundComponent::CollisionSoundCooldown' has a wrong offset!");
static_assert(offsetof(UPhysicalSoundComponent, IsCollisionSoundOnCooldown) == 0x0000D0, "Member 'UPhysicalSoundComponent::IsCollisionSoundOnCooldown' has a wrong offset!");
static_assert(offsetof(UPhysicalSoundComponent, CollisionSoundCooldownTimerHandle) == 0x0000D8, "Member 'UPhysicalSoundComponent::CollisionSoundCooldownTimerHandle' has a wrong offset!");
static_assert(offsetof(UPhysicalSoundComponent, CurrentSlideSound) == 0x0000E0, "Member 'UPhysicalSoundComponent::CurrentSlideSound' has a wrong offset!");
static_assert(offsetof(UPhysicalSoundComponent, CollisionSound) == 0x0000E8, "Member 'UPhysicalSoundComponent::CollisionSound' has a wrong offset!");
static_assert(offsetof(UPhysicalSoundComponent, SlideSound) == 0x0000F0, "Member 'UPhysicalSoundComponent::SlideSound' has a wrong offset!");

// Class PropWitchHuntModule.CallBackProxyPingServer
// 0x0050 (0x0080 - 0x0030)
class UCallBackProxyPingServer final : public UOnlineBlueprintCallProxyBase
{
public:
	FMulticastInlineDelegateProperty_             OnSuccess;                                         // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnFailure;                                         // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTimeout;                                         // 0x0050(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPending;                                         // 0x0060(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_1EEE[0x10];                                    // 0x0070(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UCallBackProxyPingServer* PingServer(const class FString& ServerAddress);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CallBackProxyPingServer">();
	}
	static class UCallBackProxyPingServer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCallBackProxyPingServer>();
	}
};
static_assert(alignof(UCallBackProxyPingServer) == 0x000008, "Wrong alignment on UCallBackProxyPingServer");
static_assert(sizeof(UCallBackProxyPingServer) == 0x000080, "Wrong size on UCallBackProxyPingServer");
static_assert(offsetof(UCallBackProxyPingServer, OnSuccess) == 0x000030, "Member 'UCallBackProxyPingServer::OnSuccess' has a wrong offset!");
static_assert(offsetof(UCallBackProxyPingServer, OnFailure) == 0x000040, "Member 'UCallBackProxyPingServer::OnFailure' has a wrong offset!");
static_assert(offsetof(UCallBackProxyPingServer, OnTimeout) == 0x000050, "Member 'UCallBackProxyPingServer::OnTimeout' has a wrong offset!");
static_assert(offsetof(UCallBackProxyPingServer, OnPending) == 0x000060, "Member 'UCallBackProxyPingServer::OnPending' has a wrong offset!");

// Class PropWitchHuntModule.PingSubsystem
// 0x00B0 (0x00E0 - 0x0030)
class UPingSubsystem final : public UEngineSubsystem
{
public:
	TMap<class FString, struct FPingCacheEntry>   PingResults;                                       // 0x0030(0x0050)(NativeAccessSpecifierPublic)
	TArray<class FString>                         PendingPingResults;                                // 0x0080(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<class FString, float>                    QuickMatchPings;                                   // 0x0090(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)

public:
	void ResetPings();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PingSubsystem">();
	}
	static class UPingSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPingSubsystem>();
	}
};
static_assert(alignof(UPingSubsystem) == 0x000008, "Wrong alignment on UPingSubsystem");
static_assert(sizeof(UPingSubsystem) == 0x0000E0, "Wrong size on UPingSubsystem");
static_assert(offsetof(UPingSubsystem, PingResults) == 0x000030, "Member 'UPingSubsystem::PingResults' has a wrong offset!");
static_assert(offsetof(UPingSubsystem, PendingPingResults) == 0x000080, "Member 'UPingSubsystem::PendingPingResults' has a wrong offset!");
static_assert(offsetof(UPingSubsystem, QuickMatchPings) == 0x000090, "Member 'UPingSubsystem::QuickMatchPings' has a wrong offset!");

// Class PropWitchHuntModule.PowerupParameters
// 0x0050 (0x0078 - 0x0028)
class UPowerupParameters : public UObject
{
public:
	bool                                          IsEnabled;                                         // 0x0028(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1EEF[0x7];                                     // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   Name_PowerupParameters;                            // 0x0030(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          IsHunterPowerup;                                   // 0x0048(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1EF0[0x7];                                     // 0x0049(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   ToolTip;                                           // 0x0050(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class UTexture2D*                             Icon;                                              // 0x0068(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             UIParameterData;                                   // 0x0070(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PowerupParameters">();
	}
	static class UPowerupParameters* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPowerupParameters>();
	}
};
static_assert(alignof(UPowerupParameters) == 0x000008, "Wrong alignment on UPowerupParameters");
static_assert(sizeof(UPowerupParameters) == 0x000078, "Wrong size on UPowerupParameters");
static_assert(offsetof(UPowerupParameters, IsEnabled) == 0x000028, "Member 'UPowerupParameters::IsEnabled' has a wrong offset!");
static_assert(offsetof(UPowerupParameters, Name_PowerupParameters) == 0x000030, "Member 'UPowerupParameters::Name_PowerupParameters' has a wrong offset!");
static_assert(offsetof(UPowerupParameters, IsHunterPowerup) == 0x000048, "Member 'UPowerupParameters::IsHunterPowerup' has a wrong offset!");
static_assert(offsetof(UPowerupParameters, ToolTip) == 0x000050, "Member 'UPowerupParameters::ToolTip' has a wrong offset!");
static_assert(offsetof(UPowerupParameters, Icon) == 0x000068, "Member 'UPowerupParameters::Icon' has a wrong offset!");
static_assert(offsetof(UPowerupParameters, UIParameterData) == 0x000070, "Member 'UPowerupParameters::UIParameterData' has a wrong offset!");

// Class PropWitchHuntModule.PowerupParametersSubsystem
// 0x0000 (0x0030 - 0x0030)
class UPowerupParametersSubsystem : public UWorldSubsystem
{
public:
	void InitializeSubsystem();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PowerupParametersSubsystem">();
	}
	static class UPowerupParametersSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPowerupParametersSubsystem>();
	}
};
static_assert(alignof(UPowerupParametersSubsystem) == 0x000008, "Wrong alignment on UPowerupParametersSubsystem");
static_assert(sizeof(UPowerupParametersSubsystem) == 0x000030, "Wrong size on UPowerupParametersSubsystem");

// Class PropWitchHuntModule.ProjectVersionBlueprint
// 0x0000 (0x0028 - 0x0028)
class UProjectVersionBlueprint final : public UBlueprintFunctionLibrary
{
public:
	static class UActorComponent* AddActorComponent(class AActor* OwnerActor, class UClass* ActorComponentClass);
	static void BanPlayer(class AGameModeBase* GameMode, class APlayerController* BannedPlayer, const class FText& BanReason);
	static bool ClearAchievement(class UGameInstance* GameInstance, const class FName& Param_Name);
	static bool ClearGSAchievement(class UGameInstance* GameInstance, class APlayerState* PlayerState, const class FName& Param_Name);
	static bool ComponentEncroachesGeometry(class AActor* Actor, class UPrimitiveComponent* PrimitiveComponent, const struct FTransform& Transform, const TArray<class AActor*>& IgnoreActors);
	static bool GetAchievement(class UGameInstance* GameInstance, const class FName& Param_Name, bool* Achieved);
	static void GetAllChildBlueprintClasses(TSubclassOf<class UObject> BaseClass, TArray<TSubclassOf<class UObject>>* Subclasses);
	static class FName GetClassFName(class UClass* blueprintClass);
	static class FString GetClassObjectPath(class UClass* blueprintClass);
	static class UObject* GetDefaultObject(TSubclassOf<class UObject> ObjectClass);
	static class FString GetEarliestPurchaseUnixTime(class UGameInstance* GameInstance);
	static int32 GetEngineChangelist();
	static int32 GetEngineCompatibleChangelist();
	static bool GetFiles(TArray<class FString>* Files, const class FString& RootFolderFullPath, const class FString& Ext);
	static class APlayerController* GetFirstLocalPlayerController(class UGameInstance* GameInstance);
	static bool GetGSAchievement(class UGameInstance* GameInstance, class APlayerState* PlayerState, const class FName& Param_Name, bool* Achieved);
	static bool GetGSOnlineStatFloat(class UGameInstance* GameInstance, class APlayerState* PlayerState, const class FName& Param_Name, float* Value);
	static bool GetGSOnlineStatInt(class UGameInstance* GameInstance, class APlayerState* PlayerState, const class FName& Param_Name, int32* Value);
	static class FString GetItemProperty(class UGameInstance* GameInstance, const struct FBlueprintOnlineItem& Item, class FName PropertyName);
	static class FString GetLaunchPath();
	static void GetMemoryStats(float* UsedPhysical, float* PeakUsedPhysical, float* UsedVirtual, float* PeakUsedVirtual, float* AvailablePhysical, float* AvailableVirtual, float* TotalPhysical, float* TotalVirtual);
	static bool GetOnlineStatFloat(class UGameInstance* GameInstance, const class FName& Param_Name, float* Value);
	static bool GetOnlineStatInt(class UGameInstance* GameInstance, const class FName& Param_Name, int32* Value);
	static class FString GetProjectVersion();
	static class FString GetSessionOwnersId(const struct FBlueprintSessionResult& Result);
	static class FString GetUint64SteamIdAsString(class UGameInstance* GameInstance);
	static bool HasSaveGameAnyBytes(const class FString& SlotName, const int32 UserIndex);
	static bool IsConsoleBuild();
	static bool IsEncroachingBlockingGeometry(const class AActor* TestActor, const struct FVector& TestLocation, const struct FRotator& TestRotation);
	static bool IsEncroachingBlockingGeometryWithAdjustment(const class AActor* TestActor, const struct FVector& TestLocation, const struct FRotator& TestRotation, struct FVector* Adjust);
	static bool IsLevelInitializedForActor(class AActor* InActor, class APlayerState* PlayerState);
	static bool IsLinuxBuild();
	static bool IsPendingKill(class UObject* Object);
	static bool IsPS4Build();
	static bool IsSessionDedicatedServer(const struct FBlueprintSessionResult& Result);
	static bool IsSwitchBuild();
	static bool IsWindowsBuild();
	static bool IsXboxBuild();
	static void KickPlayer(class AGameModeBase* GameMode, class APlayerController* KickedPlayer, const class FText& KickReason);
	static class USaveGame* LoadGameFromFile(const class FString& AbsoluteFileName, const int32 UserIndex);
	static bool LoadItemDefinitions(class UGameInstance* GameInstance);
	static bool LoadPropLayoutFromFile(const class FString& AbsoluteFileName, TArray<struct FPropToSave>* PropsToLoad, class FString* WorkshopId, TArray<struct FPlaceableStaticToSave>* PlaceableStaticsToLoad, TArray<struct FPlaceableLightToSave>* PlaceableLightsToLoad, TArray<struct FSwitchToSave>* SwitchesToLoad, TArray<struct FPrefabToSave>* PrefabsToLoad);
	static bool LoadPropLayoutFromFileCompressed(const class FString& AbsoluteFileName, TArray<struct FPropToSave>* PropsToLoad, class FString* WorkshopId, TArray<struct FPlaceableStaticToSave>* PlaceableStaticsToLoad, TArray<struct FPlaceableLightToSave>* PlaceableLightsToLoad, TArray<struct FSwitchToSave>* SwitchesToLoad, TArray<struct FPrefabToSave>* PrefabsToLoad);
	static void PlayReplay(class UGameInstance* GameInstance, const class FString& Param_Name);
	static bool ReadStringFromFile(class FString* Result, const class FString& FullFilePath);
	static void RecordReplay(class UGameInstance* GameInstance, const class FString& Param_Name, const class FString& FriendlyName);
	static bool ResetAllOnlineStats(class UGameInstance* GameInstance, bool AchievementsToo);
	static void ResetNetDriverSettings();
	static bool SaveGameToFile(class USaveGame* SaveGameObject, const class FString& AbsoluteFileName, const int32 UserIndex);
	static bool SavePropLayoutToFile(const class FString& AbsoluteFileName, const TArray<struct FPropToSave>& PropsToSave, const class FString& WorkshopId, const TArray<struct FPlaceableStaticToSave>& PlaceableStaticsToSave, const TArray<struct FPlaceableLightToSave>& PlaceableLightsToSave, const TArray<struct FSwitchToSave>& SwitchesToSave, const TArray<struct FPrefabToSave>& PrefabsToSave);
	static bool SavePropLayoutToFileCompressed(const class FString& AbsoluteFileName, const TArray<struct FPropToSave>& PropsToSave, const class FString& WorkshopId, const TArray<struct FPlaceableStaticToSave>& PlaceableStaticsToSave, const TArray<struct FPlaceableLightToSave>& PlaceableLightsToSave, const TArray<struct FSwitchToSave>& SwitchesToSave, const TArray<struct FPrefabToSave>& PrefabsToSave);
	static void SendItemDropHeartbeat(class UGameInstance* GameInstance);
	static bool SetAchievement(class UGameInstance* GameInstance, const class FName& Param_Name);
	static void SetCCDEnabled(class UPrimitiveComponent* PrimitiveComponent, bool Enabled);
	static bool SetGSAchievement(class UGameInstance* GameInstance, class APlayerState* PlayerState, const class FName& Param_Name);
	static bool SetGSOnlineStatFloat(class UGameInstance* GameInstance, class APlayerState* PlayerState, const class FName& Param_Name, float Value);
	static bool SetGSOnlineStatInt(class UGameInstance* GameInstance, class APlayerState* PlayerState, const class FName& Param_Name, int32 Value);
	static void SetHiddenShadow(class UPrimitiveComponent* PrimitiveComponent, bool Enabled);
	static bool SetOnlineStatFloat(class UGameInstance* GameInstance, const class FName& Param_Name, float Value);
	static bool SetOnlineStatInt(class UGameInstance* GameInstance, const class FName& Param_Name, int32 Value);
	static void SetSelfShadowOnly(class UPrimitiveComponent* PrimitiveComponent, bool Enabled);
	static void SetWorldGravity(class UGameInstance* GameInstance, float Gravity);
	static void Shutdown();
	static class AActor* SpawnActorByWorldContextObject(class UObject* WorldContextObject, class UClass* Param_Class, const struct FTransform& Transform, ESpawnActorCollisionHandlingMethod CollisionHandling);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProjectVersionBlueprint">();
	}
	static class UProjectVersionBlueprint* GetDefaultObj()
	{
		return GetDefaultObjImpl<UProjectVersionBlueprint>();
	}
};
static_assert(alignof(UProjectVersionBlueprint) == 0x000008, "Wrong alignment on UProjectVersionBlueprint");
static_assert(sizeof(UProjectVersionBlueprint) == 0x000028, "Wrong size on UProjectVersionBlueprint");

// Class PropWitchHuntModule.PropPawnPhysics
// 0x0008 (0x0328 - 0x0320)
class APropPawnPhysics : public APawn
{
public:
	uint8                                         Pad_1F15[0x8];                                     // 0x0320(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PropPawnPhysics">();
	}
	static class APropPawnPhysics* GetDefaultObj()
	{
		return GetDefaultObjImpl<APropPawnPhysics>();
	}
};
static_assert(alignof(APropPawnPhysics) == 0x000008, "Wrong alignment on APropPawnPhysics");
static_assert(sizeof(APropPawnPhysics) == 0x000328, "Wrong size on APropPawnPhysics");

// Class PropWitchHuntModule.RealTimeClock
// 0x0000 (0x0028 - 0x0028)
class URealTimeClock final : public UBlueprintFunctionLibrary
{
public:
	static struct FDateTime GetCurrentDateAndTime();
	static struct FTimespan GetCurrentTime();
	static float GetCurrentTimeInHours();
	static float GetCurrentTimeInMilliseconds();
	static float GetCurrentTimeInMinutes();
	static float GetCurrentTimeInSeconds();
	static float GetCurrentTimeInTicks();
	static struct FDateTime GetCurrentUtcDateAndTime(int32 MyTimezone);
	static struct FTimespan GetCurrentUtcTime(int32 MyTimezone);
	static float GetCurrentUtcTimeInSeconds(int32 MyTimezone);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RealTimeClock">();
	}
	static class URealTimeClock* GetDefaultObj()
	{
		return GetDefaultObjImpl<URealTimeClock>();
	}
};
static_assert(alignof(URealTimeClock) == 0x000008, "Wrong alignment on URealTimeClock");
static_assert(sizeof(URealTimeClock) == 0x000028, "Wrong size on URealTimeClock");

// Class PropWitchHuntModule.RequestCurrentStatsCallbackProxy
// 0x0060 (0x0090 - 0x0030)
class URequestCurrentStatsCallbackProxy final : public UOnlineBlueprintCallProxyBase
{
public:
	FMulticastInlineDelegateProperty_             OnSuccess;                                         // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnFailure;                                         // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F18[0x40];                                    // 0x0050(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class URequestCurrentStatsCallbackProxy* RequestCurrentOnlineStats(class UObject* WorldContextObject);
	static class URequestCurrentStatsCallbackProxy* RequestGSOnlineStats(class UObject* WorldContextObject, class APlayerState* PlayerState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RequestCurrentStatsCallbackProxy">();
	}
	static class URequestCurrentStatsCallbackProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<URequestCurrentStatsCallbackProxy>();
	}
};
static_assert(alignof(URequestCurrentStatsCallbackProxy) == 0x000008, "Wrong alignment on URequestCurrentStatsCallbackProxy");
static_assert(sizeof(URequestCurrentStatsCallbackProxy) == 0x000090, "Wrong size on URequestCurrentStatsCallbackProxy");
static_assert(offsetof(URequestCurrentStatsCallbackProxy, OnSuccess) == 0x000030, "Member 'URequestCurrentStatsCallbackProxy::OnSuccess' has a wrong offset!");
static_assert(offsetof(URequestCurrentStatsCallbackProxy, OnFailure) == 0x000040, "Member 'URequestCurrentStatsCallbackProxy::OnFailure' has a wrong offset!");

// Class PropWitchHuntModule.SerializeItemsCallbackProxy
// 0x0058 (0x0088 - 0x0030)
class USerializeItemsCallbackProxy final : public UOnlineBlueprintCallProxyBase
{
public:
	FMulticastInlineDelegateProperty_             OnSuccess;                                         // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnFailure;                                         // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F19[0x38];                                    // 0x0050(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static TArray<uint8> GetSerializationBuffer(const struct FBlueprintItemSerialization& ItemSerialization);
	static class USerializeItemsCallbackProxy* SerializeItems(class UObject* WorldContextObject, class APlayerController* PlayerController, const TArray<struct FBlueprintOnlineItem>& ItemsToSerialize);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SerializeItemsCallbackProxy">();
	}
	static class USerializeItemsCallbackProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<USerializeItemsCallbackProxy>();
	}
};
static_assert(alignof(USerializeItemsCallbackProxy) == 0x000008, "Wrong alignment on USerializeItemsCallbackProxy");
static_assert(sizeof(USerializeItemsCallbackProxy) == 0x000088, "Wrong size on USerializeItemsCallbackProxy");
static_assert(offsetof(USerializeItemsCallbackProxy, OnSuccess) == 0x000030, "Member 'USerializeItemsCallbackProxy::OnSuccess' has a wrong offset!");
static_assert(offsetof(USerializeItemsCallbackProxy, OnFailure) == 0x000040, "Member 'USerializeItemsCallbackProxy::OnFailure' has a wrong offset!");

// Class PropWitchHuntModule.SessionSubsystem
// 0x0000 (0x0030 - 0x0030)
class USessionSubsystem final : public UEngineSubsystem
{
public:
	struct FBlueprintSessionResult GetActiveGameSession(class UObject* WorldContextObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SessionSubsystem">();
	}
	static class USessionSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<USessionSubsystem>();
	}
};
static_assert(alignof(USessionSubsystem) == 0x000008, "Wrong alignment on USessionSubsystem");
static_assert(sizeof(USessionSubsystem) == 0x000030, "Wrong size on USessionSubsystem");

// Class PropWitchHuntModule.SkillParameters
// 0x0030 (0x0058 - 0x0028)
class USkillParameters : public UObject
{
public:
	bool                                          IsListed;                                          // 0x0028(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F1A[0x7];                                     // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   ToolTip;                                           // 0x0030(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class UDataTable*                             UIParameterData;                                   // 0x0048(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UClass*                                 SkillClass;                                        // 0x0050(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	class FText GetFormattedTooltip();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SkillParameters">();
	}
	static class USkillParameters* GetDefaultObj()
	{
		return GetDefaultObjImpl<USkillParameters>();
	}
};
static_assert(alignof(USkillParameters) == 0x000008, "Wrong alignment on USkillParameters");
static_assert(sizeof(USkillParameters) == 0x000058, "Wrong size on USkillParameters");
static_assert(offsetof(USkillParameters, IsListed) == 0x000028, "Member 'USkillParameters::IsListed' has a wrong offset!");
static_assert(offsetof(USkillParameters, ToolTip) == 0x000030, "Member 'USkillParameters::ToolTip' has a wrong offset!");
static_assert(offsetof(USkillParameters, UIParameterData) == 0x000048, "Member 'USkillParameters::UIParameterData' has a wrong offset!");
static_assert(offsetof(USkillParameters, SkillClass) == 0x000050, "Member 'USkillParameters::SkillClass' has a wrong offset!");

// Class PropWitchHuntModule.StartupSubsystem
// 0x0028 (0x0058 - 0x0030)
class UStartupSubsystem final : public UEngineSubsystem
{
public:
	uint8                                         Pad_1F1B[0x18];                                    // 0x0030(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnStartupPhaseCompleted;                           // 0x0048(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void BeginStartupPhase();
	void CompleteStartupPhase(class FName Phase);
	void RegisterStartupPhase(class FName Phase);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StartupSubsystem">();
	}
	static class UStartupSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStartupSubsystem>();
	}
};
static_assert(alignof(UStartupSubsystem) == 0x000008, "Wrong alignment on UStartupSubsystem");
static_assert(sizeof(UStartupSubsystem) == 0x000058, "Wrong size on UStartupSubsystem");
static_assert(offsetof(UStartupSubsystem, OnStartupPhaseCompleted) == 0x000048, "Member 'UStartupSubsystem::OnStartupPhaseCompleted' has a wrong offset!");

// Class PropWitchHuntModule.StaticMeshProp
// 0x00E8 (0x0380 - 0x0298)
class AStaticMeshProp : public AActor
{
public:
	bool                                          IsControlledByWitch;                               // 0x0298(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsSleeping;                                        // 0x0299(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F1C[0x6];                                     // 0x029A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        JumpLockOutTime;                                   // 0x02A0(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CanJump;                                           // 0x02A8(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SelectedForEditing;                                // 0x02A9(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F1D[0x6];                                     // 0x02AA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             TransformAtStart;                                  // 0x02B0(0x0060)(BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             CurrentSleepTransform;                             // 0x0310(0x0060)(BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        ResetCanJumpDelay;                                 // 0x0370(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F1E[0x8];                                     // 0x0378(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CallHandleWake();
	void CheckClientSleep();
	void HandleCanJump(const struct FVector& HitNormal, double Slope);
	void SetActorSubComponentsTickState(bool bTickEnabled);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StaticMeshProp">();
	}
	static class AStaticMeshProp* GetDefaultObj()
	{
		return GetDefaultObjImpl<AStaticMeshProp>();
	}
};
static_assert(alignof(AStaticMeshProp) == 0x000010, "Wrong alignment on AStaticMeshProp");
static_assert(sizeof(AStaticMeshProp) == 0x000380, "Wrong size on AStaticMeshProp");
static_assert(offsetof(AStaticMeshProp, IsControlledByWitch) == 0x000298, "Member 'AStaticMeshProp::IsControlledByWitch' has a wrong offset!");
static_assert(offsetof(AStaticMeshProp, IsSleeping) == 0x000299, "Member 'AStaticMeshProp::IsSleeping' has a wrong offset!");
static_assert(offsetof(AStaticMeshProp, JumpLockOutTime) == 0x0002A0, "Member 'AStaticMeshProp::JumpLockOutTime' has a wrong offset!");
static_assert(offsetof(AStaticMeshProp, CanJump) == 0x0002A8, "Member 'AStaticMeshProp::CanJump' has a wrong offset!");
static_assert(offsetof(AStaticMeshProp, SelectedForEditing) == 0x0002A9, "Member 'AStaticMeshProp::SelectedForEditing' has a wrong offset!");
static_assert(offsetof(AStaticMeshProp, TransformAtStart) == 0x0002B0, "Member 'AStaticMeshProp::TransformAtStart' has a wrong offset!");
static_assert(offsetof(AStaticMeshProp, CurrentSleepTransform) == 0x000310, "Member 'AStaticMeshProp::CurrentSleepTransform' has a wrong offset!");
static_assert(offsetof(AStaticMeshProp, ResetCanJumpDelay) == 0x000370, "Member 'AStaticMeshProp::ResetCanJumpDelay' has a wrong offset!");

// Class PropWitchHuntModule.StoreStatsCallbackProxy
// 0x0058 (0x0088 - 0x0030)
class UStoreStatsCallbackProxy final : public UOnlineBlueprintCallProxyBase
{
public:
	FMulticastInlineDelegateProperty_             OnSuccess;                                         // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnFailure;                                         // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F1F[0x38];                                    // 0x0050(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UStoreStatsCallbackProxy* StoreGSOnlineStats(class UObject* WorldContextObject, class APlayerState* PlayerState);
	static class UStoreStatsCallbackProxy* StoreOnlineStats(class UObject* WorldContextObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StoreStatsCallbackProxy">();
	}
	static class UStoreStatsCallbackProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStoreStatsCallbackProxy>();
	}
};
static_assert(alignof(UStoreStatsCallbackProxy) == 0x000008, "Wrong alignment on UStoreStatsCallbackProxy");
static_assert(sizeof(UStoreStatsCallbackProxy) == 0x000088, "Wrong size on UStoreStatsCallbackProxy");
static_assert(offsetof(UStoreStatsCallbackProxy, OnSuccess) == 0x000030, "Member 'UStoreStatsCallbackProxy::OnSuccess' has a wrong offset!");
static_assert(offsetof(UStoreStatsCallbackProxy, OnFailure) == 0x000040, "Member 'UStoreStatsCallbackProxy::OnFailure' has a wrong offset!");

// Class PropWitchHuntModule.StructDataLibrary
// 0x0000 (0x0028 - 0x0028)
class UStructDataLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void ApplyParameterRules(class UObject* Parameter, const TArray<struct FUIParam>& UIParam);
	static bool AreParametersEqual(class UObject* FirstParameter, class UObject* SecondParameter);
	static struct FUIParam GetParameterValue(class UObject* Parameter, class FName ParameterName);
	static TArray<struct FUIParameterData> GetUIParameters(class UObject* Parameter, class UDataTable* UIData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StructDataLibrary">();
	}
	static class UStructDataLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStructDataLibrary>();
	}
};
static_assert(alignof(UStructDataLibrary) == 0x000008, "Wrong alignment on UStructDataLibrary");
static_assert(sizeof(UStructDataLibrary) == 0x000028, "Wrong size on UStructDataLibrary");

// Class PropWitchHuntModule.TickableBaseManager
// 0x0010 (0x0040 - 0x0030)
class UTickableBaseManager final : public UBaseManager
{
public:
	uint8                                         Pad_1F22[0x8];                                     // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          CallBlueprintTickFunction;                         // 0x0038(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F23[0x7];                                     // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BPTick(float DeltaTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TickableBaseManager">();
	}
	static class UTickableBaseManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTickableBaseManager>();
	}
};
static_assert(alignof(UTickableBaseManager) == 0x000008, "Wrong alignment on UTickableBaseManager");
static_assert(sizeof(UTickableBaseManager) == 0x000040, "Wrong size on UTickableBaseManager");
static_assert(offsetof(UTickableBaseManager, CallBlueprintTickFunction) == 0x000038, "Member 'UTickableBaseManager::CallBlueprintTickFunction' has a wrong offset!");

// Class PropWitchHuntModule.TljhUserControllerSystem
// 0x00F0 (0x0118 - 0x0028)
class UTljhUserControllerSystem : public UObject
{
public:
	uint8                                         Pad_1F24[0x8];                                     // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnNewUserEstablished;                              // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRefreshUser;                                     // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnShowUserReestablishMessage;                      // 0x0050(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnHideUserReestablishMessage;                      // 0x0060(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnActiveUserInfoUpdated;                           // 0x0070(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnInputChanged;                                    // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPushToTalkChanged;                               // 0x0090(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	EUserControllerState                          CurrentState;                                      // 0x00A0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F25[0x7];                                     // 0x00A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UGameInstance*                          GameInstance;                                      // 0x00A8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F26[0x68];                                    // 0x00B0(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ActiveUserInfoUpdatedSignature__DelegateSignature(const struct FSlateBrush& IconBrush, const class FString& DisplayString);
	void EstablishInitialUser();
	void HideUserReestablishMessageSignature__DelegateSignature();
	void Initialize(class UGameInstance* Param_GameInstance);
	void NewUserEstablishedSignature__DelegateSignature();
	void OnInputChangedSignature__DelegateSignature(bool bIsGamepad);
	void OnPushToTalkChangedSignature__DelegateSignature(bool bIsTalking);
	bool OpenAccountPicker_BP();
	void RefreshUserSignature__DelegateSignature();
	void ShowUserReestablishMessageSignature__DelegateSignature(const EEstablishUserReason& EstablishUserReason);

	void GetActiveUserDisplayInfo(bool* Supported, struct FSlateBrush* Icon, class FString* DisplayName) const;
	bool HasEstablishedInitialUser() const;
	bool IsAccountPickerSupported() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TljhUserControllerSystem">();
	}
	static class UTljhUserControllerSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTljhUserControllerSystem>();
	}
};
static_assert(alignof(UTljhUserControllerSystem) == 0x000008, "Wrong alignment on UTljhUserControllerSystem");
static_assert(sizeof(UTljhUserControllerSystem) == 0x000118, "Wrong size on UTljhUserControllerSystem");
static_assert(offsetof(UTljhUserControllerSystem, OnNewUserEstablished) == 0x000030, "Member 'UTljhUserControllerSystem::OnNewUserEstablished' has a wrong offset!");
static_assert(offsetof(UTljhUserControllerSystem, OnRefreshUser) == 0x000040, "Member 'UTljhUserControllerSystem::OnRefreshUser' has a wrong offset!");
static_assert(offsetof(UTljhUserControllerSystem, OnShowUserReestablishMessage) == 0x000050, "Member 'UTljhUserControllerSystem::OnShowUserReestablishMessage' has a wrong offset!");
static_assert(offsetof(UTljhUserControllerSystem, OnHideUserReestablishMessage) == 0x000060, "Member 'UTljhUserControllerSystem::OnHideUserReestablishMessage' has a wrong offset!");
static_assert(offsetof(UTljhUserControllerSystem, OnActiveUserInfoUpdated) == 0x000070, "Member 'UTljhUserControllerSystem::OnActiveUserInfoUpdated' has a wrong offset!");
static_assert(offsetof(UTljhUserControllerSystem, OnInputChanged) == 0x000080, "Member 'UTljhUserControllerSystem::OnInputChanged' has a wrong offset!");
static_assert(offsetof(UTljhUserControllerSystem, OnPushToTalkChanged) == 0x000090, "Member 'UTljhUserControllerSystem::OnPushToTalkChanged' has a wrong offset!");
static_assert(offsetof(UTljhUserControllerSystem, CurrentState) == 0x0000A0, "Member 'UTljhUserControllerSystem::CurrentState' has a wrong offset!");
static_assert(offsetof(UTljhUserControllerSystem, GameInstance) == 0x0000A8, "Member 'UTljhUserControllerSystem::GameInstance' has a wrong offset!");

// Class PropWitchHuntModule.CreateUGCItemCallbackProxy
// 0x0040 (0x0070 - 0x0030)
class UCreateUGCItemCallbackProxy final : public UOnlineBlueprintCallProxyBase
{
public:
	FMulticastInlineDelegateProperty_             OnFinished;                                        // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F28[0x30];                                    // 0x0040(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UCreateUGCItemCallbackProxy* CreateWorkshopItem(class UObject* WorldContextObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CreateUGCItemCallbackProxy">();
	}
	static class UCreateUGCItemCallbackProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCreateUGCItemCallbackProxy>();
	}
};
static_assert(alignof(UCreateUGCItemCallbackProxy) == 0x000008, "Wrong alignment on UCreateUGCItemCallbackProxy");
static_assert(sizeof(UCreateUGCItemCallbackProxy) == 0x000070, "Wrong size on UCreateUGCItemCallbackProxy");
static_assert(offsetof(UCreateUGCItemCallbackProxy, OnFinished) == 0x000030, "Member 'UCreateUGCItemCallbackProxy::OnFinished' has a wrong offset!");

// Class PropWitchHuntModule.UpdateUGCItemCallbackProxy
// 0x0058 (0x0088 - 0x0030)
class UUpdateUGCItemCallbackProxy final : public UOnlineBlueprintCallProxyBase
{
public:
	FMulticastInlineDelegateProperty_             OnFinished;                                        // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F29[0x48];                                    // 0x0040(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UUpdateUGCItemCallbackProxy* UpdateWorkshopItem(class UObject* WorldContextObject, int64 ItemIdToUpdate, const class FString& ChangeNote, const class FString& Title, const class FString& Description, const class FString& Language, const class FString& MetaData, EUGCItemVisibility Visibility, const TArray<class FString>& Tags, const TMap<class FString, class FString>& KeyValueTags, const class FString& ContentFolder, const class FString& PreviewFile);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UpdateUGCItemCallbackProxy">();
	}
	static class UUpdateUGCItemCallbackProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUpdateUGCItemCallbackProxy>();
	}
};
static_assert(alignof(UUpdateUGCItemCallbackProxy) == 0x000008, "Wrong alignment on UUpdateUGCItemCallbackProxy");
static_assert(sizeof(UUpdateUGCItemCallbackProxy) == 0x000088, "Wrong size on UUpdateUGCItemCallbackProxy");
static_assert(offsetof(UUpdateUGCItemCallbackProxy, OnFinished) == 0x000030, "Member 'UUpdateUGCItemCallbackProxy::OnFinished' has a wrong offset!");

// Class PropWitchHuntModule.WindForceComponent
// 0x0038 (0x00D8 - 0x00A0)
class UWindForceComponent : public UActorComponent
{
public:
	uint8                                         Pad_1F2B[0x20];                                    // 0x00A0(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UMeshComponent*                         Mesh;                                              // 0x00C0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        WindStrength;                                      // 0x00C8(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        GravityStrength;                                   // 0x00D0(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void SetMesh(class UMeshComponent* MeshComponent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WindForceComponent">();
	}
	static class UWindForceComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWindForceComponent>();
	}
};
static_assert(alignof(UWindForceComponent) == 0x000008, "Wrong alignment on UWindForceComponent");
static_assert(sizeof(UWindForceComponent) == 0x0000D8, "Wrong size on UWindForceComponent");
static_assert(offsetof(UWindForceComponent, Mesh) == 0x0000C0, "Member 'UWindForceComponent::Mesh' has a wrong offset!");
static_assert(offsetof(UWindForceComponent, WindStrength) == 0x0000C8, "Member 'UWindForceComponent::WindStrength' has a wrong offset!");
static_assert(offsetof(UWindForceComponent, GravityStrength) == 0x0000D0, "Member 'UWindForceComponent::GravityStrength' has a wrong offset!");

// Class PropWitchHuntModule.Witch
// 0x0000 (0x0680 - 0x0680)
class AWitch : public ACharacter
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Witch">();
	}
	static class AWitch* GetDefaultObj()
	{
		return GetDefaultObjImpl<AWitch>();
	}
};
static_assert(alignof(AWitch) == 0x000010, "Wrong alignment on AWitch");
static_assert(sizeof(AWitch) == 0x000680, "Wrong size on AWitch");

// Class PropWitchHuntModule.WitchItBeaconClient
// 0x0040 (0x0368 - 0x0328)
class AWitchItBeaconClient final : public AOnlineBeaconClient
{
public:
	uint8                                         Pad_1F2C[0x40];                                    // 0x0328(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClientPing();
	void ServerPing();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WitchItBeaconClient">();
	}
	static class AWitchItBeaconClient* GetDefaultObj()
	{
		return GetDefaultObjImpl<AWitchItBeaconClient>();
	}
};
static_assert(alignof(AWitchItBeaconClient) == 0x000008, "Wrong alignment on AWitchItBeaconClient");
static_assert(sizeof(AWitchItBeaconClient) == 0x000368, "Wrong size on AWitchItBeaconClient");

// Class PropWitchHuntModule.WitchItBeaconHostObject
// 0x0000 (0x02C0 - 0x02C0)
class AWitchItBeaconHostObject final : public AOnlineBeaconHostObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WitchItBeaconHostObject">();
	}
	static class AWitchItBeaconHostObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<AWitchItBeaconHostObject>();
	}
};
static_assert(alignof(AWitchItBeaconHostObject) == 0x000008, "Wrong alignment on AWitchItBeaconHostObject");
static_assert(sizeof(AWitchItBeaconHostObject) == 0x0002C0, "Wrong size on AWitchItBeaconHostObject");

// Class PropWitchHuntModule.WitchItGameInstance
// 0x00C0 (0x0300 - 0x0240)
class UWitchItGameInstance : public UAdvancedFriendsGameInstance
{
public:
	TMap<struct FUniqueNetIdRepl, class FString>  NativePlatformIdLookup;                            // 0x0240(0x0050)(NativeAccessSpecifierPrivate)
	TMap<struct FUniqueNetIdRepl, class FString>  NativePlatformLookup;                              // 0x0290(0x0050)(NativeAccessSpecifierPrivate)
	bool                                          bIsServerPasswordProtected;                        // 0x02E0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F2D[0x7];                                     // 0x02E1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ServerPassword;                                    // 0x02E8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CurrentOnlineSessionName;                          // 0x02F8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	bool AddPlayerLookupEntry(const struct FUniqueNetIdRepl& UniqueNetId, const class FString& NativePlatformId, const class FString& NativePlatform);
	void OnNetworkFailure(ENetworkFailure FailureType, const class FString& ErrorText, bool IsServer);
	bool RemovePlayerLookupEntry(const struct FUniqueNetIdRepl& UniqueNetId);

	bool GetNativePlatformInfo(const struct FUniqueNetIdRepl& UniqueNetId, class FString* NativePlatformId, class FString* NativePlatform) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WitchItGameInstance">();
	}
	static class UWitchItGameInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWitchItGameInstance>();
	}
};
static_assert(alignof(UWitchItGameInstance) == 0x000008, "Wrong alignment on UWitchItGameInstance");
static_assert(sizeof(UWitchItGameInstance) == 0x000300, "Wrong size on UWitchItGameInstance");
static_assert(offsetof(UWitchItGameInstance, NativePlatformIdLookup) == 0x000240, "Member 'UWitchItGameInstance::NativePlatformIdLookup' has a wrong offset!");
static_assert(offsetof(UWitchItGameInstance, NativePlatformLookup) == 0x000290, "Member 'UWitchItGameInstance::NativePlatformLookup' has a wrong offset!");
static_assert(offsetof(UWitchItGameInstance, bIsServerPasswordProtected) == 0x0002E0, "Member 'UWitchItGameInstance::bIsServerPasswordProtected' has a wrong offset!");
static_assert(offsetof(UWitchItGameInstance, ServerPassword) == 0x0002E8, "Member 'UWitchItGameInstance::ServerPassword' has a wrong offset!");
static_assert(offsetof(UWitchItGameInstance, CurrentOnlineSessionName) == 0x0002F8, "Member 'UWitchItGameInstance::CurrentOnlineSessionName' has a wrong offset!");

// Class PropWitchHuntModule.WitchItGameSession
// 0x0000 (0x02B0 - 0x02B0)
class AWitchItGameSession final : public AGameSession
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WitchItGameSession">();
	}
	static class AWitchItGameSession* GetDefaultObj()
	{
		return GetDefaultObjImpl<AWitchItGameSession>();
	}
};
static_assert(alignof(AWitchItGameSession) == 0x000008, "Wrong alignment on AWitchItGameSession");
static_assert(sizeof(AWitchItGameSession) == 0x0002B0, "Wrong size on AWitchItGameSession");

// Class PropWitchHuntModule.CallbackProxyCreateWorkshopItemBRG
// 0x0100 (0x0130 - 0x0030)
class UCallbackProxyCreateWorkshopItemBRG final : public UOnlineBlueprintCallProxyBase
{
public:
	FMulticastInlineDelegateProperty_             OnSuccess;                                         // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnFailure;                                         // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSteamInitFailure;                                // 0x0050(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F33[0xD0];                                    // 0x0060(0x00D0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UCallbackProxyCreateWorkshopItemBRG* Workshop_CreateItem(const struct FWorkshopUpdateDetails& ItemDetails);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CallbackProxyCreateWorkshopItemBRG">();
	}
	static class UCallbackProxyCreateWorkshopItemBRG* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCallbackProxyCreateWorkshopItemBRG>();
	}
};
static_assert(alignof(UCallbackProxyCreateWorkshopItemBRG) == 0x000008, "Wrong alignment on UCallbackProxyCreateWorkshopItemBRG");
static_assert(sizeof(UCallbackProxyCreateWorkshopItemBRG) == 0x000130, "Wrong size on UCallbackProxyCreateWorkshopItemBRG");
static_assert(offsetof(UCallbackProxyCreateWorkshopItemBRG, OnSuccess) == 0x000030, "Member 'UCallbackProxyCreateWorkshopItemBRG::OnSuccess' has a wrong offset!");
static_assert(offsetof(UCallbackProxyCreateWorkshopItemBRG, OnFailure) == 0x000040, "Member 'UCallbackProxyCreateWorkshopItemBRG::OnFailure' has a wrong offset!");
static_assert(offsetof(UCallbackProxyCreateWorkshopItemBRG, OnSteamInitFailure) == 0x000050, "Member 'UCallbackProxyCreateWorkshopItemBRG::OnSteamInitFailure' has a wrong offset!");

// Class PropWitchHuntModule.CallbackProxyUpdateWorkshopItemBRG
// 0x0118 (0x0148 - 0x0030)
class UCallbackProxyUpdateWorkshopItemBRG final : public UOnlineBlueprintCallProxyBase
{
public:
	FMulticastInlineDelegateProperty_             OnUpdateComplete;                                  // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnFailure;                                         // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSteamInitFailure;                                // 0x0050(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F34[0xE8];                                    // 0x0060(0x00E8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UCallbackProxyUpdateWorkshopItemBRG* Workshop_UpdateItem(const struct FUGCItemId& ItemId, const struct FWorkshopUpdateDetails& UpdateDetails, const TDelegate<void(const struct FUGCUpdateHandle& UpdateHandle)>& OnUpdateStarted);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CallbackProxyUpdateWorkshopItemBRG">();
	}
	static class UCallbackProxyUpdateWorkshopItemBRG* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCallbackProxyUpdateWorkshopItemBRG>();
	}
};
static_assert(alignof(UCallbackProxyUpdateWorkshopItemBRG) == 0x000008, "Wrong alignment on UCallbackProxyUpdateWorkshopItemBRG");
static_assert(sizeof(UCallbackProxyUpdateWorkshopItemBRG) == 0x000148, "Wrong size on UCallbackProxyUpdateWorkshopItemBRG");
static_assert(offsetof(UCallbackProxyUpdateWorkshopItemBRG, OnUpdateComplete) == 0x000030, "Member 'UCallbackProxyUpdateWorkshopItemBRG::OnUpdateComplete' has a wrong offset!");
static_assert(offsetof(UCallbackProxyUpdateWorkshopItemBRG, OnFailure) == 0x000040, "Member 'UCallbackProxyUpdateWorkshopItemBRG::OnFailure' has a wrong offset!");
static_assert(offsetof(UCallbackProxyUpdateWorkshopItemBRG, OnSteamInitFailure) == 0x000050, "Member 'UCallbackProxyUpdateWorkshopItemBRG::OnSteamInitFailure' has a wrong offset!");

// Class PropWitchHuntModule.CallbackProxyQueryWorkshopForItemDetailsBRG
// 0x0068 (0x0098 - 0x0030)
class UCallbackProxyQueryWorkshopForItemDetailsBRG final : public UOnlineBlueprintCallProxyBase
{
public:
	FMulticastInlineDelegateProperty_             OnSuccess;                                         // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnFailure;                                         // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSteamInitFailure;                                // 0x0050(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F35[0x38];                                    // 0x0060(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UCallbackProxyQueryWorkshopForItemDetailsBRG* Workshop_QueryForItemDetails(const struct FUGCQueryParameterDetails& Parameter);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CallbackProxyQueryWorkshopForItemDetailsBRG">();
	}
	static class UCallbackProxyQueryWorkshopForItemDetailsBRG* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCallbackProxyQueryWorkshopForItemDetailsBRG>();
	}
};
static_assert(alignof(UCallbackProxyQueryWorkshopForItemDetailsBRG) == 0x000008, "Wrong alignment on UCallbackProxyQueryWorkshopForItemDetailsBRG");
static_assert(sizeof(UCallbackProxyQueryWorkshopForItemDetailsBRG) == 0x000098, "Wrong size on UCallbackProxyQueryWorkshopForItemDetailsBRG");
static_assert(offsetof(UCallbackProxyQueryWorkshopForItemDetailsBRG, OnSuccess) == 0x000030, "Member 'UCallbackProxyQueryWorkshopForItemDetailsBRG::OnSuccess' has a wrong offset!");
static_assert(offsetof(UCallbackProxyQueryWorkshopForItemDetailsBRG, OnFailure) == 0x000040, "Member 'UCallbackProxyQueryWorkshopForItemDetailsBRG::OnFailure' has a wrong offset!");
static_assert(offsetof(UCallbackProxyQueryWorkshopForItemDetailsBRG, OnSteamInitFailure) == 0x000050, "Member 'UCallbackProxyQueryWorkshopForItemDetailsBRG::OnSteamInitFailure' has a wrong offset!");

// Class PropWitchHuntModule.WorkshopGeneralLibrary
// 0x0000 (0x0028 - 0x0028)
class UWorkshopGeneralLibrary final : public UBlueprintFunctionLibrary
{
public:
	static bool BreakUInt64BRG(const struct FUInt64BRG& InVal, int32* OutVal);
	static struct FUInt64BRG FromString_UInt64BRG(const class FString& Value);
	static class FString ToString_UInt64BRG(const struct FUInt64BRG& Value);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WorkshopGeneralLibrary">();
	}
	static class UWorkshopGeneralLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWorkshopGeneralLibrary>();
	}
};
static_assert(alignof(UWorkshopGeneralLibrary) == 0x000008, "Wrong alignment on UWorkshopGeneralLibrary");
static_assert(sizeof(UWorkshopGeneralLibrary) == 0x000028, "Wrong size on UWorkshopGeneralLibrary");

// Class PropWitchHuntModule.WorkshopLibrary
// 0x0000 (0x0028 - 0x0028)
class UWorkshopLibrary final : public UBlueprintFunctionLibrary
{
public:
	static struct FWorkshopUpdateDetails MakeWorkshopUpdateDetails(const class FString& Title, const class FString& Description, const class FString& UpdateNotice, const class FString& MetaData, const TArray<class FString>& Tags, const TArray<struct FKeyValuePairBRG>& KeyValueTags, const class FString& ContentDirectory, const class FString& PreviewImage, const TArray<class FString>& AdditionalImages, const TArray<class FString>& YoutubeVideoIDs, const TArray<class FString>& KeysOfKeyValueTagsToRemove, const TArray<int32>& IndexOfPreviewToRemove, const ESupportedLanguages UpdateLanguage, const EItemVisibility Visibility);
	static EResultBRGBP Workshop_GetItemInstallInfo(const struct FUGCItemId& ItemId, struct FWorkshopItemInstallInfo* Info);
	static int32 Workshop_GetNumSubscribedItems();
	static void Workshop_GetSubscribedItems(const int32 MaxNumItemsToReturn, TArray<struct FUGCItemId>* OutItems);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WorkshopLibrary">();
	}
	static class UWorkshopLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWorkshopLibrary>();
	}
};
static_assert(alignof(UWorkshopLibrary) == 0x000008, "Wrong alignment on UWorkshopLibrary");
static_assert(sizeof(UWorkshopLibrary) == 0x000028, "Wrong size on UWorkshopLibrary");

}

