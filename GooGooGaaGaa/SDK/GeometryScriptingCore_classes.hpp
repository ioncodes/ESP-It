#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: GeometryScriptingCore

#include "Basic.hpp"

#include "GeometryScriptingCore_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "Engine_classes.hpp"


namespace SDK
{

// Class GeometryScriptingCore.GeometryScriptDebug
// 0x0010 (0x0038 - 0x0028)
class UGeometryScriptDebug final : public UObject
{
public:
	TArray<struct FGeometryScriptDebugMessage>    Messages;                                          // 0x0028(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GeometryScriptDebug">();
	}
	static class UGeometryScriptDebug* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGeometryScriptDebug>();
	}
};
static_assert(alignof(UGeometryScriptDebug) == 0x000008, "Wrong alignment on UGeometryScriptDebug");
static_assert(sizeof(UGeometryScriptDebug) == 0x000038, "Wrong size on UGeometryScriptDebug");
static_assert(offsetof(UGeometryScriptDebug, Messages) == 0x000028, "Member 'UGeometryScriptDebug::Messages' has a wrong offset!");

// Class GeometryScriptingCore.GeometryScriptLibrary_CollisionFunctions
// 0x0000 (0x0028 - 0x0028)
class UGeometryScriptLibrary_CollisionFunctions final : public UBlueprintFunctionLibrary
{
public:
	static void ApproximateConvexHullsWithSimplerCollisionShapes(struct FGeometryScriptSimpleCollision& SimpleCollision, const struct FGeometryScriptConvexHullApproximationOptions& ApproximateOptions, bool* bHasApproximated, class UGeometryScriptDebug* Debug);
	static void CombineSimpleCollision(struct FGeometryScriptSimpleCollision& CollisionToUpdate, const struct FGeometryScriptSimpleCollision& AppendCollision, class UGeometryScriptDebug* Debug);
	static struct FGeometryScriptSphereCovering ComputeNegativeSpace(const struct FGeometryScriptDynamicMeshBVH& MeshBVH, const struct FComputeNegativeSpaceOptions& NegativeSpaceOptions, class UGeometryScriptDebug* Debug);
	static TArray<struct FSphere> Conv_GeometryScriptSphereCoveringToSphereArray(const struct FGeometryScriptSphereCovering& SphereCovering);
	static struct FGeometryScriptSphereCovering Conv_SphereArrayToGeometryScriptSphereCovering(const TArray<struct FSphere>& Spheres);
	static struct FGeometryScriptSimpleCollision GetSimpleCollisionFromComponent(class UPrimitiveComponent* Component, class UGeometryScriptDebug* Debug);
	static struct FGeometryScriptSimpleCollision GetSimpleCollisionFromStaticMesh(class UStaticMesh* StaticMesh, class UGeometryScriptDebug* Debug);
	static int32 GetSimpleCollisionShapeCount(const struct FGeometryScriptSimpleCollision& SimpleCollision);
	static struct FGeometryScriptSimpleCollision MergeSimpleCollisionShapes(const struct FGeometryScriptSimpleCollision& SimpleCollision, const struct FGeometryScriptMergeSimpleCollisionOptions& MergeOptions, bool* bHasMerged, class UGeometryScriptDebug* Debug);
	static void ResetDynamicMeshCollision(class UDynamicMeshComponent* Component, bool bEmitTransaction, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* SetDynamicMeshCollisionFromMesh(class UDynamicMesh* FromDynamicMesh, class UDynamicMeshComponent* ToDynamicMeshComponent, const struct FGeometryScriptCollisionFromMeshOptions& Options, class UGeometryScriptDebug* Debug);
	static void SetSimpleCollisionOfDynamicMeshComponent(const struct FGeometryScriptSimpleCollision& SimpleCollision, class UDynamicMeshComponent* DynamicMeshComponent, const struct FGeometryScriptSetSimpleCollisionOptions& Options, class UGeometryScriptDebug* Debug);
	static void SetSimpleCollisionOfStaticMesh(const struct FGeometryScriptSimpleCollision& SimpleCollision, class UStaticMesh* StaticMesh, const struct FGeometryScriptSetSimpleCollisionOptions& Options, const struct FGeometryScriptSetStaticMeshCollisionOptions& StaticMeshCollisionOptions, class UGeometryScriptDebug* Debug);
	static void SetStaticMeshCollisionFromComponent(class UStaticMesh* StaticMeshAsset, class UPrimitiveComponent* SourceComponent, const struct FGeometryScriptSetSimpleCollisionOptions& Options, const struct FGeometryScriptSetStaticMeshCollisionOptions& StaticMeshCollisionOptions, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* SetStaticMeshCollisionFromMesh(class UDynamicMesh* FromDynamicMesh, class UStaticMesh* ToStaticMeshAsset, const struct FGeometryScriptCollisionFromMeshOptions& Options, const struct FGeometryScriptSetStaticMeshCollisionOptions& StaticMeshCollisionOptions, class UGeometryScriptDebug* Debug);
	static void SimplifyConvexHulls(struct FGeometryScriptSimpleCollision& SimpleCollision, const struct FGeometryScriptConvexHullSimplificationOptions& SimplifyOptions, bool* bHasSimplified, class UGeometryScriptDebug* Debug);
	static bool StaticMeshHasCustomizedCollision(class UStaticMesh* StaticMeshAsset);
	static struct FGeometryScriptSimpleCollision TransformSimpleCollisionShapes(const struct FGeometryScriptSimpleCollision& SimpleCollision, const struct FTransform& Transform, const struct FGeometryScriptTransformCollisionOptions& TransformOptions, bool* bSuccess, class UGeometryScriptDebug* Debug);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GeometryScriptLibrary_CollisionFunctions">();
	}
	static class UGeometryScriptLibrary_CollisionFunctions* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGeometryScriptLibrary_CollisionFunctions>();
	}
};
static_assert(alignof(UGeometryScriptLibrary_CollisionFunctions) == 0x000008, "Wrong alignment on UGeometryScriptLibrary_CollisionFunctions");
static_assert(sizeof(UGeometryScriptLibrary_CollisionFunctions) == 0x000028, "Wrong size on UGeometryScriptLibrary_CollisionFunctions");

// Class GeometryScriptingCore.GeometryScriptLibrary_ContainmentFunctions
// 0x0000 (0x0028 - 0x0028)
class UGeometryScriptLibrary_ContainmentFunctions final : public UBlueprintFunctionLibrary
{
public:
	static class UDynamicMesh* ComputeMeshConvexDecomposition(class UDynamicMesh* TargetMesh, class UDynamicMesh*& CopyToMesh, class UDynamicMesh** CopyToMeshOut, const struct FGeometryScriptConvexDecompositionOptions& Options, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* ComputeMeshConvexHull(class UDynamicMesh* TargetMesh, class UDynamicMesh*& CopyToMesh, class UDynamicMesh** CopyToMeshOut, const struct FGeometryScriptMeshSelection& Selection, const struct FGeometryScriptConvexHullOptions& Options, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* ComputeMeshSweptHull(class UDynamicMesh* TargetMesh, class UDynamicMesh*& CopyToMesh, class UDynamicMesh** CopyToMeshOut, const struct FTransform& ProjectionFrame, const struct FGeometryScriptSweptHullOptions& Options, class UGeometryScriptDebug* Debug);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GeometryScriptLibrary_ContainmentFunctions">();
	}
	static class UGeometryScriptLibrary_ContainmentFunctions* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGeometryScriptLibrary_ContainmentFunctions>();
	}
};
static_assert(alignof(UGeometryScriptLibrary_ContainmentFunctions) == 0x000008, "Wrong alignment on UGeometryScriptLibrary_ContainmentFunctions");
static_assert(sizeof(UGeometryScriptLibrary_ContainmentFunctions) == 0x000028, "Wrong size on UGeometryScriptLibrary_ContainmentFunctions");

// Class GeometryScriptingCore.GeometryScriptLibrary_ListUtilityFunctions
// 0x0000 (0x0028 - 0x0028)
class UGeometryScriptLibrary_ListUtilityFunctions final : public UBlueprintFunctionLibrary
{
public:
	static void ClearColorList(struct FGeometryScriptColorList& ColorList, const struct FLinearColor& ClearColor);
	static void ClearIndexList(struct FGeometryScriptIndexList& IndexList, int32 ClearValue);
	static void ClearScalarList(struct FGeometryScriptScalarList& ScalarList, double ClearValue);
	static void ClearUVList(struct FGeometryScriptUVList& UVList, const struct FVector2D& ClearUV);
	static void ClearVectorList(struct FGeometryScriptVectorList& VectorList, const struct FVector& ClearValue);
	static void ConvertArrayToColorList(const TArray<struct FLinearColor>& ColorArray, struct FGeometryScriptColorList* ColorList);
	static void ConvertArrayToIndexList(const TArray<int32>& IndexArray, struct FGeometryScriptIndexList* IndexList, EGeometryScriptIndexType IndexType);
	static void ConvertArrayToScalarList(const TArray<double>& VectorArray, struct FGeometryScriptScalarList* ScalarList);
	static void ConvertArrayToTriangleList(const TArray<struct FIntVector>& TriangleArray, struct FGeometryScriptTriangleList* TriangleList);
	static void ConvertArrayToUVList(const TArray<struct FVector2D>& UVArray, struct FGeometryScriptUVList* UVList);
	static void ConvertArrayToVectorList(const TArray<struct FVector>& VectorArray, struct FGeometryScriptVectorList* VectorList);
	static void ConvertColorListToArray(const struct FGeometryScriptColorList& ColorList, TArray<struct FLinearColor>* ColorArray);
	static void ConvertIndexListToArray(const struct FGeometryScriptIndexList& IndexList, TArray<int32>* IndexArray);
	static void ConvertScalarListToArray(const struct FGeometryScriptScalarList& ScalarList, TArray<double>* ScalarArray);
	static void ConvertTriangleListToArray(const struct FGeometryScriptTriangleList& TriangleList, TArray<struct FIntVector>* TriangleArray);
	static void ConvertUVListToArray(const struct FGeometryScriptUVList& UVList, TArray<struct FVector2D>* UVArray);
	static void ConvertVectorListToArray(const struct FGeometryScriptVectorList& VectorList, TArray<struct FVector>* VectorArray);
	static void DuplicateColorList(const struct FGeometryScriptColorList& ColorList, struct FGeometryScriptColorList* DuplicateList);
	static void DuplicateIndexList(const struct FGeometryScriptIndexList& IndexList, struct FGeometryScriptIndexList* DuplicateList);
	static void DuplicateScalarList(const struct FGeometryScriptScalarList& ScalarList, struct FGeometryScriptScalarList* DuplicateList);
	static void DuplicateUVList(const struct FGeometryScriptUVList& UVList, struct FGeometryScriptUVList* DuplicateList);
	static void DuplicateVectorList(const struct FGeometryScriptVectorList& VectorList, struct FGeometryScriptVectorList* DuplicateList);
	static void ExtractColorListChannel(const struct FGeometryScriptColorList& ColorList, struct FGeometryScriptScalarList* ScalarList, int32 ChannelIndex);
	static void ExtractColorListChannels(const struct FGeometryScriptColorList& ColorList, struct FGeometryScriptVectorList* VectorList, int32 XChannelIndex, int32 YChannelIndex, int32 ZChannelIndex);
	static struct FLinearColor GetColorListItem(const struct FGeometryScriptColorList& ColorList, int32 Index_0, bool* bIsValidIndex);
	static int32 GetColorListLastIndex(const struct FGeometryScriptColorList& ColorList);
	static int32 GetColorListLength(const struct FGeometryScriptColorList& ColorList);
	static int32 GetIndexListItem(const struct FGeometryScriptIndexList& IndexList, int32 Index_0, bool* bIsValidIndex);
	static int32 GetIndexListLastIndex(const struct FGeometryScriptIndexList& IndexList);
	static int32 GetIndexListLength(const struct FGeometryScriptIndexList& IndexList);
	static double GetScalarListItem(const struct FGeometryScriptScalarList& ScalarList, int32 Index_0, bool* bIsValidIndex);
	static int32 GetScalarListLastIndex(const struct FGeometryScriptScalarList& ScalarList);
	static int32 GetScalarListLength(const struct FGeometryScriptScalarList& ScalarList);
	static struct FIntVector GetTriangleListItem(const struct FGeometryScriptTriangleList& TriangleList, int32 Triangle, bool* bIsValidTriangle);
	static int32 GetTriangleListLastTriangle(const struct FGeometryScriptTriangleList& TriangleList);
	static int32 GetTriangleListLength(const struct FGeometryScriptTriangleList& TriangleList);
	static struct FVector2D GetUVListItem(const struct FGeometryScriptUVList& UVList, int32 Index_0, bool* bIsValidIndex);
	static int32 GetUVListLastIndex(const struct FGeometryScriptUVList& UVList);
	static int32 GetUVListLength(const struct FGeometryScriptUVList& UVList);
	static struct FVector GetVectorListItem(const struct FGeometryScriptVectorList& VectorList, int32 Index_0, bool* bIsValidIndex);
	static int32 GetVectorListLastIndex(const struct FGeometryScriptVectorList& VectorList);
	static int32 GetVectorListLength(const struct FGeometryScriptVectorList& VectorList);
	static void SetColorListItem(struct FGeometryScriptColorList& ColorList, int32 Index_0, const struct FLinearColor& NewColor, bool* bIsValidIndex);
	static void SetIndexListItem(struct FGeometryScriptIndexList& IndexList, int32 Index_0, int32 NewValue, bool* bIsValidIndex);
	static void SetScalarListItem(struct FGeometryScriptScalarList& ScalarList, int32 Index_0, double NewValue, bool* bIsValidIndex);
	static void SetUVListItem(struct FGeometryScriptUVList& UVList, int32 Index_0, const struct FVector2D& NewUV, bool* bIsValidIndex);
	static void SetVectorListItem(struct FGeometryScriptVectorList& VectorList, int32 Index_0, const struct FVector& NewValue, bool* bIsValidIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GeometryScriptLibrary_ListUtilityFunctions">();
	}
	static class UGeometryScriptLibrary_ListUtilityFunctions* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGeometryScriptLibrary_ListUtilityFunctions>();
	}
};
static_assert(alignof(UGeometryScriptLibrary_ListUtilityFunctions) == 0x000008, "Wrong alignment on UGeometryScriptLibrary_ListUtilityFunctions");
static_assert(sizeof(UGeometryScriptLibrary_ListUtilityFunctions) == 0x000028, "Wrong size on UGeometryScriptLibrary_ListUtilityFunctions");

// Class GeometryScriptingCore.GeometryScriptLibrary_StaticMeshFunctions
// 0x0000 (0x0028 - 0x0028)
class UGeometryScriptLibrary_StaticMeshFunctions final : public UBlueprintFunctionLibrary
{
public:
	static bool CheckStaticMeshHasAvailableLOD(class UStaticMesh* StaticMeshAsset, const struct FGeometryScriptMeshReadLOD& RequestedLOD, EGeometryScriptSearchOutcomePins* Outcome, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* CopyMeshFromSkeletalMesh(class USkeletalMesh* FromSkeletalMeshAsset, class UDynamicMesh* ToDynamicMesh, const struct FGeometryScriptCopyMeshFromAssetOptions& AssetOptions, const struct FGeometryScriptMeshReadLOD& RequestedLOD, EGeometryScriptOutcomePins* Outcome, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* CopyMeshFromStaticMesh(class UStaticMesh* FromStaticMeshAsset, class UDynamicMesh* ToDynamicMesh, const struct FGeometryScriptCopyMeshFromAssetOptions& AssetOptions, const struct FGeometryScriptMeshReadLOD& RequestedLOD, EGeometryScriptOutcomePins* Outcome, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* CopyMeshToSkeletalMesh(class UDynamicMesh* FromDynamicMesh, class USkeletalMesh* ToSkeletalMeshAsset, const struct FGeometryScriptCopyMeshToAssetOptions& Options, const struct FGeometryScriptMeshWriteLOD& TargetLod, EGeometryScriptOutcomePins* Outcome, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* CopyMeshToStaticMesh(class UDynamicMesh* FromDynamicMesh, class UStaticMesh* ToStaticMeshAsset, const struct FGeometryScriptCopyMeshToAssetOptions& Options, const struct FGeometryScriptMeshWriteLOD& TargetLod, EGeometryScriptOutcomePins* Outcome, class UGeometryScriptDebug* Debug);
	static int32 GetNumStaticMeshLODsOfType(class UStaticMesh* StaticMeshAsset, EGeometryScriptLODType LODType);
	static void GetSectionMaterialListFromStaticMesh(class UStaticMesh* FromStaticMeshAsset, const struct FGeometryScriptMeshReadLOD& RequestedLOD, TArray<class UMaterialInterface*>* MaterialList, TArray<int32>* MaterialIndex, TArray<class FName>* MaterialSlotNames, EGeometryScriptOutcomePins* Outcome, class UGeometryScriptDebug* Debug);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GeometryScriptLibrary_StaticMeshFunctions">();
	}
	static class UGeometryScriptLibrary_StaticMeshFunctions* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGeometryScriptLibrary_StaticMeshFunctions>();
	}
};
static_assert(alignof(UGeometryScriptLibrary_StaticMeshFunctions) == 0x000008, "Wrong alignment on UGeometryScriptLibrary_StaticMeshFunctions");
static_assert(sizeof(UGeometryScriptLibrary_StaticMeshFunctions) == 0x000028, "Wrong size on UGeometryScriptLibrary_StaticMeshFunctions");

// Class GeometryScriptingCore.GeometryScriptLibrary_MeshBakeFunctions
// 0x0000 (0x0028 - 0x0028)
class UGeometryScriptLibrary_MeshBakeFunctions final : public UBlueprintFunctionLibrary
{
public:
	static TArray<class UTexture2D*> BakeTexture(class UDynamicMesh* TargetMesh, const struct FTransform& TargetTransform, const struct FGeometryScriptBakeTargetMeshOptions& TargetOptions, class UDynamicMesh* SourceMesh, const struct FTransform& SourceTransform, const struct FGeometryScriptBakeSourceMeshOptions& SourceOptions, const TArray<struct FGeometryScriptBakeTypeOptions>& BakeTypes, const struct FGeometryScriptBakeTextureOptions& BakeOptions, class UGeometryScriptDebug* Debug);
	static struct FGeometryScriptRenderCaptureTextures BakeTextureFromRenderCaptures(class UDynamicMesh* TargetMesh, const struct FTransform& TargetLocalToWorld, const struct FGeometryScriptBakeTargetMeshOptions& TargetOptions, const TArray<class AActor*>& SourceActors, const struct FGeometryScriptBakeRenderCaptureOptions& BakeOptions, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* BakeVertex(class UDynamicMesh* TargetMesh, const struct FTransform& TargetTransform, const struct FGeometryScriptBakeTargetMeshOptions& TargetOptions, class UDynamicMesh* SourceMesh, const struct FTransform& SourceTransform, const struct FGeometryScriptBakeSourceMeshOptions& SourceOptions, const struct FGeometryScriptBakeOutputType& BakeTypes, const struct FGeometryScriptBakeVertexOptions& BakeOptions, class UGeometryScriptDebug* Debug);
	static int32 ConvertBakeResolutionToInt(EGeometryScriptBakeResolution BakeResolution);
	static struct FGeometryScriptBakeTypeOptions MakeBakeTypeAmbientOcclusion(int32 OcclusionRays, float MaxDistance, float SpreadAngle, float BiasAngle);
	static struct FGeometryScriptBakeTypeOptions MakeBakeTypeBentNormal(int32 OcclusionRays, float MaxDistance, float SpreadAngle);
	static struct FGeometryScriptBakeTypeOptions MakeBakeTypeConstant(float Value);
	static struct FGeometryScriptBakeTypeOptions MakeBakeTypeCurvature(EGeometryScriptBakeCurvatureTypeMode CurvatureType, EGeometryScriptBakeCurvatureColorMode ColorMapping, float ColorRangeMultiplier, float MinRangeMultiplier, EGeometryScriptBakeCurvatureClampMode Clamping);
	static struct FGeometryScriptBakeTypeOptions MakeBakeTypeFaceNormal();
	static struct FGeometryScriptBakeTypeOptions MakeBakeTypeMaterialID();
	static struct FGeometryScriptBakeTypeOptions MakeBakeTypeMultiTexture(const TArray<class UTexture2D*>& MaterialIDSourceTextures, int32 SourceUVLayer);
	static struct FGeometryScriptBakeTypeOptions MakeBakeTypeObjectNormal();
	static struct FGeometryScriptBakeTypeOptions MakeBakeTypePosition();
	static struct FGeometryScriptBakeTypeOptions MakeBakeTypeTangentNormal();
	static struct FGeometryScriptBakeTypeOptions MakeBakeTypeTexture(class UTexture2D* SourceTexture, int32 SourceUVLayer);
	static struct FGeometryScriptBakeTypeOptions MakeBakeTypeVertexColor();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GeometryScriptLibrary_MeshBakeFunctions">();
	}
	static class UGeometryScriptLibrary_MeshBakeFunctions* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGeometryScriptLibrary_MeshBakeFunctions>();
	}
};
static_assert(alignof(UGeometryScriptLibrary_MeshBakeFunctions) == 0x000008, "Wrong alignment on UGeometryScriptLibrary_MeshBakeFunctions");
static_assert(sizeof(UGeometryScriptLibrary_MeshBakeFunctions) == 0x000028, "Wrong size on UGeometryScriptLibrary_MeshBakeFunctions");

// Class GeometryScriptingCore.GeometryScriptLibrary_MeshBasicEditFunctions
// 0x0000 (0x0028 - 0x0028)
class UGeometryScriptLibrary_MeshBasicEditFunctions final : public UBlueprintFunctionLibrary
{
public:
	static class UDynamicMesh* AddTrianglesToMesh(class UDynamicMesh* TargetMesh, const struct FGeometryScriptTriangleList& NewTrianglesList, struct FGeometryScriptIndexList* NewIndicesList, int32 NewTriangleGroupID, bool bDeferChangeNotifications, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* AddTriangleToMesh(class UDynamicMesh* TargetMesh, const struct FIntVector& NewTriangle, int32* NewTriangleIndex, int32 NewTriangleGroupID, bool bDeferChangeNotifications, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* AddVertexToMesh(class UDynamicMesh* TargetMesh, const struct FVector& NewPosition, int32* NewVertexIndex, bool bDeferChangeNotifications);
	static class UDynamicMesh* AddVerticesToMesh(class UDynamicMesh* TargetMesh, const struct FGeometryScriptVectorList& NewPositionsList, struct FGeometryScriptIndexList* NewIndicesList, bool bDeferChangeNotifications);
	static class UDynamicMesh* AppendBuffersToMesh(class UDynamicMesh* TargetMesh, const struct FGeometryScriptSimpleMeshBuffers& Buffers, struct FGeometryScriptIndexList* NewTriangleIndicesList, int32 MaterialID, bool bDeferChangeNotifications, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* AppendMesh(class UDynamicMesh* TargetMesh, class UDynamicMesh* AppendMesh_0, const struct FTransform& AppendTransform, bool bDeferChangeNotifications, const struct FGeometryScriptAppendMeshOptions& AppendOptions, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* AppendMeshRepeated(class UDynamicMesh* TargetMesh, class UDynamicMesh* AppendMesh, const struct FTransform& AppendTransform, int32 RepeatCount, bool bApplyTransformToFirstInstance, bool bDeferChangeNotifications, const struct FGeometryScriptAppendMeshOptions& AppendOptions, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* AppendMeshTransformed(class UDynamicMesh* TargetMesh, class UDynamicMesh* AppendMesh, const TArray<struct FTransform>& AppendTransforms, const struct FTransform& ConstantTransform, bool bConstantTransformIsRelative, bool bDeferChangeNotifications, const struct FGeometryScriptAppendMeshOptions& AppendOptions, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* DeleteSelectedTrianglesFromMesh(class UDynamicMesh* TargetMesh, const struct FGeometryScriptMeshSelection& Selection, int32* NumDeleted, bool bDeferChangeNotifications);
	static class UDynamicMesh* DeleteTriangleFromMesh(class UDynamicMesh* TargetMesh, int32 TriangleID, bool* bWasTriangleDeleted, bool bDeferChangeNotifications);
	static class UDynamicMesh* DeleteTrianglesFromMesh(class UDynamicMesh* TargetMesh, const struct FGeometryScriptIndexList& TriangleList, int32* NumDeleted, bool bDeferChangeNotifications);
	static class UDynamicMesh* DeleteVertexFromMesh(class UDynamicMesh* TargetMesh, int32 VertexID, bool* bWasVertexDeleted, bool bDeferChangeNotifications);
	static class UDynamicMesh* DeleteVerticesFromMesh(class UDynamicMesh* TargetMesh, const struct FGeometryScriptIndexList& VertexList, int32* NumDeleted, bool bDeferChangeNotifications);
	static class UDynamicMesh* DiscardMeshAttributes(class UDynamicMesh* TargetMesh, bool bDeferChangeNotifications);
	static class UDynamicMesh* SetAllMeshVertexPositions(class UDynamicMesh* TargetMesh, const struct FGeometryScriptVectorList& PositionList, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* SetVertexPosition(class UDynamicMesh* TargetMesh, int32 VertexID, const struct FVector& NewPosition, bool* bIsValidVertex, bool bDeferChangeNotifications);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GeometryScriptLibrary_MeshBasicEditFunctions">();
	}
	static class UGeometryScriptLibrary_MeshBasicEditFunctions* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGeometryScriptLibrary_MeshBasicEditFunctions>();
	}
};
static_assert(alignof(UGeometryScriptLibrary_MeshBasicEditFunctions) == 0x000008, "Wrong alignment on UGeometryScriptLibrary_MeshBasicEditFunctions");
static_assert(sizeof(UGeometryScriptLibrary_MeshBasicEditFunctions) == 0x000028, "Wrong size on UGeometryScriptLibrary_MeshBasicEditFunctions");

// Class GeometryScriptingCore.GeometryScriptLibrary_MeshBoneWeightFunctions
// 0x0000 (0x0028 - 0x0028)
class UGeometryScriptLibrary_MeshBoneWeightFunctions final : public UBlueprintFunctionLibrary
{
public:
	static class UDynamicMesh* ComputeSmoothBoneWeights(class UDynamicMesh* TargetMesh, class USkeleton* Skeleton, const struct FGeometryScriptSmoothBoneWeightsOptions& Options, const struct FGeometryScriptBoneWeightProfile& Profile, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* CopyBonesFromMesh(class UDynamicMesh* SourceMesh, class UDynamicMesh* TargetMesh, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* DiscardBonesFromMesh(class UDynamicMesh* TargetMesh, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* GetAllBonesInfo(class UDynamicMesh* TargetMesh, TArray<struct FGeometryScriptBoneInfo>* BonesInfo, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* GetBoneChildren(class UDynamicMesh* TargetMesh, class FName BoneName, bool bRecursive, bool* bIsValidBoneName, TArray<struct FGeometryScriptBoneInfo>* ChildrenInfo, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* GetBoneIndex(class UDynamicMesh* TargetMesh, class FName BoneName, bool* bIsValidBoneName, int32* BoneIndex, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* GetBoneInfo(class UDynamicMesh* TargetMesh, class FName BoneName, bool* bIsValidBoneName, struct FGeometryScriptBoneInfo* BoneInfo, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* GetLargestVertexBoneWeight(class UDynamicMesh* TargetMesh, int32 VertexID, struct FGeometryScriptBoneWeight* BoneWeight, bool* bHasValidBoneWeights, const struct FGeometryScriptBoneWeightProfile& Profile);
	static class UDynamicMesh* GetMaxBoneWeightIndex(class UDynamicMesh* TargetMesh, bool* bHasBoneWeights, int32* MaxBoneIndex, const struct FGeometryScriptBoneWeightProfile& Profile);
	static class UDynamicMesh* GetRootBoneName(class UDynamicMesh* TargetMesh, class FName* BoneName, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* GetVertexBoneWeights(class UDynamicMesh* TargetMesh, int32 VertexID, TArray<struct FGeometryScriptBoneWeight>* BoneWeights, bool* bHasValidBoneWeights, const struct FGeometryScriptBoneWeightProfile& Profile);
	static class UDynamicMesh* MeshCreateBoneWeights(class UDynamicMesh* TargetMesh, bool* bProfileExisted, bool bReplaceExistingProfile, const struct FGeometryScriptBoneWeightProfile& Profile);
	static class UDynamicMesh* MeshHasBoneWeights(class UDynamicMesh* TargetMesh, bool* bHasBoneWeights, const struct FGeometryScriptBoneWeightProfile& Profile);
	static class UDynamicMesh* SetAllVertexBoneWeights(class UDynamicMesh* TargetMesh, const TArray<struct FGeometryScriptBoneWeight>& BoneWeights, const struct FGeometryScriptBoneWeightProfile& Profile);
	static class UDynamicMesh* SetVertexBoneWeights(class UDynamicMesh* TargetMesh, int32 VertexID, const TArray<struct FGeometryScriptBoneWeight>& BoneWeights, bool* bIsValidVertexID, const struct FGeometryScriptBoneWeightProfile& Profile);
	static class UDynamicMesh* TransferBoneWeightsFromMesh(class UDynamicMesh* SourceMesh, class UDynamicMesh* TargetMesh, const struct FGeometryScriptTransferBoneWeightsOptions& Options, class UGeometryScriptDebug* Debug);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GeometryScriptLibrary_MeshBoneWeightFunctions">();
	}
	static class UGeometryScriptLibrary_MeshBoneWeightFunctions* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGeometryScriptLibrary_MeshBoneWeightFunctions>();
	}
};
static_assert(alignof(UGeometryScriptLibrary_MeshBoneWeightFunctions) == 0x000008, "Wrong alignment on UGeometryScriptLibrary_MeshBoneWeightFunctions");
static_assert(sizeof(UGeometryScriptLibrary_MeshBoneWeightFunctions) == 0x000028, "Wrong size on UGeometryScriptLibrary_MeshBoneWeightFunctions");

// Class GeometryScriptingCore.GeometryScriptLibrary_MeshBooleanFunctions
// 0x0000 (0x0028 - 0x0028)
class UGeometryScriptLibrary_MeshBooleanFunctions final : public UBlueprintFunctionLibrary
{
public:
	static class UDynamicMesh* ApplyMeshBoolean(class UDynamicMesh* TargetMesh, const struct FTransform& TargetTransform, class UDynamicMesh* ToolMesh, const struct FTransform& ToolTransform, EGeometryScriptBooleanOperation Operation, const struct FGeometryScriptMeshBooleanOptions& Options, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* ApplyMeshMirror(class UDynamicMesh* TargetMesh, const struct FTransform& MirrorFrame, const struct FGeometryScriptMeshMirrorOptions& Options, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* ApplyMeshPlaneCut(class UDynamicMesh* TargetMesh, const struct FTransform& CutFrame, const struct FGeometryScriptMeshPlaneCutOptions& Options, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* ApplyMeshPlaneSlice(class UDynamicMesh* TargetMesh, const struct FTransform& CutFrame, const struct FGeometryScriptMeshPlaneSliceOptions& Options, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* ApplyMeshSelfUnion(class UDynamicMesh* TargetMesh, const struct FGeometryScriptMeshSelfUnionOptions& Options, class UGeometryScriptDebug* Debug);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GeometryScriptLibrary_MeshBooleanFunctions">();
	}
	static class UGeometryScriptLibrary_MeshBooleanFunctions* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGeometryScriptLibrary_MeshBooleanFunctions>();
	}
};
static_assert(alignof(UGeometryScriptLibrary_MeshBooleanFunctions) == 0x000008, "Wrong alignment on UGeometryScriptLibrary_MeshBooleanFunctions");
static_assert(sizeof(UGeometryScriptLibrary_MeshBooleanFunctions) == 0x000028, "Wrong size on UGeometryScriptLibrary_MeshBooleanFunctions");

// Class GeometryScriptingCore.GeometryScriptLibrary_MeshComparisonFunctions
// 0x0000 (0x0028 - 0x0028)
class UGeometryScriptLibrary_MeshComparisonFunctions final : public UBlueprintFunctionLibrary
{
public:
	static class UDynamicMesh* IsIntersectingMesh(class UDynamicMesh* TargetMesh, const struct FTransform& TargetTransform, class UDynamicMesh* OtherMesh, const struct FTransform& OtherTransform, bool* bIsIntersecting, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* IsSameMeshAs(class UDynamicMesh* TargetMesh, class UDynamicMesh* OtherMesh, const struct FGeometryScriptIsSameMeshOptions& Options, bool* bIsSameMesh, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* MeasureDistancesBetweenMeshes(class UDynamicMesh* TargetMesh, class UDynamicMesh* OtherMesh, const struct FGeometryScriptMeasureMeshDistanceOptions& Options, double* MaxDistance, double* MinDistance, double* AverageDistance, double* RootMeanSqrDeviation, class UGeometryScriptDebug* Debug);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GeometryScriptLibrary_MeshComparisonFunctions">();
	}
	static class UGeometryScriptLibrary_MeshComparisonFunctions* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGeometryScriptLibrary_MeshComparisonFunctions>();
	}
};
static_assert(alignof(UGeometryScriptLibrary_MeshComparisonFunctions) == 0x000008, "Wrong alignment on UGeometryScriptLibrary_MeshComparisonFunctions");
static_assert(sizeof(UGeometryScriptLibrary_MeshComparisonFunctions) == 0x000028, "Wrong size on UGeometryScriptLibrary_MeshComparisonFunctions");

// Class GeometryScriptingCore.GeometryScriptLibrary_MeshDecompositionFunctions
// 0x0000 (0x0028 - 0x0028)
class UGeometryScriptLibrary_MeshDecompositionFunctions final : public UBlueprintFunctionLibrary
{
public:
	static class UDynamicMesh* CopyMeshSelectionToMesh(class UDynamicMesh* TargetMesh, class UDynamicMesh*& StoreToSubmesh, const struct FGeometryScriptMeshSelection& Selection, class UDynamicMesh** StoreToSubmeshOut, bool bAppendToExisting, bool bPreserveGroupIDs, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* CopyMeshToMesh(class UDynamicMesh* CopyFromMesh, class UDynamicMesh*& CopyToMesh, class UDynamicMesh** CopyToMeshOut, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* GetSubMeshFromMesh(class UDynamicMesh* TargetMesh, class UDynamicMesh*& StoreToSubmesh, const struct FGeometryScriptIndexList& TriangleList, class UDynamicMesh** StoreToSubmeshOut, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* SplitMeshByComponents(class UDynamicMesh* TargetMesh, TArray<class UDynamicMesh*>* ComponentMeshes, class UDynamicMeshPool* MeshPool, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* SplitMeshByMaterialIDs(class UDynamicMesh* TargetMesh, TArray<class UDynamicMesh*>* ComponentMeshes, TArray<int32>* ComponentMaterialIDs, class UDynamicMeshPool* MeshPool, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* SplitMeshByPolygroups(class UDynamicMesh* TargetMesh, const struct FGeometryScriptGroupLayer& GroupLayer, TArray<class UDynamicMesh*>* ComponentMeshes, TArray<int32>* ComponentPolygroups, class UDynamicMeshPool* MeshPool, class UGeometryScriptDebug* Debug);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GeometryScriptLibrary_MeshDecompositionFunctions">();
	}
	static class UGeometryScriptLibrary_MeshDecompositionFunctions* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGeometryScriptLibrary_MeshDecompositionFunctions>();
	}
};
static_assert(alignof(UGeometryScriptLibrary_MeshDecompositionFunctions) == 0x000008, "Wrong alignment on UGeometryScriptLibrary_MeshDecompositionFunctions");
static_assert(sizeof(UGeometryScriptLibrary_MeshDecompositionFunctions) == 0x000028, "Wrong size on UGeometryScriptLibrary_MeshDecompositionFunctions");

// Class GeometryScriptingCore.GeometryScriptLibrary_MeshDeformFunctions
// 0x0000 (0x0028 - 0x0028)
class UGeometryScriptLibrary_MeshDeformFunctions final : public UBlueprintFunctionLibrary
{
public:
	static class UDynamicMesh* ApplyBendWarpToMesh(class UDynamicMesh* TargetMesh, const struct FGeometryScriptBendWarpOptions& Options, const struct FTransform& BendOrientation, float BendAngle, float BendExtent, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* ApplyDisplaceFromPerVertexVectors(class UDynamicMesh* TargetMesh, const struct FGeometryScriptMeshSelection& Selection, const struct FGeometryScriptVectorList& VectorList, float Magnitude, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* ApplyDisplaceFromTextureMap(class UDynamicMesh* TargetMesh, class UTexture2D* Texture, const struct FGeometryScriptMeshSelection& Selection, const struct FGeometryScriptDisplaceFromTextureOptions& Options, int32 UVLayer, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* ApplyFlareWarpToMesh(class UDynamicMesh* TargetMesh, const struct FGeometryScriptFlareWarpOptions& Options, const struct FTransform& FlareOrientation, float FlarePercentX, float FlarePercentY, float FlareExtent, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* ApplyIterativeSmoothingToMesh(class UDynamicMesh* TargetMesh, const struct FGeometryScriptMeshSelection& Selection, const struct FGeometryScriptIterativeMeshSmoothingOptions& Options, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* ApplyMathWarpToMesh(class UDynamicMesh* TargetMesh, const struct FTransform& WarpOrientation, EGeometryScriptMathWarpType WarpType, const struct FGeometryScriptMathWarpOptions& Options, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* ApplyPerlinNoiseToMesh(class UDynamicMesh* TargetMesh, const struct FGeometryScriptMeshSelection& Selection, const struct FGeometryScriptPerlinNoiseOptions& Options, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* ApplyTwistWarpToMesh(class UDynamicMesh* TargetMesh, const struct FGeometryScriptTwistWarpOptions& Options, const struct FTransform& TwistOrientation, float TwistAngle, float TwistExtent, class UGeometryScriptDebug* Debug);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GeometryScriptLibrary_MeshDeformFunctions">();
	}
	static class UGeometryScriptLibrary_MeshDeformFunctions* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGeometryScriptLibrary_MeshDeformFunctions>();
	}
};
static_assert(alignof(UGeometryScriptLibrary_MeshDeformFunctions) == 0x000008, "Wrong alignment on UGeometryScriptLibrary_MeshDeformFunctions");
static_assert(sizeof(UGeometryScriptLibrary_MeshDeformFunctions) == 0x000028, "Wrong size on UGeometryScriptLibrary_MeshDeformFunctions");

// Class GeometryScriptingCore.GeometryScriptLibrary_MeshGeodesicFunctions
// 0x0000 (0x0028 - 0x0028)
class UGeometryScriptLibrary_MeshGeodesicFunctions final : public UBlueprintFunctionLibrary
{
public:
	static class UDynamicMesh* CreateSurfacePath(class UDynamicMesh* TargetMesh, const struct FVector& Direction, int32 StartTriangleID, const struct FVector& StartBaryCoords, float MaxPathLength, struct FGeometryScriptPolyPath* SurfacePath, bool* bFoundErrors, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* GetShortestSurfacePath(class UDynamicMesh* TargetMesh, int32 StartTriangleID, const struct FVector& StartBaryCoords, int32 EndTriangleID, const struct FVector& EndBaryCoords, struct FGeometryScriptPolyPath* ShortestPath, bool* bFoundErrors, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* GetShortestVertexPath(class UDynamicMesh* TargetMesh, int32 StartVertexID, int32 EndVertexID, struct FGeometryScriptIndexList* VertexIDList, bool* bFoundErrors, class UGeometryScriptDebug* Debug);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GeometryScriptLibrary_MeshGeodesicFunctions">();
	}
	static class UGeometryScriptLibrary_MeshGeodesicFunctions* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGeometryScriptLibrary_MeshGeodesicFunctions>();
	}
};
static_assert(alignof(UGeometryScriptLibrary_MeshGeodesicFunctions) == 0x000008, "Wrong alignment on UGeometryScriptLibrary_MeshGeodesicFunctions");
static_assert(sizeof(UGeometryScriptLibrary_MeshGeodesicFunctions) == 0x000028, "Wrong size on UGeometryScriptLibrary_MeshGeodesicFunctions");

// Class GeometryScriptingCore.GeometryScriptLibrary_MeshMaterialFunctions
// 0x0000 (0x0028 - 0x0028)
class UGeometryScriptLibrary_MeshMaterialFunctions final : public UBlueprintFunctionLibrary
{
public:
	static class UDynamicMesh* ClearMaterialIDs(class UDynamicMesh* TargetMesh, int32 ClearValue, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* CompactMaterialIDs(class UDynamicMesh* TargetMesh, const TArray<class UMaterialInterface*>& SourceMaterialList, TArray<class UMaterialInterface*>* CompactedMaterialList, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* DeleteTrianglesByMaterialID(class UDynamicMesh* TargetMesh, int32 MaterialID, int32* NumDeleted, bool bDeferChangeNotifications, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* EnableMaterialIDs(class UDynamicMesh* TargetMesh, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* GetAllTriangleMaterialIDs(class UDynamicMesh* TargetMesh, struct FGeometryScriptIndexList* MaterialIDList, bool* bHasMaterialIDs);
	static class UDynamicMesh* GetMaterialIDsOfTriangles(class UDynamicMesh* TargetMesh, const struct FGeometryScriptIndexList& TriangleIDList, struct FGeometryScriptIndexList* MaterialIDList, class UGeometryScriptDebug* Debug);
	static int32 GetMaxMaterialID(class UDynamicMesh* TargetMesh, bool* bHasMaterialIDs);
	static int32 GetTriangleMaterialID(class UDynamicMesh* TargetMesh, int32 TriangleID, bool* bIsValidTriangle);
	static class UDynamicMesh* GetTrianglesByMaterialID(class UDynamicMesh* TargetMesh, int32 MaterialID, struct FGeometryScriptIndexList* TriangleIDList, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* RemapMaterialIDs(class UDynamicMesh* TargetMesh, int32 FromMaterialID, int32 ToMaterialID, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* RemapToNewMaterialIDsByMaterial(class UDynamicMesh* TargetMesh, const TArray<class UMaterialInterface*>& FromMaterialList, const TArray<class UMaterialInterface*>& ToMaterialList, int32 MissingMaterialID, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* SetAllTriangleMaterialIDs(class UDynamicMesh* TargetMesh, const struct FGeometryScriptIndexList& TriangleMaterialIDList, bool bDeferChangeNotifications, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* SetMaterialIDForMeshSelection(class UDynamicMesh* TargetMesh, const struct FGeometryScriptMeshSelection& Selection, int32 MaterialID, bool bDeferChangeNotifications, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* SetMaterialIDOnTriangles(class UDynamicMesh* TargetMesh, const struct FGeometryScriptIndexList& TriangleIDList, int32 MaterialID, bool bDeferChangeNotifications, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* SetPolygroupMaterialID(class UDynamicMesh* TargetMesh, const struct FGeometryScriptGroupLayer& GroupLayer, int32 PolygroupID, int32 MaterialID, bool* bIsValidPolygroupID, bool bDeferChangeNotifications, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* SetTriangleMaterialID(class UDynamicMesh* TargetMesh, int32 TriangleID, int32 MaterialID, bool* bIsValidTriangle, bool bDeferChangeNotifications);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GeometryScriptLibrary_MeshMaterialFunctions">();
	}
	static class UGeometryScriptLibrary_MeshMaterialFunctions* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGeometryScriptLibrary_MeshMaterialFunctions>();
	}
};
static_assert(alignof(UGeometryScriptLibrary_MeshMaterialFunctions) == 0x000008, "Wrong alignment on UGeometryScriptLibrary_MeshMaterialFunctions");
static_assert(sizeof(UGeometryScriptLibrary_MeshMaterialFunctions) == 0x000028, "Wrong size on UGeometryScriptLibrary_MeshMaterialFunctions");

// Class GeometryScriptingCore.GeometryScriptLibrary_MeshModelingFunctions
// 0x0000 (0x0028 - 0x0028)
class UGeometryScriptLibrary_MeshModelingFunctions final : public UBlueprintFunctionLibrary
{
public:
	static class UDynamicMesh* ApplyMeshBevelSelection(class UDynamicMesh* TargetMesh, const struct FGeometryScriptMeshSelection& Selection, EGeometryScriptMeshBevelSelectionMode BevelMode, const struct FGeometryScriptMeshBevelSelectionOptions& BevelOptions, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* ApplyMeshDisconnectFaces(class UDynamicMesh* TargetMesh, const struct FGeometryScriptMeshSelection& Selection, bool bAllowBowtiesInOutput, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* ApplyMeshDuplicateFaces(class UDynamicMesh* TargetMesh, const struct FGeometryScriptMeshSelection& Selection, struct FGeometryScriptMeshSelection* NewTriangles, const struct FGeometryScriptMeshEditPolygroupOptions& GroupOptions, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* ApplyMeshExtrude_Compatibility_5p0(class UDynamicMesh* TargetMesh, const struct FGeometryScriptMeshExtrudeOptions& Options, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* ApplyMeshInsetOutsetFaces(class UDynamicMesh* TargetMesh, const struct FGeometryScriptMeshInsetOutsetFacesOptions& Options, const struct FGeometryScriptMeshSelection& Selection, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* ApplyMeshLinearExtrudeFaces(class UDynamicMesh* TargetMesh, const struct FGeometryScriptMeshLinearExtrudeOptions& Options, const struct FGeometryScriptMeshSelection& Selection, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* ApplyMeshOffset(class UDynamicMesh* TargetMesh, const struct FGeometryScriptMeshOffsetOptions& Options, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* ApplyMeshOffsetFaces(class UDynamicMesh* TargetMesh, const struct FGeometryScriptMeshOffsetFacesOptions& Options, const struct FGeometryScriptMeshSelection& Selection, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* ApplyMeshPolygroupBevel(class UDynamicMesh* TargetMesh, const struct FGeometryScriptMeshBevelOptions& Options, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* ApplyMeshShell(class UDynamicMesh* TargetMesh, const struct FGeometryScriptMeshOffsetOptions& Options, class UGeometryScriptDebug* Debug);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GeometryScriptLibrary_MeshModelingFunctions">();
	}
	static class UGeometryScriptLibrary_MeshModelingFunctions* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGeometryScriptLibrary_MeshModelingFunctions>();
	}
};
static_assert(alignof(UGeometryScriptLibrary_MeshModelingFunctions) == 0x000008, "Wrong alignment on UGeometryScriptLibrary_MeshModelingFunctions");
static_assert(sizeof(UGeometryScriptLibrary_MeshModelingFunctions) == 0x000028, "Wrong size on UGeometryScriptLibrary_MeshModelingFunctions");

// Class GeometryScriptingCore.GeometryScriptLibrary_MeshNormalsFunctions
// 0x0000 (0x0028 - 0x0028)
class UGeometryScriptLibrary_MeshNormalsFunctions final : public UBlueprintFunctionLibrary
{
public:
	static class UDynamicMesh* AutoRepairNormals(class UDynamicMesh* TargetMesh, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* ComputeSplitNormals(class UDynamicMesh* TargetMesh, const struct FGeometryScriptSplitNormalsOptions& SplitOptions, const struct FGeometryScriptCalculateNormalsOptions& CalculateOptions, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* ComputeTangents(class UDynamicMesh* TargetMesh, const struct FGeometryScriptTangentsOptions& Options, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* DiscardTangents(class UDynamicMesh* TargetMesh, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* FlipNormals(class UDynamicMesh* TargetMesh, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* GetMeshHasTangents(class UDynamicMesh* TargetMesh, bool* bHasTangents, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* GetMeshPerVertexNormals(class UDynamicMesh* TargetMesh, struct FGeometryScriptVectorList* NormalList, bool* bIsValidNormalSet, bool* bHasVertexIDGaps, bool bAverageSplitVertexValues);
	static class UDynamicMesh* GetMeshPerVertexTangents(class UDynamicMesh* TargetMesh, struct FGeometryScriptVectorList* TangentXList, struct FGeometryScriptVectorList* TangentYList, bool* bIsValidTangentSet, bool* bHasVertexIDGaps, bool bAverageSplitVertexValues);
	static class UDynamicMesh* RecomputeNormals(class UDynamicMesh* TargetMesh, const struct FGeometryScriptCalculateNormalsOptions& CalculateOptions, bool bDeferChangeNotifications, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* RecomputeNormalsForMeshSelection(class UDynamicMesh* TargetMesh, const struct FGeometryScriptMeshSelection& Selection, const struct FGeometryScriptCalculateNormalsOptions& CalculateOptions, bool bDeferChangeNotifications, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* SetMeshPerVertexNormals(class UDynamicMesh* TargetMesh, const struct FGeometryScriptVectorList& VertexNormalList, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* SetMeshPerVertexTangents(class UDynamicMesh* TargetMesh, const struct FGeometryScriptVectorList& TangentXList, const struct FGeometryScriptVectorList& TangentYList, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* SetMeshTriangleNormals(class UDynamicMesh* TargetMesh, int32 TriangleID, const struct FGeometryScriptTriangle& Normals, bool* bIsValidTriangle, bool bDeferChangeNotifications);
	static class UDynamicMesh* SetPerFaceNormals(class UDynamicMesh* TargetMesh, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* SetPerVertexNormals(class UDynamicMesh* TargetMesh, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* UpdateVertexNormal(class UDynamicMesh* TargetMesh, int32 VertexID, bool bUpdateNormal, const struct FVector& NewNormal, bool bUpdateTangents, const struct FVector& NewTangentX, const struct FVector& NewTangentY, bool* bIsValidVertex, bool bMergeSplitValues, bool bDeferChangeNotifications);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GeometryScriptLibrary_MeshNormalsFunctions">();
	}
	static class UGeometryScriptLibrary_MeshNormalsFunctions* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGeometryScriptLibrary_MeshNormalsFunctions>();
	}
};
static_assert(alignof(UGeometryScriptLibrary_MeshNormalsFunctions) == 0x000008, "Wrong alignment on UGeometryScriptLibrary_MeshNormalsFunctions");
static_assert(sizeof(UGeometryScriptLibrary_MeshNormalsFunctions) == 0x000028, "Wrong size on UGeometryScriptLibrary_MeshNormalsFunctions");

// Class GeometryScriptingCore.GeometryScriptLibrary_MeshPolygroupFunctions
// 0x0000 (0x0028 - 0x0028)
class UGeometryScriptLibrary_MeshPolygroupFunctions final : public UBlueprintFunctionLibrary
{
public:
	static class UDynamicMesh* ClearPolygroups(class UDynamicMesh* TargetMesh, const struct FGeometryScriptGroupLayer& GroupLayer, int32 ClearValue, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* ComputePolygroupsFromAngleThreshold(class UDynamicMesh* TargetMesh, const struct FGeometryScriptGroupLayer& GroupLayer, float CreaseAngle, int32 MinGroupSize, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* ComputePolygroupsFromPolygonDetection(class UDynamicMesh* TargetMesh, const struct FGeometryScriptGroupLayer& GroupLayer, bool bRespectUVSeams, bool bRespectHardNormals, double QuadAdjacencyWeight, double QuadMetricClamp, int32 MaxSearchRounds, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* ConvertComponentsToPolygroups(class UDynamicMesh* TargetMesh, const struct FGeometryScriptGroupLayer& GroupLayer, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* ConvertUVIslandsToPolygroups(class UDynamicMesh* TargetMesh, const struct FGeometryScriptGroupLayer& GroupLayer, int32 UVLayer, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* CopyPolygroupsLayer(class UDynamicMesh* TargetMesh, const struct FGeometryScriptGroupLayer& FromGroupLayer, const struct FGeometryScriptGroupLayer& ToGroupLayer, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* DeleteTrianglesInPolygroup(class UDynamicMesh* TargetMesh, const struct FGeometryScriptGroupLayer& GroupLayer, int32 PolygroupID, int32* NumDeleted, bool bDeferChangeNotifications, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* EnablePolygroups(class UDynamicMesh* TargetMesh, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* GetAllTrianglePolygroupIDs(class UDynamicMesh* TargetMesh, const struct FGeometryScriptGroupLayer& GroupLayer, struct FGeometryScriptIndexList& PolygroupIDsOut);
	static class UDynamicMesh* GetPolygroupIDsInMesh(class UDynamicMesh* TargetMesh, const struct FGeometryScriptGroupLayer& GroupLayer, struct FGeometryScriptIndexList& PolygroupIDsOut);
	static int32 GetTrianglePolygroupID(class UDynamicMesh* TargetMesh, const struct FGeometryScriptGroupLayer& GroupLayer, int32 TriangleID, bool* bIsValidTriangle);
	static class UDynamicMesh* GetTrianglesInPolygroup(class UDynamicMesh* TargetMesh, const struct FGeometryScriptGroupLayer& GroupLayer, int32 PolygroupID, struct FGeometryScriptIndexList& TriangleIDsOut);
	static class UDynamicMesh* SetNumExtendedPolygroupLayers(class UDynamicMesh* TargetMesh, int32 NumLayers, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* SetPolygroupForMeshSelection(class UDynamicMesh* TargetMesh, const struct FGeometryScriptGroupLayer& GroupLayer, const struct FGeometryScriptMeshSelection& Selection, int32* SetPolygroupIDOut, int32 SetPolygroupID, bool bGenerateNewPolygroup, bool bDeferChangeNotifications);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GeometryScriptLibrary_MeshPolygroupFunctions">();
	}
	static class UGeometryScriptLibrary_MeshPolygroupFunctions* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGeometryScriptLibrary_MeshPolygroupFunctions>();
	}
};
static_assert(alignof(UGeometryScriptLibrary_MeshPolygroupFunctions) == 0x000008, "Wrong alignment on UGeometryScriptLibrary_MeshPolygroupFunctions");
static_assert(sizeof(UGeometryScriptLibrary_MeshPolygroupFunctions) == 0x000028, "Wrong size on UGeometryScriptLibrary_MeshPolygroupFunctions");

// Class GeometryScriptingCore.GeometryScriptLibrary_MeshPrimitiveFunctions
// 0x0000 (0x0028 - 0x0028)
class UGeometryScriptLibrary_MeshPrimitiveFunctions final : public UBlueprintFunctionLibrary
{
public:
	static class UDynamicMesh* AppendBoundingBox(class UDynamicMesh* TargetMesh, const struct FGeometryScriptPrimitiveOptions& PrimitiveOptions, const struct FTransform& Transform, const struct FBox& Box, int32 StepsX, int32 StepsY, int32 StepsZ, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* AppendBox(class UDynamicMesh* TargetMesh, const struct FGeometryScriptPrimitiveOptions& PrimitiveOptions, const struct FTransform& Transform, float DimensionX, float DimensionY, float DimensionZ, int32 StepsX, int32 StepsY, int32 StepsZ, EGeometryScriptPrimitiveOriginMode Origin, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* AppendCapsule(class UDynamicMesh* TargetMesh, const struct FGeometryScriptPrimitiveOptions& PrimitiveOptions, const struct FTransform& Transform, float Radius, float LineLength, int32 HemisphereSteps, int32 CircleSteps, EGeometryScriptPrimitiveOriginMode Origin, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* AppendCone(class UDynamicMesh* TargetMesh, const struct FGeometryScriptPrimitiveOptions& PrimitiveOptions, const struct FTransform& Transform, float BaseRadius, float TopRadius, float Height, int32 RadialSteps, int32 HeightSteps, bool bCapped, EGeometryScriptPrimitiveOriginMode Origin, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* AppendCurvedStairs(class UDynamicMesh* TargetMesh, const struct FGeometryScriptPrimitiveOptions& PrimitiveOptions, const struct FTransform& Transform, float StepWidth, float StepHeight, float InnerRadius, float CurveAngle, int32 NumSteps, bool bFloating, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* AppendCylinder(class UDynamicMesh* TargetMesh, const struct FGeometryScriptPrimitiveOptions& PrimitiveOptions, const struct FTransform& Transform, float Radius, float Height, int32 RadialSteps, int32 HeightSteps, bool bCapped, EGeometryScriptPrimitiveOriginMode Origin, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* AppendDelaunayTriangulation2D(class UDynamicMesh* TargetMesh, const struct FGeometryScriptPrimitiveOptions& PrimitiveOptions, const struct FTransform& Transform, const TArray<struct FVector2D>& VertexPositions, const TArray<struct FIntPoint>& ConstrainedEdges, const struct FGeometryScriptConstrainedDelaunayTriangulationOptions& TriangulationOptions, TArray<int32>* PositionsToVertexIDs, bool* bHasDuplicateVertices, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* AppendDisc(class UDynamicMesh* TargetMesh, const struct FGeometryScriptPrimitiveOptions& PrimitiveOptions, const struct FTransform& Transform, float Radius, int32 AngleSteps, int32 SpokeSteps, float StartAngle, float EndAngle, float HoleRadius, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* AppendLinearStairs(class UDynamicMesh* TargetMesh, const struct FGeometryScriptPrimitiveOptions& PrimitiveOptions, const struct FTransform& Transform, float StepWidth, float StepHeight, float StepDepth, int32 NumSteps, bool bFloating, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* AppendPolygonListTriangulation(class UDynamicMesh* TargetMesh, const struct FGeometryScriptPrimitiveOptions& PrimitiveOptions, const struct FTransform& Transform, const struct FGeometryScriptGeneralPolygonList& PolygonList, const struct FGeometryScriptPolygonsTriangulationOptions& TriangulationOptions, bool* bTriangulationError, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* AppendRectangle_Compatibility_5_0(class UDynamicMesh* TargetMesh, const struct FGeometryScriptPrimitiveOptions& PrimitiveOptions, const struct FTransform& Transform, float DimensionX, float DimensionY, int32 StepsWidth, int32 StepsHeight, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* AppendRectangleXY(class UDynamicMesh* TargetMesh, const struct FGeometryScriptPrimitiveOptions& PrimitiveOptions, const struct FTransform& Transform, float DimensionX, float DimensionY, int32 StepsWidth, int32 StepsHeight, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* AppendRevolvePath(class UDynamicMesh* TargetMesh, const struct FGeometryScriptPrimitiveOptions& PrimitiveOptions, const struct FTransform& Transform, const TArray<struct FVector2D>& PathVertices, const struct FGeometryScriptRevolveOptions& RevolveOptions, int32 Steps, bool bCapped, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* AppendRevolvePolygon(class UDynamicMesh* TargetMesh, const struct FGeometryScriptPrimitiveOptions& PrimitiveOptions, const struct FTransform& Transform, const TArray<struct FVector2D>& PolygonVertices, const struct FGeometryScriptRevolveOptions& RevolveOptions, float Radius, int32 Steps, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* AppendRoundRectangle_Compatibility_5_0(class UDynamicMesh* TargetMesh, const struct FGeometryScriptPrimitiveOptions& PrimitiveOptions, const struct FTransform& Transform, float DimensionX, float DimensionY, float CornerRadius, int32 StepsWidth, int32 StepsHeight, int32 StepsRound, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* AppendRoundRectangleXY(class UDynamicMesh* TargetMesh, const struct FGeometryScriptPrimitiveOptions& PrimitiveOptions, const struct FTransform& Transform, float DimensionX, float DimensionY, float CornerRadius, int32 StepsWidth, int32 StepsHeight, int32 StepsRound, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* AppendSimpleCollisionShapes(class UDynamicMesh* TargetMesh, const struct FGeometryScriptPrimitiveOptions& PrimitiveOptions, const struct FTransform& Transform, const struct FGeometryScriptSimpleCollision& SimpleCollision, const struct FGeometryScriptSimpleCollisionTriangulationOptions& TriangulationOptions, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* AppendSimpleExtrudePolygon(class UDynamicMesh* TargetMesh, const struct FGeometryScriptPrimitiveOptions& PrimitiveOptions, const struct FTransform& Transform, const TArray<struct FVector2D>& PolygonVertices, float Height, int32 HeightSteps, bool bCapped, EGeometryScriptPrimitiveOriginMode Origin, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* AppendSimpleSweptPolygon(class UDynamicMesh* TargetMesh, const struct FGeometryScriptPrimitiveOptions& PrimitiveOptions, const struct FTransform& Transform, const TArray<struct FVector2D>& PolygonVertices, const TArray<struct FVector>& SweepPath, bool bLoop, bool bCapped, float StartScale, float EndScale, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* AppendSphereBox(class UDynamicMesh* TargetMesh, const struct FGeometryScriptPrimitiveOptions& PrimitiveOptions, const struct FTransform& Transform, float Radius, int32 StepsX, int32 StepsY, int32 StepsZ, EGeometryScriptPrimitiveOriginMode Origin, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* AppendSphereCovering(class UDynamicMesh* TargetMesh, const struct FGeometryScriptPrimitiveOptions& PrimitiveOptions, const struct FTransform& Transform, const struct FGeometryScriptSphereCovering& SphereCovering, int32 StepsX, int32 StepsY, int32 StepsZ, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* AppendSphereLatLong(class UDynamicMesh* TargetMesh, const struct FGeometryScriptPrimitiveOptions& PrimitiveOptions, const struct FTransform& Transform, float Radius, int32 StepsPhi, int32 StepsTheta, EGeometryScriptPrimitiveOriginMode Origin, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* AppendSpiralRevolvePolygon(class UDynamicMesh* TargetMesh, const struct FGeometryScriptPrimitiveOptions& PrimitiveOptions, const struct FTransform& Transform, const TArray<struct FVector2D>& PolygonVertices, const struct FGeometryScriptRevolveOptions& RevolveOptions, float Radius, int32 Steps, float RisePerRevolution, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* AppendSweepPolygon(class UDynamicMesh* TargetMesh, const struct FGeometryScriptPrimitiveOptions& PrimitiveOptions, const struct FTransform& Transform, const TArray<struct FVector2D>& PolygonVertices, const TArray<struct FTransform>& SweepPath, bool bLoop, bool bCapped, float StartScale, float EndScale, float RotationAngleDeg, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* AppendSweepPolyline(class UDynamicMesh* TargetMesh, const struct FGeometryScriptPrimitiveOptions& PrimitiveOptions, const struct FTransform& Transform, const TArray<struct FVector2D>& PolylineVertices, const TArray<struct FTransform>& SweepPath, const TArray<float>& PolylineTexParamU, const TArray<float>& SweepPathTexParamV, bool bLoop, float StartScale, float EndScale, float RotationAngleDeg, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* AppendTorus(class UDynamicMesh* TargetMesh, const struct FGeometryScriptPrimitiveOptions& PrimitiveOptions, const struct FTransform& Transform, const struct FGeometryScriptRevolveOptions& RevolveOptions, float MajorRadius, float MinorRadius, int32 MajorSteps, int32 MinorSteps, EGeometryScriptPrimitiveOriginMode Origin, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* AppendTriangulatedPolygon(class UDynamicMesh* TargetMesh, const struct FGeometryScriptPrimitiveOptions& PrimitiveOptions, const struct FTransform& Transform, const TArray<struct FVector2D>& PolygonVertices, bool bAllowSelfIntersections, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* AppendTriangulatedPolygon3D(class UDynamicMesh* TargetMesh, const struct FGeometryScriptPrimitiveOptions& PrimitiveOptions, const struct FTransform& Transform, const TArray<struct FVector>& PolygonVertices3D, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* AppendVoronoiDiagram2D(class UDynamicMesh* TargetMesh, const struct FGeometryScriptPrimitiveOptions& PrimitiveOptions, const struct FTransform& Transform, const TArray<struct FVector2D>& VoronoiSites, const struct FGeometryScriptVoronoiOptions& VoronoiOptions, class UGeometryScriptDebug* Debug);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GeometryScriptLibrary_MeshPrimitiveFunctions">();
	}
	static class UGeometryScriptLibrary_MeshPrimitiveFunctions* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGeometryScriptLibrary_MeshPrimitiveFunctions>();
	}
};
static_assert(alignof(UGeometryScriptLibrary_MeshPrimitiveFunctions) == 0x000008, "Wrong alignment on UGeometryScriptLibrary_MeshPrimitiveFunctions");
static_assert(sizeof(UGeometryScriptLibrary_MeshPrimitiveFunctions) == 0x000028, "Wrong size on UGeometryScriptLibrary_MeshPrimitiveFunctions");

// Class GeometryScriptingCore.GeometryScriptLibrary_MeshQueryFunctions
// 0x0000 (0x0028 - 0x0028)
class UGeometryScriptLibrary_MeshQueryFunctions final : public UBlueprintFunctionLibrary
{
public:
	static class UDynamicMesh* ComputeTriangleBarycentricCoords(class UDynamicMesh* TargetMesh, int32 TriangleID, bool* bIsValidTriangle, const struct FVector& Point, struct FVector* Vertex1, struct FVector* Vertex2, struct FVector* Vertex3, struct FVector* BarycentricCoords);
	static class UDynamicMesh* GetAllSplitUVsAtVertex(class UDynamicMesh* TargetMesh, int32 UvSetIndex, int32 VertexID, TArray<int32>* ElementIDs, TArray<struct FVector2D>* ElementUVs, bool* bHaveValidUVs);
	static class UDynamicMesh* GetAllTriangleIDs(class UDynamicMesh* TargetMesh, struct FGeometryScriptIndexList* TriangleIDList, bool* bHasTriangleIDGaps);
	static class UDynamicMesh* GetAllTriangleIndices(class UDynamicMesh* TargetMesh, struct FGeometryScriptTriangleList* TriangleList, bool bSkipGaps, bool* bHasTriangleIDGaps);
	static class UDynamicMesh* GetAllVertexIDs(class UDynamicMesh* TargetMesh, struct FGeometryScriptIndexList* VertexIDList, bool* bHasVertexIDGaps);
	static class UDynamicMesh* GetAllVertexPositions(class UDynamicMesh* TargetMesh, struct FGeometryScriptVectorList* PositionList, bool bSkipGaps, bool* bHasVertexIDGaps);
	static bool GetHasMaterialIDs(class UDynamicMesh* TargetMesh);
	static bool GetHasPolygroups(class UDynamicMesh* TargetMesh);
	static bool GetHasTriangleIDGaps(class UDynamicMesh* TargetMesh);
	static bool GetHasTriangleNormals(class UDynamicMesh* TargetMesh);
	static bool GetHasVertexColors(class UDynamicMesh* TargetMesh);
	static bool GetHasVertexIDGaps(class UDynamicMesh* TargetMesh);
	static class UDynamicMesh* GetInterpolatedTriangleNormal(class UDynamicMesh* TargetMesh, int32 TriangleID, const struct FVector& BarycentricCoords, bool* bTriHasValidNormals, struct FVector* InterpolatedNormal);
	static class UDynamicMesh* GetInterpolatedTriangleNormalTangents(class UDynamicMesh* TargetMesh, int32 TriangleID, const struct FVector& BarycentricCoords, bool* bTriHasValidElements, struct FVector* InterpolatedNormal, struct FVector* InterpolatedTangent, struct FVector* InterpolatedBiTangent);
	static class UDynamicMesh* GetInterpolatedTrianglePosition(class UDynamicMesh* TargetMesh, int32 TriangleID, const struct FVector& BarycentricCoords, bool* bIsValidTriangle, struct FVector* InterpolatedPosition);
	static class UDynamicMesh* GetInterpolatedTriangleUV(class UDynamicMesh* TargetMesh, int32 UvSetIndex, int32 TriangleID, const struct FVector& BarycentricCoords, bool* bTriHasValidUVs, struct FVector2D* InterpolatedUV);
	static class UDynamicMesh* GetInterpolatedTriangleVertexColor(class UDynamicMesh* TargetMesh, int32 TriangleID, const struct FVector& BarycentricCoords, const struct FLinearColor& DefaultColor, bool* bTriHasValidVertexColors, struct FLinearColor* InterpolatedColor);
	static bool GetIsClosedMesh(class UDynamicMesh* TargetMesh);
	static bool GetIsDenseMesh(class UDynamicMesh* TargetMesh);
	static struct FBox GetMeshBoundingBox(class UDynamicMesh* TargetMesh);
	static bool GetMeshHasAttributeSet(class UDynamicMesh* TargetMesh);
	static class FString GetMeshInfoString(class UDynamicMesh* TargetMesh);
	static void GetMeshVolumeArea(class UDynamicMesh* TargetMesh, float* SurfaceArea, float* Volume);
	static void GetMeshVolumeAreaCenter(class UDynamicMesh* TargetMesh, float* SurfaceArea, float* Volume, struct FVector* CenterOfMass);
	static int32 GetNumConnectedComponents(class UDynamicMesh* TargetMesh);
	static int32 GetNumExtendedPolygroupLayers(class UDynamicMesh* TargetMesh);
	static int32 GetNumOpenBorderEdges(class UDynamicMesh* TargetMesh);
	static int32 GetNumOpenBorderLoops(class UDynamicMesh* TargetMesh, bool* bAmbiguousTopologyFound);
	static int32 GetNumTriangleIDs(class UDynamicMesh* TargetMesh);
	static int32 GetNumUVSets(class UDynamicMesh* TargetMesh);
	static int32 GetNumVertexIDs(class UDynamicMesh* TargetMesh);
	static struct FVector GetTriangleFaceNormal(class UDynamicMesh* TargetMesh, int32 TriangleID, bool* bIsValidTriangle);
	static struct FIntVector GetTriangleIndices(class UDynamicMesh* TargetMesh, int32 TriangleID, bool* bIsValidTriangle);
	static class UDynamicMesh* GetTriangleNormals(class UDynamicMesh* TargetMesh, int32 TriangleID, struct FVector* Normal1, struct FVector* Normal2, struct FVector* Normal3, bool* bTriHasValidNormals);
	static class UDynamicMesh* GetTriangleNormalTangents(class UDynamicMesh* TargetMesh, int32 TriangleID, bool* bTriHasValidElements, struct FGeometryScriptTriangle* Normals, struct FGeometryScriptTriangle* Tangents, struct FGeometryScriptTriangle* BiTangents);
	static void GetTrianglePositions(class UDynamicMesh* TargetMesh, int32 TriangleID, bool* bIsValidTriangle, struct FVector* Vertex1, struct FVector* Vertex2, struct FVector* Vertex3);
	static void GetTriangleUVs(class UDynamicMesh* TargetMesh, int32 UvSetIndex, int32 TriangleID, struct FVector2D* UV1, struct FVector2D* UV2, struct FVector2D* UV3, bool* bHaveValidUVs);
	static class UDynamicMesh* GetTriangleVertexColors(class UDynamicMesh* TargetMesh, int32 TriangleID, struct FLinearColor* Color1, struct FLinearColor* Color2, struct FLinearColor* Color3, bool* bTriHasValidVertexColors);
	static struct FBox2D GetUVSetBoundingBox(class UDynamicMesh* TargetMesh, int32 UvSetIndex, bool* bIsValidUVSet, bool* bUVSetIsEmpty);
	static class UDynamicMesh* GetVertexConnectedTriangles(class UDynamicMesh* TargetMesh, int32 VertexID, TArray<int32>* Triangles);
	static class UDynamicMesh* GetVertexConnectedVertices(class UDynamicMesh* TargetMesh, int32 VertexID, TArray<int32>* Vertices);
	static int32 GetVertexCount(class UDynamicMesh* TargetMesh);
	static struct FVector GetVertexPosition(class UDynamicMesh* TargetMesh, int32 VertexID, bool* bIsValidVertex);
	static bool IsValidTriangleID(class UDynamicMesh* TargetMesh, int32 TriangleID);
	static bool IsValidVertexID(class UDynamicMesh* TargetMesh, int32 VertexID);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GeometryScriptLibrary_MeshQueryFunctions">();
	}
	static class UGeometryScriptLibrary_MeshQueryFunctions* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGeometryScriptLibrary_MeshQueryFunctions>();
	}
};
static_assert(alignof(UGeometryScriptLibrary_MeshQueryFunctions) == 0x000008, "Wrong alignment on UGeometryScriptLibrary_MeshQueryFunctions");
static_assert(sizeof(UGeometryScriptLibrary_MeshQueryFunctions) == 0x000028, "Wrong size on UGeometryScriptLibrary_MeshQueryFunctions");

// Class GeometryScriptingCore.GeometryScriptLibrary_RemeshingFunctions
// 0x0000 (0x0028 - 0x0028)
class UGeometryScriptLibrary_RemeshingFunctions final : public UBlueprintFunctionLibrary
{
public:
	static class UDynamicMesh* ApplyUniformRemesh(class UDynamicMesh* TargetMesh, const struct FGeometryScriptRemeshOptions& RemeshOptions, const struct FGeometryScriptUniformRemeshOptions& UniformOptions, class UGeometryScriptDebug* Debug);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GeometryScriptLibrary_RemeshingFunctions">();
	}
	static class UGeometryScriptLibrary_RemeshingFunctions* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGeometryScriptLibrary_RemeshingFunctions>();
	}
};
static_assert(alignof(UGeometryScriptLibrary_RemeshingFunctions) == 0x000008, "Wrong alignment on UGeometryScriptLibrary_RemeshingFunctions");
static_assert(sizeof(UGeometryScriptLibrary_RemeshingFunctions) == 0x000028, "Wrong size on UGeometryScriptLibrary_RemeshingFunctions");

// Class GeometryScriptingCore.GeometryScriptLibrary_MeshRepairFunctions
// 0x0000 (0x0028 - 0x0028)
class UGeometryScriptLibrary_MeshRepairFunctions final : public UBlueprintFunctionLibrary
{
public:
	static class UDynamicMesh* CompactMesh(class UDynamicMesh* TargetMesh, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* FillAllMeshHoles(class UDynamicMesh* TargetMesh, const struct FGeometryScriptFillHolesOptions& FillOptions, int32* NumFilledHoles, int32* NumFailedHoleFills, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* RemoveHiddenTriangles(class UDynamicMesh* TargetMesh, const struct FGeometryScriptRemoveHiddenTrianglesOptions& Options, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* RemoveSmallComponents(class UDynamicMesh* TargetMesh, const struct FGeometryScriptRemoveSmallComponentOptions& Options, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* RemoveUnusedVertices(class UDynamicMesh* TargetMesh, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* RepairMeshDegenerateGeometry(class UDynamicMesh* TargetMesh, const struct FGeometryScriptDegenerateTriangleOptions& Options, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* ResolveMeshTJunctions(class UDynamicMesh* TargetMesh, const struct FGeometryScriptResolveTJunctionOptions& ResolveOptions, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* SplitMeshBowties(class UDynamicMesh* TargetMesh, bool bMeshBowties, bool bAttributeBowties, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* WeldMeshEdges(class UDynamicMesh* TargetMesh, const struct FGeometryScriptWeldEdgesOptions& WeldOptions, class UGeometryScriptDebug* Debug);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GeometryScriptLibrary_MeshRepairFunctions">();
	}
	static class UGeometryScriptLibrary_MeshRepairFunctions* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGeometryScriptLibrary_MeshRepairFunctions>();
	}
};
static_assert(alignof(UGeometryScriptLibrary_MeshRepairFunctions) == 0x000008, "Wrong alignment on UGeometryScriptLibrary_MeshRepairFunctions");
static_assert(sizeof(UGeometryScriptLibrary_MeshRepairFunctions) == 0x000028, "Wrong size on UGeometryScriptLibrary_MeshRepairFunctions");

// Class GeometryScriptingCore.GeometryScriptLibrary_MeshSamplingFunctions
// 0x0000 (0x0028 - 0x0028)
class UGeometryScriptLibrary_MeshSamplingFunctions final : public UBlueprintFunctionLibrary
{
public:
	static class UDynamicMesh* ComputeNonUniformPointSampling(class UDynamicMesh* TargetMesh, const struct FGeometryScriptMeshPointSamplingOptions& Options, const struct FGeometryScriptNonUniformPointSamplingOptions& NonUniformOptions, TArray<struct FTransform>* Samples, TArray<double>* SampleRadii, struct FGeometryScriptIndexList* TriangleIDs, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* ComputePointSampling(class UDynamicMesh* TargetMesh, const struct FGeometryScriptMeshPointSamplingOptions& Options, TArray<struct FTransform>* Samples, struct FGeometryScriptIndexList* TriangleIDs, class UGeometryScriptDebug* Debug);
	static void ComputeRenderCaptureCamerasForBox(TArray<struct FGeometryScriptRenderCaptureCamera>* Cameras, const struct FBox& Box, const struct FGeometryScriptRenderCaptureCamerasForBoxOptions& Options, class UGeometryScriptDebug* Debug);
	static void ComputeRenderCapturePointSampling(TArray<struct FTransform>* Samples, const TArray<class AActor*>& Actors, const TArray<struct FGeometryScriptRenderCaptureCamera>& Cameras, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* ComputeVertexWeightedPointSampling(class UDynamicMesh* TargetMesh, const struct FGeometryScriptMeshPointSamplingOptions& Options, const struct FGeometryScriptNonUniformPointSamplingOptions& NonUniformOptions, const struct FGeometryScriptScalarList& VertexWeights, TArray<struct FTransform>* Samples, TArray<double>* SampleRadii, struct FGeometryScriptIndexList* TriangleIDs, class UGeometryScriptDebug* Debug);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GeometryScriptLibrary_MeshSamplingFunctions">();
	}
	static class UGeometryScriptLibrary_MeshSamplingFunctions* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGeometryScriptLibrary_MeshSamplingFunctions>();
	}
};
static_assert(alignof(UGeometryScriptLibrary_MeshSamplingFunctions) == 0x000008, "Wrong alignment on UGeometryScriptLibrary_MeshSamplingFunctions");
static_assert(sizeof(UGeometryScriptLibrary_MeshSamplingFunctions) == 0x000028, "Wrong size on UGeometryScriptLibrary_MeshSamplingFunctions");

// Class GeometryScriptingCore.GeometryScriptLibrary_MeshSelectionFunctions
// 0x0000 (0x0028 - 0x0028)
class UGeometryScriptLibrary_MeshSelectionFunctions final : public UBlueprintFunctionLibrary
{
public:
	static void CombineMeshSelections(const struct FGeometryScriptMeshSelection& SelectionA, const struct FGeometryScriptMeshSelection& SelectionB, struct FGeometryScriptMeshSelection* ResultSelection, EGeometryScriptCombineSelectionMode CombineMode);
	static class UDynamicMesh* ConvertIndexArrayToMeshSelection(class UDynamicMesh* TargetMesh, const TArray<int32>& IndexArray, EGeometryScriptMeshSelectionType SelectionType, struct FGeometryScriptMeshSelection* Selection);
	static class UDynamicMesh* ConvertIndexListToMeshSelection(class UDynamicMesh* TargetMesh, const struct FGeometryScriptIndexList& IndexList, EGeometryScriptMeshSelectionType SelectionType, struct FGeometryScriptMeshSelection* Selection);
	static class UDynamicMesh* ConvertIndexSetToMeshSelection(class UDynamicMesh* TargetMesh, const TSet<int32>& IndexSet, EGeometryScriptMeshSelectionType SelectionType, struct FGeometryScriptMeshSelection* Selection);
	static class UDynamicMesh* ConvertMeshSelection(class UDynamicMesh* TargetMesh, const struct FGeometryScriptMeshSelection& FromSelection, struct FGeometryScriptMeshSelection* ToSelection, EGeometryScriptMeshSelectionType NewType, bool bAllowPartialInclusion);
	static class UDynamicMesh* ConvertMeshSelectionToIndexArray(class UDynamicMesh* TargetMesh, const struct FGeometryScriptMeshSelection& Selection, TArray<int32>* IndexArray, EGeometryScriptMeshSelectionType* SelectionType);
	static class UDynamicMesh* ConvertMeshSelectionToIndexList(class UDynamicMesh* TargetMesh, const struct FGeometryScriptMeshSelection& Selection, struct FGeometryScriptIndexList* IndexList, EGeometryScriptIndexType* ResultListType, EGeometryScriptIndexType ConvertToType);
	static class UDynamicMesh* CreateSelectAllMeshSelection(class UDynamicMesh* TargetMesh, struct FGeometryScriptMeshSelection* Selection, EGeometryScriptMeshSelectionType SelectionType);
	static void DebugPrintMeshSelection(const struct FGeometryScriptMeshSelection& Selection, bool bDisable);
	static class UDynamicMesh* ExpandContractMeshSelection(class UDynamicMesh* TargetMesh, const struct FGeometryScriptMeshSelection& Selection, struct FGeometryScriptMeshSelection* NewSelection, int32 Iterations, bool bContract, bool bOnlyExpandToFaceNeighbours);
	static class UDynamicMesh* ExpandMeshSelectionToConnected(class UDynamicMesh* TargetMesh, const struct FGeometryScriptMeshSelection& Selection, struct FGeometryScriptMeshSelection* NewSelection, EGeometryScriptTopologyConnectionType ConnectionType);
	static void GetMeshSelectionInfo(const struct FGeometryScriptMeshSelection& Selection, EGeometryScriptMeshSelectionType* SelectionType, int32* NumSelected);
	static class UDynamicMesh* InvertMeshSelection(class UDynamicMesh* TargetMesh, const struct FGeometryScriptMeshSelection& Selection, struct FGeometryScriptMeshSelection* NewSelection, bool bOnlyToConnected);
	static class UDynamicMesh* SelectMeshElementsByNormalAngle(class UDynamicMesh* TargetMesh, struct FGeometryScriptMeshSelection* Selection, const struct FVector& Normal, double MaxAngleDeg, EGeometryScriptMeshSelectionType SelectionType, bool bInvert, int32 MinNumTrianglePoints);
	static class UDynamicMesh* SelectMeshElementsInBox(class UDynamicMesh* TargetMesh, struct FGeometryScriptMeshSelection* Selection, const struct FBox& Box, EGeometryScriptMeshSelectionType SelectionType, bool bInvert, int32 MinNumTrianglePoints);
	static class UDynamicMesh* SelectMeshElementsInsideMesh(class UDynamicMesh* TargetMesh, class UDynamicMesh* SelectionMesh, struct FGeometryScriptMeshSelection* Selection, const struct FTransform& SelectionMeshTransform, EGeometryScriptMeshSelectionType SelectionType, bool bInvert, double ShellDistance, double WindingThreshold, int32 MinNumTrianglePoints);
	static class UDynamicMesh* SelectMeshElementsInSphere(class UDynamicMesh* TargetMesh, struct FGeometryScriptMeshSelection* Selection, const struct FVector& SphereOrigin, double SphereRadius, EGeometryScriptMeshSelectionType SelectionType, bool bInvert, int32 MinNumTrianglePoints);
	static class UDynamicMesh* SelectMeshElementsWithPlane(class UDynamicMesh* TargetMesh, struct FGeometryScriptMeshSelection* Selection, const struct FVector& PlaneOrigin, const struct FVector& PlaneNormal, EGeometryScriptMeshSelectionType SelectionType, bool bInvert, int32 MinNumTrianglePoints);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GeometryScriptLibrary_MeshSelectionFunctions">();
	}
	static class UGeometryScriptLibrary_MeshSelectionFunctions* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGeometryScriptLibrary_MeshSelectionFunctions>();
	}
};
static_assert(alignof(UGeometryScriptLibrary_MeshSelectionFunctions) == 0x000008, "Wrong alignment on UGeometryScriptLibrary_MeshSelectionFunctions");
static_assert(sizeof(UGeometryScriptLibrary_MeshSelectionFunctions) == 0x000028, "Wrong size on UGeometryScriptLibrary_MeshSelectionFunctions");

// Class GeometryScriptingCore.GeometryScriptLibrary_MeshSelectionQueryFunctions
// 0x0000 (0x0028 - 0x0028)
class UGeometryScriptLibrary_MeshSelectionQueryFunctions final : public UBlueprintFunctionLibrary
{
public:
	static class UDynamicMesh* GetMeshSelectionBoundaryLoops(class UDynamicMesh* TargetMesh, const struct FGeometryScriptMeshSelection& Selection, TArray<struct FGeometryScriptIndexList>* IndexLoops, TArray<struct FGeometryScriptPolyPath>* PathLoops, int32* NumLoops, bool* bFoundErrors, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* GetMeshSelectionBoundingBox(class UDynamicMesh* TargetMesh, const struct FGeometryScriptMeshSelection& Selection, struct FBox* SelectionBounds, bool* bIsEmpty, class UGeometryScriptDebug* Debug);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GeometryScriptLibrary_MeshSelectionQueryFunctions">();
	}
	static class UGeometryScriptLibrary_MeshSelectionQueryFunctions* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGeometryScriptLibrary_MeshSelectionQueryFunctions>();
	}
};
static_assert(alignof(UGeometryScriptLibrary_MeshSelectionQueryFunctions) == 0x000008, "Wrong alignment on UGeometryScriptLibrary_MeshSelectionQueryFunctions");
static_assert(sizeof(UGeometryScriptLibrary_MeshSelectionQueryFunctions) == 0x000028, "Wrong size on UGeometryScriptLibrary_MeshSelectionQueryFunctions");

// Class GeometryScriptingCore.GeometryScriptLibrary_MeshSimplifyFunctions
// 0x0000 (0x0028 - 0x0028)
class UGeometryScriptLibrary_MeshSimplifyFunctions final : public UBlueprintFunctionLibrary
{
public:
	static class UDynamicMesh* ApplySimplifyToPlanar(class UDynamicMesh* TargetMesh, const struct FGeometryScriptPlanarSimplifyOptions& Options, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* ApplySimplifyToPolygroupTopology(class UDynamicMesh* TargetMesh, const struct FGeometryScriptPolygroupSimplifyOptions& Options, const struct FGeometryScriptGroupLayer& GroupLayer, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* ApplySimplifyToTolerance(class UDynamicMesh* TargetMesh, float Tolerance, const struct FGeometryScriptSimplifyMeshOptions& Options, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* ApplySimplifyToTriangleCount(class UDynamicMesh* TargetMesh, int32 TriangleCount, const struct FGeometryScriptSimplifyMeshOptions& Options, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* ApplySimplifyToVertexCount(class UDynamicMesh* TargetMesh, int32 VertexCount, const struct FGeometryScriptSimplifyMeshOptions& Options, class UGeometryScriptDebug* Debug);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GeometryScriptLibrary_MeshSimplifyFunctions">();
	}
	static class UGeometryScriptLibrary_MeshSimplifyFunctions* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGeometryScriptLibrary_MeshSimplifyFunctions>();
	}
};
static_assert(alignof(UGeometryScriptLibrary_MeshSimplifyFunctions) == 0x000008, "Wrong alignment on UGeometryScriptLibrary_MeshSimplifyFunctions");
static_assert(sizeof(UGeometryScriptLibrary_MeshSimplifyFunctions) == 0x000028, "Wrong size on UGeometryScriptLibrary_MeshSimplifyFunctions");

// Class GeometryScriptingCore.GeometryScriptLibrary_MeshSpatial
// 0x0000 (0x0028 - 0x0028)
class UGeometryScriptLibrary_MeshSpatial final : public UBlueprintFunctionLibrary
{
public:
	static class UDynamicMesh* BuildBVHForMesh(class UDynamicMesh* TargetMesh, struct FGeometryScriptDynamicMeshBVH* OutputBVH, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* FindNearestPointOnMesh(class UDynamicMesh* TargetMesh, const struct FGeometryScriptDynamicMeshBVH& QueryBVH, const struct FVector& QueryPoint, const struct FGeometryScriptSpatialQueryOptions& Options, struct FGeometryScriptTrianglePoint* NearestResult, EGeometryScriptSearchOutcomePins* Outcome, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* FindNearestRayIntersectionWithMesh(class UDynamicMesh* TargetMesh, const struct FGeometryScriptDynamicMeshBVH& QueryBVH, const struct FVector& RayOrigin, const struct FVector& RayDirection, const struct FGeometryScriptSpatialQueryOptions& Options, struct FGeometryScriptRayHitResult* HitResult, EGeometryScriptSearchOutcomePins* Outcome, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* IsBVHValidForMesh(class UDynamicMesh* TargetMesh, const struct FGeometryScriptDynamicMeshBVH& TestBVH, bool* bIsValid, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* IsPointInsideMesh(class UDynamicMesh* TargetMesh, const struct FGeometryScriptDynamicMeshBVH& QueryBVH, const struct FVector& QueryPoint, const struct FGeometryScriptSpatialQueryOptions& Options, bool* bIsInside, EGeometryScriptContainmentOutcomePins* Outcome, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* RebuildBVHForMesh(class UDynamicMesh* TargetMesh, struct FGeometryScriptDynamicMeshBVH& UpdateBVH, bool bOnlyIfInvalid, class UGeometryScriptDebug* Debug);
	static void ResetBVH(struct FGeometryScriptDynamicMeshBVH& ResetBVH_0);
	static class UDynamicMesh* SelectMeshElementsInBoxWithBVH(class UDynamicMesh* TargetMesh, const struct FGeometryScriptDynamicMeshBVH& QueryBVH, const struct FBox& QueryBox, const struct FGeometryScriptSpatialQueryOptions& Options, struct FGeometryScriptMeshSelection* Selection, EGeometryScriptMeshSelectionType SelectionType, int32 MinNumTrianglePoints, class UGeometryScriptDebug* Debug);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GeometryScriptLibrary_MeshSpatial">();
	}
	static class UGeometryScriptLibrary_MeshSpatial* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGeometryScriptLibrary_MeshSpatial>();
	}
};
static_assert(alignof(UGeometryScriptLibrary_MeshSpatial) == 0x000008, "Wrong alignment on UGeometryScriptLibrary_MeshSpatial");
static_assert(sizeof(UGeometryScriptLibrary_MeshSpatial) == 0x000028, "Wrong size on UGeometryScriptLibrary_MeshSpatial");

// Class GeometryScriptingCore.GeometryScriptLibrary_MeshSubdivideFunctions
// 0x0000 (0x0028 - 0x0028)
class UGeometryScriptLibrary_MeshSubdivideFunctions final : public UBlueprintFunctionLibrary
{
public:
	static class UDynamicMesh* ApplyPNTessellation(class UDynamicMesh* TargetMesh, const struct FGeometryScriptPNTessellateOptions& Options, int32 TessellationLevel, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* ApplySelectiveTessellation(class UDynamicMesh* TargetMesh, const struct FGeometryScriptMeshSelection& Selection, const struct FGeometryScriptSelectiveTessellateOptions& Options, int32 TessellationLevel, ESelectiveTessellatePatternType PatternType, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* ApplyUniformTessellation(class UDynamicMesh* TargetMesh, int32 TessellationLevel, class UGeometryScriptDebug* Debug);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GeometryScriptLibrary_MeshSubdivideFunctions">();
	}
	static class UGeometryScriptLibrary_MeshSubdivideFunctions* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGeometryScriptLibrary_MeshSubdivideFunctions>();
	}
};
static_assert(alignof(UGeometryScriptLibrary_MeshSubdivideFunctions) == 0x000008, "Wrong alignment on UGeometryScriptLibrary_MeshSubdivideFunctions");
static_assert(sizeof(UGeometryScriptLibrary_MeshSubdivideFunctions) == 0x000028, "Wrong size on UGeometryScriptLibrary_MeshSubdivideFunctions");

// Class GeometryScriptingCore.GeometryScriptLibrary_MeshTransformFunctions
// 0x0000 (0x0028 - 0x0028)
class UGeometryScriptLibrary_MeshTransformFunctions final : public UBlueprintFunctionLibrary
{
public:
	static class UDynamicMesh* RotateMesh(class UDynamicMesh* TargetMesh, const struct FRotator& Rotation, const struct FVector& RotationOrigin, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* RotateMeshSelection(class UDynamicMesh* TargetMesh, const struct FGeometryScriptMeshSelection& Selection, const struct FRotator& Rotation, const struct FVector& RotationOrigin, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* ScaleMesh(class UDynamicMesh* TargetMesh, const struct FVector& Scale, const struct FVector& ScaleOrigin, bool bFixOrientationForNegativeScale, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* ScaleMeshSelection(class UDynamicMesh* TargetMesh, const struct FGeometryScriptMeshSelection& Selection, const struct FVector& Scale, const struct FVector& ScaleOrigin, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* TransformMesh(class UDynamicMesh* TargetMesh, const struct FTransform& Transform, bool bFixOrientationForNegativeScale, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* TransformMeshSelection(class UDynamicMesh* TargetMesh, const struct FGeometryScriptMeshSelection& Selection, const struct FTransform& Transform, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* TranslateMesh(class UDynamicMesh* TargetMesh, const struct FVector& Translation, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* TranslateMeshSelection(class UDynamicMesh* TargetMesh, const struct FGeometryScriptMeshSelection& Selection, const struct FVector& Translation, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* TranslatePivotToLocation(class UDynamicMesh* TargetMesh, const struct FVector& PivotLocation, class UGeometryScriptDebug* Debug);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GeometryScriptLibrary_MeshTransformFunctions">();
	}
	static class UGeometryScriptLibrary_MeshTransformFunctions* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGeometryScriptLibrary_MeshTransformFunctions>();
	}
};
static_assert(alignof(UGeometryScriptLibrary_MeshTransformFunctions) == 0x000008, "Wrong alignment on UGeometryScriptLibrary_MeshTransformFunctions");
static_assert(sizeof(UGeometryScriptLibrary_MeshTransformFunctions) == 0x000028, "Wrong size on UGeometryScriptLibrary_MeshTransformFunctions");

// Class GeometryScriptingCore.GeometryScriptLibrary_MeshUVFunctions
// 0x0000 (0x0028 - 0x0028)
class UGeometryScriptLibrary_MeshUVFunctions final : public UBlueprintFunctionLibrary
{
public:
	static class UDynamicMesh* AddUVElementToMesh(class UDynamicMesh* TargetMesh, int32 UvSetIndex, const struct FVector2D& NewUVPosition, int32* NewUVElementID, bool* bIsValidUVSet, bool bDeferChangeNotifications);
	static class UDynamicMesh* AutoGeneratePatchBuilderMeshUVs(class UDynamicMesh* TargetMesh, int32 UvSetIndex, const struct FGeometryScriptPatchBuilderOptions& Options, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* AutoGenerateXAtlasMeshUVs(class UDynamicMesh* TargetMesh, int32 UvSetIndex, const struct FGeometryScriptXAtlasOptions& Options, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* ComputeMeshLocalUVParam(class UDynamicMesh* TargetMesh, const struct FVector& CenterPoint, int32 CenterPointTriangleID, TArray<int32>* VertexIDs, TArray<struct FVector2D>* VertexUVs, double Radius, bool bUseInterpolatedNormal, const struct FVector& TangentYDirection, double UVRotationDeg, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* CopyMeshToMeshUVLayer(class UDynamicMesh* CopyFromUVMesh, int32 ToUVSetIndex, class UDynamicMesh*& CopyToMesh, class UDynamicMesh** CopyToMeshOut, bool* bFoundTopologyErrors, bool* bIsValidUVSet, bool bOnlyUVPositions, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* CopyMeshUVLayerToMesh(class UDynamicMesh* CopyFromMesh, int32 UvSetIndex, class UDynamicMesh*& CopyToUVMesh, class UDynamicMesh** CopyToUVMeshOut, bool* bInvalidTopology, bool* bIsValidUVSet, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* CopyUVSet(class UDynamicMesh* TargetMesh, int32 FromUVSet, int32 ToUVSet, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* GetMeshPerVertexUVs(class UDynamicMesh* TargetMesh, int32 UvSetIndex, struct FGeometryScriptUVList* UVList, bool* bIsValidUVSet, bool* bHasVertexIDGaps, bool* bHasSplitUVs, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* GetMeshTriangleUVElementIDs(class UDynamicMesh* TargetMesh, int32 UvSetIndex, int32 TriangleID, struct FIntVector* TriangleUVElements, bool* bHaveValidUVs);
	static class UDynamicMesh* GetMeshUVElementPosition(class UDynamicMesh* TargetMesh, int32 UvSetIndex, int32 ElementID, struct FVector2D* UVPosition, bool* bIsValidElementID);
	static class UDynamicMesh* GetMeshUVSizeInfo(class UDynamicMesh* TargetMesh, int32 UvSetIndex, const struct FGeometryScriptMeshSelection& Selection, double* MeshArea, double* UVArea, struct FBox* MeshBounds, struct FBox2D* UVBounds, bool* bIsValidUVSet, bool* bFoundUnsetUVs, bool bOnlyIncludeValidUVTris, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* RecomputeMeshUVs(class UDynamicMesh* TargetMesh, int32 UvSetIndex, const struct FGeometryScriptRecomputeUVsOptions& Options, const struct FGeometryScriptMeshSelection& Selection, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* RepackMeshUVs(class UDynamicMesh* TargetMesh, int32 UvSetIndex, const struct FGeometryScriptRepackUVsOptions& RepackOptions, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* RotateMeshUVs(class UDynamicMesh* TargetMesh, int32 UvSetIndex, float RotationAngle, const struct FVector2D& RotationOrigin, const struct FGeometryScriptMeshSelection& Selection, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* ScaleMeshUVs(class UDynamicMesh* TargetMesh, int32 UvSetIndex, const struct FVector2D& Scale, const struct FVector2D& ScaleOrigin, const struct FGeometryScriptMeshSelection& Selection, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* SetMeshTriangleUVElementIDs(class UDynamicMesh* TargetMesh, int32 UvSetIndex, int32 TriangleID, const struct FIntVector& TriangleUVElements, bool* bIsValidTriangle, bool bDeferChangeNotifications);
	static class UDynamicMesh* SetMeshTriangleUVs(class UDynamicMesh* TargetMesh, int32 UvSetIndex, int32 TriangleID, const struct FGeometryScriptUVTriangle& UVs, bool* bIsValidTriangle, bool bDeferChangeNotifications);
	static class UDynamicMesh* SetMeshUVElementPosition(class UDynamicMesh* TargetMesh, int32 UvSetIndex, int32 ElementID, const struct FVector2D& NewUVPosition, bool* bIsValidElementID, bool bDeferChangeNotifications);
	static class UDynamicMesh* SetMeshUVsFromBoxProjection(class UDynamicMesh* TargetMesh, int32 UvSetIndex, const struct FTransform& BoxTransform, const struct FGeometryScriptMeshSelection& Selection, int32 MinIslandTriCount, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* SetMeshUVsFromCylinderProjection(class UDynamicMesh* TargetMesh, int32 UvSetIndex, const struct FTransform& CylinderTransform, const struct FGeometryScriptMeshSelection& Selection, float SplitAngle, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* SetMeshUVsFromPlanarProjection(class UDynamicMesh* TargetMesh, int32 UvSetIndex, const struct FTransform& PlaneTransform, const struct FGeometryScriptMeshSelection& Selection, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* SetNumUVSets(class UDynamicMesh* TargetMesh, int32 NumUVSets, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* TranslateMeshUVs(class UDynamicMesh* TargetMesh, int32 UvSetIndex, const struct FVector2D& Translation, const struct FGeometryScriptMeshSelection& Selection, class UGeometryScriptDebug* Debug);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GeometryScriptLibrary_MeshUVFunctions">();
	}
	static class UGeometryScriptLibrary_MeshUVFunctions* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGeometryScriptLibrary_MeshUVFunctions>();
	}
};
static_assert(alignof(UGeometryScriptLibrary_MeshUVFunctions) == 0x000008, "Wrong alignment on UGeometryScriptLibrary_MeshUVFunctions");
static_assert(sizeof(UGeometryScriptLibrary_MeshUVFunctions) == 0x000028, "Wrong size on UGeometryScriptLibrary_MeshUVFunctions");

// Class GeometryScriptingCore.GeometryScriptLibrary_MeshVertexColorFunctions
// 0x0000 (0x0028 - 0x0028)
class UGeometryScriptLibrary_MeshVertexColorFunctions final : public UBlueprintFunctionLibrary
{
public:
	static class UDynamicMesh* BlurMeshVertexColors(class UDynamicMesh* TargetMesh, const struct FGeometryScriptMeshSelection& Selection, int32 NumIterations, double Strength, EGeometryScriptBlurColorMode BlurMode, const struct FGeometryScriptBlurMeshVertexColorsOptions& Options, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* ConvertMeshVertexColorsLinearToSRGB(class UDynamicMesh* TargetMesh, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* ConvertMeshVertexColorsSRGBToLinear(class UDynamicMesh* TargetMesh, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* GetMeshPerVertexColors(class UDynamicMesh* TargetMesh, struct FGeometryScriptColorList* ColorList, bool* bIsValidColorSet, bool* bHasVertexIDGaps, bool bBlendSplitVertexValues);
	static class UDynamicMesh* SetMeshConstantVertexColor(class UDynamicMesh* TargetMesh, const struct FLinearColor& Color, const struct FGeometryScriptColorFlags& Flags_0, bool bClearExisting, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* SetMeshPerVertexColors(class UDynamicMesh* TargetMesh, const struct FGeometryScriptColorList& VertexColorList, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* SetMeshSelectionVertexColor(class UDynamicMesh* TargetMesh, const struct FGeometryScriptMeshSelection& Selection, const struct FLinearColor& Color, const struct FGeometryScriptColorFlags& Flags_0, bool bCreateColorSeam, class UGeometryScriptDebug* Debug);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GeometryScriptLibrary_MeshVertexColorFunctions">();
	}
	static class UGeometryScriptLibrary_MeshVertexColorFunctions* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGeometryScriptLibrary_MeshVertexColorFunctions>();
	}
};
static_assert(alignof(UGeometryScriptLibrary_MeshVertexColorFunctions) == 0x000008, "Wrong alignment on UGeometryScriptLibrary_MeshVertexColorFunctions");
static_assert(sizeof(UGeometryScriptLibrary_MeshVertexColorFunctions) == 0x000028, "Wrong size on UGeometryScriptLibrary_MeshVertexColorFunctions");

// Class GeometryScriptingCore.GeometryScriptLibrary_MeshVoxelFunctions
// 0x0000 (0x0028 - 0x0028)
class UGeometryScriptLibrary_MeshVoxelFunctions final : public UBlueprintFunctionLibrary
{
public:
	static class UDynamicMesh* ApplyMeshMorphology(class UDynamicMesh* TargetMesh, const struct FGeometryScriptMorphologyOptions& Options, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* ApplyMeshSolidify(class UDynamicMesh* TargetMesh, const struct FGeometryScriptSolidifyOptions& Options, class UGeometryScriptDebug* Debug);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GeometryScriptLibrary_MeshVoxelFunctions">();
	}
	static class UGeometryScriptLibrary_MeshVoxelFunctions* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGeometryScriptLibrary_MeshVoxelFunctions>();
	}
};
static_assert(alignof(UGeometryScriptLibrary_MeshVoxelFunctions) == 0x000008, "Wrong alignment on UGeometryScriptLibrary_MeshVoxelFunctions");
static_assert(sizeof(UGeometryScriptLibrary_MeshVoxelFunctions) == 0x000028, "Wrong size on UGeometryScriptLibrary_MeshVoxelFunctions");

// Class GeometryScriptingCore.GeometryScriptLibrary_PointSetSamplingFunctions
// 0x0000 (0x0028 - 0x0028)
class UGeometryScriptLibrary_PointSetSamplingFunctions final : public UBlueprintFunctionLibrary
{
public:
	static void DownsamplePoints(const TArray<struct FVector>& Points, const struct FGeometryScriptPointPriorityOptions& Options, struct FGeometryScriptIndexList* DownsampledIndices, int32 KeepNumPoints, class UGeometryScriptDebug* Debug);
	static void FlattenPoints(const TArray<struct FVector>& PointsIn3D, TArray<struct FVector2D>* PointsIn2D, const struct FGeometryScriptPointFlatteningOptions& Options);
	static void GetPointsFromIndexList(const TArray<struct FVector>& AllPoints, const struct FGeometryScriptIndexList& Indices, TArray<struct FVector>* SelectedPoints);
	static void KMeansClusterToArrays(const TArray<struct FVector>& Points, const struct FGeometryScriptPointClusteringOptions& Options, TArray<struct FGeometryScriptIndexList>* ClusterIDToLists);
	static void KMeansClusterToIDs(const TArray<struct FVector>& Points, const struct FGeometryScriptPointClusteringOptions& Options, TArray<int32>* PointClusterIndices);
	static struct FBox MakeBoundingBoxFromPoints(const TArray<struct FVector>& Points, double ExpandBy);
	static void OffsetTransforms(TArray<struct FTransform>& Transforms, double Offset, const struct FVector& Direction, EGeometryScriptCoordinateSpace Space);
	static void TransformsToPoints(const TArray<struct FTransform>& Transforms, TArray<struct FVector>* Points);
	static void UnflattenPoints(const TArray<struct FVector2D>& PointsIn2D, TArray<struct FVector>* PointsIn3D, const struct FGeometryScriptPointFlatteningOptions& Options, double Height);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GeometryScriptLibrary_PointSetSamplingFunctions">();
	}
	static class UGeometryScriptLibrary_PointSetSamplingFunctions* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGeometryScriptLibrary_PointSetSamplingFunctions>();
	}
};
static_assert(alignof(UGeometryScriptLibrary_PointSetSamplingFunctions) == 0x000008, "Wrong alignment on UGeometryScriptLibrary_PointSetSamplingFunctions");
static_assert(sizeof(UGeometryScriptLibrary_PointSetSamplingFunctions) == 0x000028, "Wrong size on UGeometryScriptLibrary_PointSetSamplingFunctions");

// Class GeometryScriptingCore.GeometryScriptLibrary_SimplePolygonFunctions
// 0x0000 (0x0028 - 0x0028)
class UGeometryScriptLibrary_SimplePolygonFunctions final : public UBlueprintFunctionLibrary
{
public:
	static int32 AddPolygonVertex(struct FGeometryScriptSimplePolygon& Polygon, const struct FVector2D& Position);
	static struct FGeometryScriptSimplePolygon Conv_ArrayOfVector2DToGeometryScriptSimplePolygon(const TArray<struct FVector2D>& PathVertices);
	static struct FGeometryScriptSimplePolygon Conv_ArrayToGeometryScriptSimplePolygon(const TArray<struct FVector>& PathVertices);
	static TArray<struct FVector> Conv_GeometryScriptSimplePolygonToArray(const struct FGeometryScriptSimplePolygon& Polygon);
	static TArray<struct FVector2D> Conv_GeometryScriptSimplePolygonToArrayOfVector2D(const struct FGeometryScriptSimplePolygon& Polygon);
	static void ConvertSplineToPolygon(const class USplineComponent* Spline, struct FGeometryScriptSimplePolygon* Polygon, const struct FGeometryScriptSplineSamplingOptions& SamplingOptions, EGeometryScriptAxis DropAxis);
	static double GetPolygonArcLength(const struct FGeometryScriptSimplePolygon& Polygon);
	static double GetPolygonArea(const struct FGeometryScriptSimplePolygon& Polygon);
	static struct FBox2D GetPolygonBounds(const struct FGeometryScriptSimplePolygon& Polygon);
	static struct FVector2D GetPolygonTangent(const struct FGeometryScriptSimplePolygon& Polygon, int32 VertexIndex, bool* bPolygonIsEmpty);
	static struct FVector2D GetPolygonVertex(const struct FGeometryScriptSimplePolygon& Polygon, int32 VertexIndex, bool* bPolygonIsEmpty);
	static int32 GetPolygonVertexCount(const struct FGeometryScriptSimplePolygon& Polygon);
	static void SetPolygonVertex(struct FGeometryScriptSimplePolygon& Polygon, int32 VertexIndex, const struct FVector2D& Position, bool* bPolygonIsEmpty);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GeometryScriptLibrary_SimplePolygonFunctions">();
	}
	static class UGeometryScriptLibrary_SimplePolygonFunctions* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGeometryScriptLibrary_SimplePolygonFunctions>();
	}
};
static_assert(alignof(UGeometryScriptLibrary_SimplePolygonFunctions) == 0x000008, "Wrong alignment on UGeometryScriptLibrary_SimplePolygonFunctions");
static_assert(sizeof(UGeometryScriptLibrary_SimplePolygonFunctions) == 0x000028, "Wrong size on UGeometryScriptLibrary_SimplePolygonFunctions");

// Class GeometryScriptingCore.GeometryScriptLibrary_PolygonListFunctions
// 0x0000 (0x0028 - 0x0028)
class UGeometryScriptLibrary_PolygonListFunctions final : public UBlueprintFunctionLibrary
{
public:
	static int32 AddPolygonToList(struct FGeometryScriptGeneralPolygonList& PolygonList, const struct FGeometryScriptSimplePolygon& OuterPolygon, const TArray<struct FGeometryScriptSimplePolygon>& HolePolygons, bool bFixHoleOrientations);
	static void AppendPolygonList(struct FGeometryScriptGeneralPolygonList& PolygonList, const struct FGeometryScriptGeneralPolygonList& PolygonsToAppend);
	static struct FGeometryScriptGeneralPolygonList CreatePolygonListFromSimplePolygons(const TArray<struct FGeometryScriptSimplePolygon>& OuterPolygons);
	static struct FGeometryScriptGeneralPolygonList CreatePolygonListFromSinglePolygon(const struct FGeometryScriptSimplePolygon& OuterPolygon, const TArray<struct FGeometryScriptSimplePolygon>& HolePolygons, bool bFixHoleOrientations);
	static struct FGeometryScriptGeneralPolygonList CreatePolygonsFromOpenPolyPathsOffset(const TArray<struct FGeometryScriptPolyPath>& PolyPaths, const struct FGeometryScriptOpenPathOffsetOptions& OffsetOptions, double Offset, bool* bOperationSuccess, bool bCopyInputOnFailure);
	static struct FGeometryScriptGeneralPolygonList CreatePolygonsFromPathOffset(const TArray<struct FVector2D>& Path, const struct FGeometryScriptOpenPathOffsetOptions& OffsetOptions, double Offset, bool* bOperationSuccess, bool bCopyInputOnFailure);
	static double GetPolygonArea(const struct FGeometryScriptGeneralPolygonList& PolygonList, bool* bValidIndex, int32 PolygonIndex);
	static struct FBox2D GetPolygonBounds(const struct FGeometryScriptGeneralPolygonList& PolygonList, bool* bValidIndex, int32 PolygonIndex);
	static int32 GetPolygonCount(const struct FGeometryScriptGeneralPolygonList& PolygonList);
	static int32 GetPolygonHoleCount(const struct FGeometryScriptGeneralPolygonList& PolygonList, bool* bValidIndex, int32 PolygonIndex);
	static double GetPolygonListArea(const struct FGeometryScriptGeneralPolygonList& PolygonList);
	static struct FBox2D GetPolygonListBounds(const struct FGeometryScriptGeneralPolygonList& PolygonList);
	static struct FVector2D GetPolygonVertex(const struct FGeometryScriptGeneralPolygonList& PolygonList, bool* bIsValidVertex, int32 VertexIndex, int32 PolygonIndex, int32 HoleIndex);
	static int32 GetPolygonVertexCount(const struct FGeometryScriptGeneralPolygonList& PolygonList, bool* bValidIndices, int32 PolygonIndex, int32 HoleIndex);
	static void GetPolygonVertices(const struct FGeometryScriptGeneralPolygonList& PolygonList, TArray<struct FVector2D>* OutVertices, bool* bValidIndices, int32 PolygonIndex, int32 HoleIndex);
	static struct FGeometryScriptSimplePolygon GetSimplePolygon(const struct FGeometryScriptGeneralPolygonList& PolygonList, bool* bValidIndices, int32 PolygonIndex, int32 HoleIndex);
	static struct FGeometryScriptGeneralPolygonList PolygonsDifference(const struct FGeometryScriptGeneralPolygonList& PolygonList, const struct FGeometryScriptGeneralPolygonList& PolygonsToSubtract);
	static struct FGeometryScriptGeneralPolygonList PolygonsExclusiveOr(const struct FGeometryScriptGeneralPolygonList& PolygonList, const struct FGeometryScriptGeneralPolygonList& PolygonsToExclusiveOr);
	static struct FGeometryScriptGeneralPolygonList PolygonsIntersection(const struct FGeometryScriptGeneralPolygonList& PolygonList, const struct FGeometryScriptGeneralPolygonList& PolygonsToIntersect);
	static struct FGeometryScriptGeneralPolygonList PolygonsMorphologyClose(const struct FGeometryScriptGeneralPolygonList& PolygonList, const struct FGeometryScriptPolygonOffsetOptions& OffsetOptions, double Offset, bool* bOperationSuccess, bool bCopyInputOnFailure);
	static struct FGeometryScriptGeneralPolygonList PolygonsMorphologyOpen(const struct FGeometryScriptGeneralPolygonList& PolygonList, const struct FGeometryScriptPolygonOffsetOptions& OffsetOptions, double Offset, bool* bOperationSuccess, bool bCopyInputOnFailure);
	static struct FGeometryScriptGeneralPolygonList PolygonsOffset(const struct FGeometryScriptGeneralPolygonList& PolygonList, const struct FGeometryScriptPolygonOffsetOptions& OffsetOptions, double Offset, bool* bOperationSuccess, bool bCopyInputOnFailure);
	static struct FGeometryScriptGeneralPolygonList PolygonsOffsets(const struct FGeometryScriptGeneralPolygonList& PolygonList, const struct FGeometryScriptPolygonOffsetOptions& OffsetOptions, double FirstOffset, double SecondOffset, bool* bOperationSuccess, bool bCopyInputOnFailure);
	static struct FGeometryScriptGeneralPolygonList PolygonsUnion(const struct FGeometryScriptGeneralPolygonList& PolygonList, bool bCopyInputOnFailure);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GeometryScriptLibrary_PolygonListFunctions">();
	}
	static class UGeometryScriptLibrary_PolygonListFunctions* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGeometryScriptLibrary_PolygonListFunctions>();
	}
};
static_assert(alignof(UGeometryScriptLibrary_PolygonListFunctions) == 0x000008, "Wrong alignment on UGeometryScriptLibrary_PolygonListFunctions");
static_assert(sizeof(UGeometryScriptLibrary_PolygonListFunctions) == 0x000028, "Wrong size on UGeometryScriptLibrary_PolygonListFunctions");

// Class GeometryScriptingCore.GeometryScriptLibrary_PolyPathFunctions
// 0x0000 (0x0028 - 0x0028)
class UGeometryScriptLibrary_PolyPathFunctions final : public UBlueprintFunctionLibrary
{
public:
	static struct FGeometryScriptPolyPath Conv_ArrayOfVector2DToGeometryScriptPolyPath(const TArray<struct FVector2D>& PathVertices);
	static struct FGeometryScriptPolyPath Conv_ArrayToGeometryScriptPolyPath(const TArray<struct FVector>& PathVertices);
	static TArray<struct FVector> Conv_GeometryScriptPolyPathToArray(const struct FGeometryScriptPolyPath& PolyPath);
	static TArray<struct FVector2D> Conv_GeometryScriptPolyPathToArrayOfVector2D(const struct FGeometryScriptPolyPath& PolyPath);
	static void ConvertArrayOfVector2DToPolyPath(const TArray<struct FVector2D>& VertexArray, struct FGeometryScriptPolyPath* PolyPath);
	static void ConvertArrayToPolyPath(const TArray<struct FVector>& VertexArray, struct FGeometryScriptPolyPath* PolyPath);
	static void ConvertPolyPathToArray(const struct FGeometryScriptPolyPath& PolyPath, TArray<struct FVector>* VertexArray);
	static void ConvertPolyPathToArrayOfVector2D(const struct FGeometryScriptPolyPath& PolyPath, TArray<struct FVector2D>* VertexArray);
	static void ConvertSplineToPolyPath(const class USplineComponent* Spline, struct FGeometryScriptPolyPath* PolyPath, const struct FGeometryScriptSplineSamplingOptions& SamplingOptions);
	static struct FGeometryScriptPolyPath CreateArcPath2D(const struct FVector2D& Center, float Radius, int32 NumPoints, float StartAngle, float EndAngle);
	static struct FGeometryScriptPolyPath CreateArcPath3D(const struct FTransform& Transform, float Radius, int32 NumPoints, float StartAngle, float EndAngle);
	static struct FGeometryScriptPolyPath CreateCirclePath2D(const struct FVector2D& Center, float Radius, int32 NumPoints);
	static struct FGeometryScriptPolyPath CreateCirclePath3D(const struct FTransform& Transform, float Radius, int32 NumPoints);
	static struct FGeometryScriptPolyPath FlattenTo2DOnAxis(const struct FGeometryScriptPolyPath& PolyPath, EGeometryScriptAxis DropAxis);
	static int32 GetNearestVertexIndex(const struct FGeometryScriptPolyPath& PolyPath, const struct FVector& Point);
	static double GetPolyPathArcLength(const struct FGeometryScriptPolyPath& PolyPath);
	static int32 GetPolyPathLastIndex(const struct FGeometryScriptPolyPath& PolyPath);
	static int32 GetPolyPathNumVertices(const struct FGeometryScriptPolyPath& PolyPath);
	static struct FVector GetPolyPathTangent(const struct FGeometryScriptPolyPath& PolyPath, int32 Index_0, bool* bIsValidIndex);
	static struct FVector GetPolyPathVertex(const struct FGeometryScriptPolyPath& PolyPath, int32 Index_0, bool* bIsValidIndex);
	static bool SampleSplineToTransforms(const class USplineComponent* Spline, TArray<struct FTransform>* Frames, TArray<double>* FrameTimes, const struct FGeometryScriptSplineSamplingOptions& SamplingOptions, const struct FTransform& RelativeTransform, bool bIncludeScale);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GeometryScriptLibrary_PolyPathFunctions">();
	}
	static class UGeometryScriptLibrary_PolyPathFunctions* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGeometryScriptLibrary_PolyPathFunctions>();
	}
};
static_assert(alignof(UGeometryScriptLibrary_PolyPathFunctions) == 0x000008, "Wrong alignment on UGeometryScriptLibrary_PolyPathFunctions");
static_assert(sizeof(UGeometryScriptLibrary_PolyPathFunctions) == 0x000028, "Wrong size on UGeometryScriptLibrary_PolyPathFunctions");

// Class GeometryScriptingCore.GeometryScriptLibrary_SceneUtilityFunctions
// 0x0000 (0x0028 - 0x0028)
class UGeometryScriptLibrary_SceneUtilityFunctions final : public UBlueprintFunctionLibrary
{
public:
	static class UDynamicMesh* CopyCollisionMeshesFromObject(class UObject* FromObject, class UDynamicMesh* ToDynamicMesh, bool bTransformToWorld, struct FTransform* LocalToWorld, EGeometryScriptOutcomePins* Outcome, bool bUseComplexCollision, int32 SphereResolution, class UGeometryScriptDebug* Debug);
	static class UDynamicMesh* CopyMeshFromComponent(class USceneComponent* Component, class UDynamicMesh* ToDynamicMesh, const struct FGeometryScriptCopyMeshFromComponentOptions& Options, bool bTransformToWorld, struct FTransform* LocalToWorld, EGeometryScriptOutcomePins* Outcome, class UGeometryScriptDebug* Debug);
	static class UDynamicMeshPool* CreateDynamicMeshPool();
	static void DetermineMeshOcclusion(const TArray<class UDynamicMesh*>& SourceMeshes, const TArray<struct FTransform>& SourceMeshTransforms, TArray<bool>* OutMeshIsHidden, const TArray<class UDynamicMesh*>& TransparentMeshes, const TArray<struct FTransform>& TransparentMeshTransforms, TArray<bool>* OutTransparentMeshIsHidden, const TArray<class UDynamicMesh*>& OccludeMeshes, const TArray<struct FTransform>& OccludeMeshTransforms, const struct FGeometryScriptDetermineMeshOcclusionOptions& OcclusionOptions, class UGeometryScriptDebug* Debug);
	static void SetComponentMaterialList(class UPrimitiveComponent* Component, const TArray<class UMaterialInterface*>& MaterialList, class UGeometryScriptDebug* Debug);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GeometryScriptLibrary_SceneUtilityFunctions">();
	}
	static class UGeometryScriptLibrary_SceneUtilityFunctions* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGeometryScriptLibrary_SceneUtilityFunctions>();
	}
};
static_assert(alignof(UGeometryScriptLibrary_SceneUtilityFunctions) == 0x000008, "Wrong alignment on UGeometryScriptLibrary_SceneUtilityFunctions");
static_assert(sizeof(UGeometryScriptLibrary_SceneUtilityFunctions) == 0x000028, "Wrong size on UGeometryScriptLibrary_SceneUtilityFunctions");

// Class GeometryScriptingCore.GeometryScriptLibrary_TransformFunctions
// 0x0000 (0x0028 - 0x0028)
class UGeometryScriptLibrary_TransformFunctions final : public UBlueprintFunctionLibrary
{
public:
	static struct FPlane GetTransformAxisPlane(const struct FTransform& Transform, EGeometryScriptAxis Axis);
	static struct FRay GetTransformAxisRay(const struct FTransform& Transform, EGeometryScriptAxis Axis);
	static struct FVector GetTransformAxisVector(const struct FTransform& Transform, EGeometryScriptAxis Axis);
	static struct FTransform MakeTransformFromAxes(const struct FVector& Location, const struct FVector& ZAxis, const struct FVector& TangentAxis, bool bTangentIsX);
	static struct FTransform MakeTransformFromZAxis(const struct FVector& Location, const struct FVector& ZAxis);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GeometryScriptLibrary_TransformFunctions">();
	}
	static class UGeometryScriptLibrary_TransformFunctions* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGeometryScriptLibrary_TransformFunctions>();
	}
};
static_assert(alignof(UGeometryScriptLibrary_TransformFunctions) == 0x000008, "Wrong alignment on UGeometryScriptLibrary_TransformFunctions");
static_assert(sizeof(UGeometryScriptLibrary_TransformFunctions) == 0x000028, "Wrong size on UGeometryScriptLibrary_TransformFunctions");

// Class GeometryScriptingCore.GeometryScriptLibrary_RayFunctions
// 0x0000 (0x0028 - 0x0028)
class UGeometryScriptLibrary_RayFunctions final : public UBlueprintFunctionLibrary
{
public:
	static bool GetRayBoxIntersection(const struct FRay& Ray, const struct FBox& Box, double* HitDistance);
	static struct FVector GetRayClosestPoint(const struct FRay& Ray, const struct FVector& Point);
	static double GetRayLineClosestPoint(const struct FRay& Ray, const struct FVector& LineOrigin, const struct FVector& LineDirection, double* RayParameter, struct FVector* RayPoint, double* LineParameter, struct FVector* LinePoint);
	static double GetRayParameter(const struct FRay& Ray, const struct FVector& Point);
	static bool GetRayPlaneIntersection(const struct FRay& Ray, const struct FPlane& Plane, double* HitDistance);
	static struct FVector GetRayPoint(const struct FRay& Ray, double Distance);
	static double GetRayPointDistance(const struct FRay& Ray, const struct FVector& Point);
	static double GetRaySegmentClosestPoint(const struct FRay& Ray, const struct FVector& SegStartPoint, const struct FVector& SegEndPoint, double* RayParameter, struct FVector* RayPoint, struct FVector* SegPoint);
	static bool GetRaySphereIntersection(const struct FRay& Ray, const struct FVector& SphereCenter, double SphereRadius, double* Distance1, double* Distance2);
	static void GetRayStartEnd(const struct FRay& Ray, double StartDistance, double EndDistance, struct FVector* StartPoint, struct FVector* EndPoint);
	static struct FRay GetTransformedRay(const struct FRay& Ray, const struct FTransform& Transform, bool bInvert);
	static struct FRay MakeRayFromPointDirection(const struct FVector& Origin, const struct FVector& Direction, bool bDirectionIsNormalized);
	static struct FRay MakeRayFromPoints(const struct FVector& A, const struct FVector& B);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GeometryScriptLibrary_RayFunctions">();
	}
	static class UGeometryScriptLibrary_RayFunctions* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGeometryScriptLibrary_RayFunctions>();
	}
};
static_assert(alignof(UGeometryScriptLibrary_RayFunctions) == 0x000008, "Wrong alignment on UGeometryScriptLibrary_RayFunctions");
static_assert(sizeof(UGeometryScriptLibrary_RayFunctions) == 0x000028, "Wrong size on UGeometryScriptLibrary_RayFunctions");

// Class GeometryScriptingCore.GeometryScriptLibrary_BoxFunctions
// 0x0000 (0x0028 - 0x0028)
class UGeometryScriptLibrary_BoxFunctions final : public UBlueprintFunctionLibrary
{
public:
	static struct FBox FindBoxBoxIntersection(const struct FBox& Box1, const struct FBox& Box2, bool* bIsIntersecting);
	static struct FVector FindClosestPointOnBox(const struct FBox& Box, const struct FVector& Point, bool* bIsInside);
	static double GetBoxBoxDistance(const struct FBox& Box1, const struct FBox& Box2);
	static void GetBoxCenterSize(const struct FBox& Box, struct FVector* Center, struct FVector* Dimensions);
	static struct FVector GetBoxCorner(const struct FBox& Box, int32 CornerIndex);
	static struct FVector GetBoxFaceCenter(const struct FBox& Box, int32 FaceIndex, struct FVector* FaceNormal);
	static double GetBoxPointDistance(const struct FBox& Box, const struct FVector& Point);
	static void GetBoxVolumeArea(const struct FBox& Box, double* Volume, double* SurfaceArea);
	static struct FBox GetExpandedBox(const struct FBox& Box, const struct FVector& ExpandBy);
	static struct FBox GetTransformedBox(const struct FBox& Box, const struct FTransform& Transform);
	static struct FBox MakeBoxFromCenterExtents(const struct FVector& Center, const struct FVector& Extents);
	static struct FBox MakeBoxFromCenterSize(const struct FVector& Center, const struct FVector& Dimensions);
	static bool TestBoxBoxIntersection(const struct FBox& Box1, const struct FBox& Box2);
	static bool TestBoxSphereIntersection(const struct FBox& Box, const struct FVector& SphereCenter, double SphereRadius);
	static bool TestPointInsideBox(const struct FBox& Box, const struct FVector& Point, bool bConsiderOnBoxAsInside);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GeometryScriptLibrary_BoxFunctions">();
	}
	static class UGeometryScriptLibrary_BoxFunctions* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGeometryScriptLibrary_BoxFunctions>();
	}
};
static_assert(alignof(UGeometryScriptLibrary_BoxFunctions) == 0x000008, "Wrong alignment on UGeometryScriptLibrary_BoxFunctions");
static_assert(sizeof(UGeometryScriptLibrary_BoxFunctions) == 0x000028, "Wrong size on UGeometryScriptLibrary_BoxFunctions");

// Class GeometryScriptingCore.GeometryScriptLibrary_TextureMapFunctions
// 0x0000 (0x0028 - 0x0028)
class UGeometryScriptLibrary_TextureMapFunctions final : public UBlueprintFunctionLibrary
{
public:
	static void SampleTexture2DAtUVPositions(const struct FGeometryScriptUVList& UVList, class UTexture2D* Texture, const struct FGeometryScriptSampleTextureOptions& SampleOptions, struct FGeometryScriptColorList* ColorList, class UGeometryScriptDebug* Debug);
	static void SampleTextureRenderTarget2DAtUVPositions(const struct FGeometryScriptUVList& UVList, class UTextureRenderTarget2D* Texture, const struct FGeometryScriptSampleTextureOptions& SampleOptions, struct FGeometryScriptColorList* ColorList, class UGeometryScriptDebug* Debug);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GeometryScriptLibrary_TextureMapFunctions">();
	}
	static class UGeometryScriptLibrary_TextureMapFunctions* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGeometryScriptLibrary_TextureMapFunctions>();
	}
};
static_assert(alignof(UGeometryScriptLibrary_TextureMapFunctions) == 0x000008, "Wrong alignment on UGeometryScriptLibrary_TextureMapFunctions");
static_assert(sizeof(UGeometryScriptLibrary_TextureMapFunctions) == 0x000028, "Wrong size on UGeometryScriptLibrary_TextureMapFunctions");

// Class GeometryScriptingCore.GeometryScriptLibrary_VectorMathFunctions
// 0x0000 (0x0028 - 0x0028)
class UGeometryScriptLibrary_VectorMathFunctions final : public UBlueprintFunctionLibrary
{
public:
	static struct FGeometryScriptScalarList ConstantScalarMultiply(double Constant, const struct FGeometryScriptScalarList& ScalarList);
	static void ConstantScalarMultiplyInPlace(double Constant, struct FGeometryScriptScalarList& ScalarList);
	static struct FGeometryScriptVectorList ConstantVectorMultiply(double Constant, const struct FGeometryScriptVectorList& VectorList);
	static void ConstantVectorMultiplyInPlace(double Constant, struct FGeometryScriptVectorList& VectorList);
	static struct FGeometryScriptScalarList ScalarBlend(const struct FGeometryScriptScalarList& ScalarListA, const struct FGeometryScriptScalarList& ScalarListB, double ConstantA, double ConstantB);
	static void ScalarBlendInPlace(const struct FGeometryScriptScalarList& ScalarListA, struct FGeometryScriptScalarList& ScalarListB, double ConstantA, double ConstantB);
	static struct FGeometryScriptScalarList ScalarInvert(const struct FGeometryScriptScalarList& ScalarList, double Numerator, double SetOnFailure, double Epsilon);
	static void ScalarInvertInPlace(struct FGeometryScriptScalarList& ScalarList, double Numerator, double SetOnFailure, double Epsilon);
	static struct FGeometryScriptScalarList ScalarMultiply(const struct FGeometryScriptScalarList& ScalarListA, const struct FGeometryScriptScalarList& ScalarListB, double ConstantMultiplier);
	static void ScalarMultiplyInPlace(const struct FGeometryScriptScalarList& ScalarListA, struct FGeometryScriptScalarList& ScalarListB, double ConstantMultiplier);
	static struct FGeometryScriptVectorList ScalarVectorMultiply(const struct FGeometryScriptScalarList& ScalarList, const struct FGeometryScriptVectorList& VectorList, double ScalarMultiplier);
	static void ScalarVectorMultiplyInPlace(const struct FGeometryScriptScalarList& ScalarList, struct FGeometryScriptVectorList& VectorList, double ScalarMultiplier);
	static struct FGeometryScriptVectorList VectorBlend(const struct FGeometryScriptVectorList& VectorListA, const struct FGeometryScriptVectorList& VectorListB, double ConstantA, double ConstantB);
	static void VectorBlendInPlace(const struct FGeometryScriptVectorList& VectorListA, struct FGeometryScriptVectorList& VectorListB, double ConstantA, double ConstantB);
	static struct FGeometryScriptVectorList VectorCross(const struct FGeometryScriptVectorList& VectorListA, const struct FGeometryScriptVectorList& VectorListB);
	static struct FGeometryScriptScalarList VectorDot(const struct FGeometryScriptVectorList& VectorListA, const struct FGeometryScriptVectorList& VectorListB);
	static struct FGeometryScriptScalarList VectorLength(const struct FGeometryScriptVectorList& VectorList);
	static void VectorNormalizeInPlace(struct FGeometryScriptVectorList& VectorList, const struct FVector& SetOnFailure);
	static struct FGeometryScriptScalarList VectorToScalar(const struct FGeometryScriptVectorList& VectorList, double ConstantX, double ConstantY, double ConstantZ);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GeometryScriptLibrary_VectorMathFunctions">();
	}
	static class UGeometryScriptLibrary_VectorMathFunctions* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGeometryScriptLibrary_VectorMathFunctions>();
	}
};
static_assert(alignof(UGeometryScriptLibrary_VectorMathFunctions) == 0x000008, "Wrong alignment on UGeometryScriptLibrary_VectorMathFunctions");
static_assert(sizeof(UGeometryScriptLibrary_VectorMathFunctions) == 0x000028, "Wrong size on UGeometryScriptLibrary_VectorMathFunctions");

}

