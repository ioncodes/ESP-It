#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: B_GameState

#include "Basic.hpp"

#include "B_GameState_classes.hpp"
#include "B_GameState_parameters.hpp"


namespace SDK
{

// Function B_GameState.B_GameState_C.OnMatchStarted__DelegateSignature
// (Public, Delegate, BlueprintCallable, BlueprintEvent)

void AB_GameState_C::OnMatchStarted__DelegateSignature()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_GameState_C", "OnMatchStarted__DelegateSignature");

	UObject::ProcessEvent(Func, nullptr);
}


// Function B_GameState.B_GameState_C.HasRoundStarted
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    RoundHasStarted                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AB_GameState_C::HasRoundStarted(bool* RoundHasStarted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_GameState_C", "HasRoundStarted");

	Params::B_GameState_C_HasRoundStarted Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (RoundHasStarted != nullptr)
		*RoundHasStarted = Parms.RoundHasStarted;
}


// Function B_GameState.B_GameState_C.HasTrackingStarted
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    Param_HasTrackingStarted                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AB_GameState_C::HasTrackingStarted(bool* Param_HasTrackingStarted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_GameState_C", "HasTrackingStarted");

	Params::B_GameState_C_HasTrackingStarted Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Param_HasTrackingStarted != nullptr)
		*Param_HasTrackingStarted = Parms.Param_HasTrackingStarted;
}


// Function B_GameState.B_GameState_C.IsPhysicsEnabled
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool AB_GameState_C::IsPhysicsEnabled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_GameState_C", "IsPhysicsEnabled");

	Params::B_GameState_C_IsPhysicsEnabled Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function B_GameState.B_GameState_C.IsRoundEnd
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    RoundIsEnd                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AB_GameState_C::IsRoundEnd(bool* RoundIsEnd)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_GameState_C", "IsRoundEnd");

	Params::B_GameState_C_IsRoundEnd Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (RoundIsEnd != nullptr)
		*RoundIsEnd = Parms.RoundIsEnd;
}


// Function B_GameState.B_GameState_C.SetIdleKickEnabled
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bIsEnabled                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AB_GameState_C::SetIdleKickEnabled(bool bIsEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_GameState_C", "SetIdleKickEnabled");

	Params::B_GameState_C_SetIdleKickEnabled Parms{};

	Parms.bIsEnabled = bIsEnabled;

	UObject::ProcessEvent(Func, &Parms);
}


// Function B_GameState.B_GameState_C.ResetAllRules
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void AB_GameState_C::ResetAllRules()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_GameState_C", "ResetAllRules");

	UObject::ProcessEvent(Func, nullptr);
}


// Function B_GameState.B_GameState_C.UpdatePowerupRules
// (Public, BlueprintCallable, BlueprintEvent)

void AB_GameState_C::UpdatePowerupRules()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_GameState_C", "UpdatePowerupRules");

	UObject::ProcessEvent(Func, nullptr);
}


// Function B_GameState.B_GameState_C.GetUnlistedSkills
// (Protected, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// TArray<class UClass*>                   Unlisted_Skills                                        (Parm, OutParm)

void AB_GameState_C::GetUnlistedSkills(TArray<class UClass*>* Unlisted_Skills)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_GameState_C", "GetUnlistedSkills");

	Params::B_GameState_C_GetUnlistedSkills Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Unlisted_Skills != nullptr)
		*Unlisted_Skills = std::move(Parms.Unlisted_Skills);
}


// Function B_GameState.B_GameState_C.OnRep_PowerupRules
// (BlueprintCallable, BlueprintEvent)

void AB_GameState_C::OnRep_PowerupRules()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_GameState_C", "OnRep_PowerupRules");

	UObject::ProcessEvent(Func, nullptr);
}


// Function B_GameState.B_GameState_C.OnRep_GameModifiers
// (BlueprintCallable, BlueprintEvent)

void AB_GameState_C::OnRep_GameModifiers()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_GameState_C", "OnRep_GameModifiers");

	UObject::ProcessEvent(Func, nullptr);
}


// Function B_GameState.B_GameState_C.OnRep_MatchRules
// (BlueprintCallable, BlueprintEvent)

void AB_GameState_C::OnRep_MatchRules()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_GameState_C", "OnRep_MatchRules");

	UObject::ProcessEvent(Func, nullptr);
}


// Function B_GameState.B_GameState_C.OnRep_SkillRules
// (BlueprintCallable, BlueprintEvent)

void AB_GameState_C::OnRep_SkillRules()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_GameState_C", "OnRep_SkillRules");

	UObject::ProcessEvent(Func, nullptr);
}


// Function B_GameState.B_GameState_C.UpdateModRules
// (Public, BlueprintCallable, BlueprintEvent)

void AB_GameState_C::UpdateModRules()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_GameState_C", "UpdateModRules");

	UObject::ProcessEvent(Func, nullptr);
}


// Function B_GameState.B_GameState_C.UpdateMatchRules
// (Public, BlueprintCallable, BlueprintEvent)

void AB_GameState_C::UpdateMatchRules()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_GameState_C", "UpdateMatchRules");

	UObject::ProcessEvent(Func, nullptr);
}


// Function B_GameState.B_GameState_C.UpdateSkillRules
// (Public, BlueprintCallable, BlueprintEvent)

void AB_GameState_C::UpdateSkillRules()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_GameState_C", "UpdateSkillRules");

	UObject::ProcessEvent(Func, nullptr);
}


// Function B_GameState.B_GameState_C.InitializeGameRules
// (Public, BlueprintCallable, BlueprintEvent)

void AB_GameState_C::InitializeGameRules()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_GameState_C", "InitializeGameRules");

	UObject::ProcessEvent(Func, nullptr);
}


// Function B_GameState.B_GameState_C.GetPlayerStateById
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class FString                           NetId                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, HasGetValueTypeHash)
// class AB_PlayerState_C*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash)

class AB_PlayerState_C* AB_GameState_C::GetPlayerStateById(const class FString& NetId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_GameState_C", "GetPlayerStateById");

	Params::B_GameState_C_GetPlayerStateById Parms{};

	Parms.NetId = std::move(NetId);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function B_GameState.B_GameState_C.InitializeTournamentPlayers
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<class FString>                   PlayerIds                                              (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// TArray<struct FS_TournamentPlayer>      Param_TournamentPlayers                                (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)

void AB_GameState_C::InitializeTournamentPlayers(TArray<class FString>& PlayerIds, TArray<struct FS_TournamentPlayer>& Param_TournamentPlayers)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_GameState_C", "InitializeTournamentPlayers");

	Params::B_GameState_C_InitializeTournamentPlayers Parms{};

	Parms.PlayerIds = std::move(PlayerIds);
	Parms.Param_TournamentPlayers = std::move(Param_TournamentPlayers);

	UObject::ProcessEvent(Func, &Parms);

	PlayerIds = std::move(Parms.PlayerIds);
	Param_TournamentPlayers = std::move(Parms.Param_TournamentPlayers);
}


// Function B_GameState.B_GameState_C.ShouldTeamVoiceBeEnabled
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool AB_GameState_C::ShouldTeamVoiceBeEnabled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_GameState_C", "ShouldTeamVoiceBeEnabled");

	Params::B_GameState_C_ShouldTeamVoiceBeEnabled Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function B_GameState.B_GameState_C.TeamCheck
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class APlayerState*                     PlayerStateA                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class APlayerState*                     PlayerStateB                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool                                    bSameTeam                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AB_GameState_C::TeamCheck(class APlayerState* PlayerStateA, class APlayerState* PlayerStateB, bool* bSameTeam)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_GameState_C", "TeamCheck");

	Params::B_GameState_C_TeamCheck Parms{};

	Parms.PlayerStateA = PlayerStateA;
	Parms.PlayerStateB = PlayerStateB;

	UObject::ProcessEvent(Func, &Parms);

	if (bSameTeam != nullptr)
		*bSameTeam = Parms.bSameTeam;
}


// Function B_GameState.B_GameState_C.InitializeGameName
// (Public, BlueprintCallable, BlueprintEvent)

void AB_GameState_C::InitializeGameName()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_GameState_C", "InitializeGameName");

	UObject::ProcessEvent(Func, nullptr);
}


// Function B_GameState.B_GameState_C.OnRep_PlayerNameToKick
// (BlueprintCallable, BlueprintEvent)

void AB_GameState_C::OnRep_PlayerNameToKick()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_GameState_C", "OnRep_PlayerNameToKick");

	UObject::ProcessEvent(Func, nullptr);
}


// Function B_GameState.B_GameState_C.UnregisterHunterActor
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           HunterActor                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void AB_GameState_C::UnregisterHunterActor(class AActor* HunterActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_GameState_C", "UnregisterHunterActor");

	Params::B_GameState_C_UnregisterHunterActor Parms{};

	Parms.HunterActor = HunterActor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function B_GameState.B_GameState_C.RegisterHunterActor
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           HunterActor                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void AB_GameState_C::RegisterHunterActor(class AActor* HunterActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_GameState_C", "RegisterHunterActor");

	Params::B_GameState_C_RegisterHunterActor Parms{};

	Parms.HunterActor = HunterActor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function B_GameState.B_GameState_C.UnregisterWitchActor
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           WitchActor                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void AB_GameState_C::UnregisterWitchActor(class AActor* WitchActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_GameState_C", "UnregisterWitchActor");

	Params::B_GameState_C_UnregisterWitchActor Parms{};

	Parms.WitchActor = WitchActor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function B_GameState.B_GameState_C.RegisterWitchActor
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           WitchActor                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void AB_GameState_C::RegisterWitchActor(class AActor* WitchActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_GameState_C", "RegisterWitchActor");

	Params::B_GameState_C_RegisterWitchActor Parms{};

	Parms.WitchActor = WitchActor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function B_GameState.B_GameState_C.TickCollectedPropsForWake
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void AB_GameState_C::TickCollectedPropsForWake()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_GameState_C", "TickCollectedPropsForWake");

	UObject::ProcessEvent(Func, nullptr);
}


// Function B_GameState.B_GameState_C.CollectAllSleepingProps
// (Public, BlueprintCallable, BlueprintEvent)

void AB_GameState_C::CollectAllSleepingProps()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_GameState_C", "CollectAllSleepingProps");

	UObject::ProcessEvent(Func, nullptr);
}


// Function B_GameState.B_GameState_C.TickCollectedPropsForSleep
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void AB_GameState_C::TickCollectedPropsForSleep()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_GameState_C", "TickCollectedPropsForSleep");

	UObject::ProcessEvent(Func, nullptr);
}


// Function B_GameState.B_GameState_C.SendChatMessageMulticast
// (Net, NetReliable, NetMulticast, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FText                             ChatMessage                                            (BlueprintVisible, BlueprintReadOnly, Parm)
// class AB_PlayerState_C*                 Player                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// EChatType                               ChatType                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AB_GameState_C::SendChatMessageMulticast(const class FText& ChatMessage, class AB_PlayerState_C* Player, EChatType ChatType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_GameState_C", "SendChatMessageMulticast");

	Params::B_GameState_C_SendChatMessageMulticast Parms{};

	Parms.ChatMessage = std::move(ChatMessage);
	Parms.Player = Player;
	Parms.ChatType = ChatType;

	UObject::ProcessEvent(Func, &Parms);
}


// Function B_GameState.B_GameState_C.ReceiveBeginPlay
// (Event, Protected, BlueprintEvent)

void AB_GameState_C::ReceiveBeginPlay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_GameState_C", "ReceiveBeginPlay");

	UObject::ProcessEvent(Func, nullptr);
}


// Function B_GameState.B_GameState_C.SendGameMessageMulticast
// (Net, NetReliable, NetMulticast, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FText                             SourcePlayerName                                       (BlueprintVisible, BlueprintReadOnly, Parm)
// class FText                             TargetPlayerName                                       (BlueprintVisible, BlueprintReadOnly, Parm)
// EGameMessageType                        MessageType                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AB_GameState_C::SendGameMessageMulticast(const class FText& SourcePlayerName, const class FText& TargetPlayerName, EGameMessageType MessageType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_GameState_C", "SendGameMessageMulticast");

	Params::B_GameState_C_SendGameMessageMulticast Parms{};

	Parms.SourcePlayerName = std::move(SourcePlayerName);
	Parms.TargetPlayerName = std::move(TargetPlayerName);
	Parms.MessageType = MessageType;

	UObject::ProcessEvent(Func, &Parms);
}


// Function B_GameState.B_GameState_C.PutPropsToSleep
// (Net, NetReliable, NetMulticast, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<class AActor*>                   Actors                                                 (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// TArray<struct FVector>                  SleepLocation                                          (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// TArray<struct FRotator>                 SleepRotation                                          (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)

void AB_GameState_C::PutPropsToSleep(const TArray<class AActor*>& Actors, const TArray<struct FVector>& SleepLocation, const TArray<struct FRotator>& SleepRotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_GameState_C", "PutPropsToSleep");

	Params::B_GameState_C_PutPropsToSleep Parms{};

	Parms.Actors = std::move(Actors);
	Parms.SleepLocation = std::move(SleepLocation);
	Parms.SleepRotation = std::move(SleepRotation);

	UObject::ProcessEvent(Func, &Parms);
}


// Function B_GameState.B_GameState_C.ReceiveTick
// (Event, Public, BlueprintEvent)
// Parameters:
// float                                   DeltaSeconds                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AB_GameState_C::ReceiveTick(float DeltaSeconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_GameState_C", "ReceiveTick");

	Params::B_GameState_C_ReceiveTick Parms{};

	Parms.DeltaSeconds = DeltaSeconds;

	UObject::ProcessEvent(Func, &Parms);
}


// Function B_GameState.B_GameState_C.PutPropsToWake
// (Net, NetReliable, NetMulticast, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<class AActor*>                   Actors                                                 (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)

void AB_GameState_C::PutPropsToWake(const TArray<class AActor*>& Actors)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_GameState_C", "PutPropsToWake");

	Params::B_GameState_C_PutPropsToWake Parms{};

	Parms.Actors = std::move(Actors);

	UObject::ProcessEvent(Func, &Parms);
}


// Function B_GameState.B_GameState_C.CollectSleepProp
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           Actor                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void AB_GameState_C::CollectSleepProp(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_GameState_C", "CollectSleepProp");

	Params::B_GameState_C_CollectSleepProp Parms{};

	Parms.Actor = Actor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function B_GameState.B_GameState_C.CollectWakeProp
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           Actor                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void AB_GameState_C::CollectWakeProp(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_GameState_C", "CollectWakeProp");

	Params::B_GameState_C_CollectWakeProp Parms{};

	Parms.Actor = Actor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function B_GameState.B_GameState_C.AddSleepProp
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           Actor                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void AB_GameState_C::AddSleepProp(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_GameState_C", "AddSleepProp");

	Params::B_GameState_C_AddSleepProp Parms{};

	Parms.Actor = Actor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function B_GameState.B_GameState_C.RemoveSleepProp
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           Actor                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void AB_GameState_C::RemoveSleepProp(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_GameState_C", "RemoveSleepProp");

	Params::B_GameState_C_RemoveSleepProp Parms{};

	Parms.Actor = Actor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function B_GameState.B_GameState_C.StartKickVote
// (Net, NetReliable, NetMulticast, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             Param_PlayerNameToKick                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class FText                             Param_ReasonToKick                                     (BlueprintVisible, BlueprintReadOnly, Parm)
// class FName                             Param_PlayerNameStartedKickVote                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AB_GameState_C::StartKickVote(class FName Param_PlayerNameToKick, const class FText& Param_ReasonToKick, class FName Param_PlayerNameStartedKickVote)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_GameState_C", "StartKickVote");

	Params::B_GameState_C_StartKickVote Parms{};

	Parms.Param_PlayerNameToKick = Param_PlayerNameToKick;
	Parms.Param_ReasonToKick = std::move(Param_ReasonToKick);
	Parms.Param_PlayerNameStartedKickVote = Param_PlayerNameStartedKickVote;

	UObject::ProcessEvent(Func, &Parms);
}


// Function B_GameState.B_GameState_C.EndKickVote
// (Net, NetReliable, NetMulticast, BlueprintCallable, BlueprintEvent)

void AB_GameState_C::EndKickVote()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_GameState_C", "EndKickVote");

	UObject::ProcessEvent(Func, nullptr);
}


// Function B_GameState.B_GameState_C.OnPlayerJoinedMulti
// (Net, NetReliable, NetMulticast, BlueprintCallable, BlueprintEvent)
// Parameters:
// class APlayerState*                     PlayerState                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void AB_GameState_C::OnPlayerJoinedMulti(class APlayerState* PlayerState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_GameState_C", "OnPlayerJoinedMulti");

	Params::B_GameState_C_OnPlayerJoinedMulti Parms{};

	Parms.PlayerState = PlayerState;

	UObject::ProcessEvent(Func, &Parms);
}


// Function B_GameState.B_GameState_C.OnMatchStartedMulti
// (Net, NetReliable, NetMulticast, BlueprintCallable, BlueprintEvent)

void AB_GameState_C::OnMatchStartedMulti()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_GameState_C", "OnMatchStartedMulti");

	UObject::ProcessEvent(Func, nullptr);
}


// Function B_GameState.B_GameState_C.OnMatchEndedMulti
// (Net, NetReliable, NetMulticast, BlueprintCallable, BlueprintEvent)

void AB_GameState_C::OnMatchEndedMulti()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_GameState_C", "OnMatchEndedMulti");

	UObject::ProcessEvent(Func, nullptr);
}


// Function B_GameState.B_GameState_C.OnPlayerChangedTeamServer
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)

void AB_GameState_C::OnPlayerChangedTeamServer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_GameState_C", "OnPlayerChangedTeamServer");

	UObject::ProcessEvent(Func, nullptr);
}


// Function B_GameState.B_GameState_C.OnPlayerChangedTeamMulti
// (Net, NetReliable, NetMulticast, BlueprintCallable, BlueprintEvent)

void AB_GameState_C::OnPlayerChangedTeamMulti()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_GameState_C", "OnPlayerChangedTeamMulti");

	UObject::ProcessEvent(Func, nullptr);
}


// Function B_GameState.B_GameState_C.OnPlayerLeftMulti
// (Net, NetReliable, NetMulticast, BlueprintCallable, BlueprintEvent)
// Parameters:
// class APlayerState*                     PlayerState                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void AB_GameState_C::OnPlayerLeftMulti(class APlayerState* PlayerState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_GameState_C", "OnPlayerLeftMulti");

	Params::B_GameState_C_OnPlayerLeftMulti Parms{};

	Parms.PlayerState = PlayerState;

	UObject::ProcessEvent(Func, &Parms);
}


// Function B_GameState.B_GameState_C.SendTournamentScoresMulti
// (Net, NetReliable, NetMulticast, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<class FString>                   PlayerNames                                            (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// TArray<int32>                           Scores                                                 (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)

void AB_GameState_C::SendTournamentScoresMulti(const TArray<class FString>& PlayerNames, const TArray<int32>& Scores)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_GameState_C", "SendTournamentScoresMulti");

	Params::B_GameState_C_SendTournamentScoresMulti Parms{};

	Parms.PlayerNames = std::move(PlayerNames);
	Parms.Scores = std::move(Scores);

	UObject::ProcessEvent(Func, &Parms);
}


// Function B_GameState.B_GameState_C.InitializeTournamentPlayersMulti
// (Net, NetReliable, NetMulticast, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<class FString>                   PlayerIds                                              (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// TArray<struct FS_TournamentPlayer>      Param_TournamentPlayers                                (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)

void AB_GameState_C::InitializeTournamentPlayersMulti(const TArray<class FString>& PlayerIds, const TArray<struct FS_TournamentPlayer>& Param_TournamentPlayers)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_GameState_C", "InitializeTournamentPlayersMulti");

	Params::B_GameState_C_InitializeTournamentPlayersMulti Parms{};

	Parms.PlayerIds = std::move(PlayerIds);
	Parms.Param_TournamentPlayers = std::move(Param_TournamentPlayers);

	UObject::ProcessEvent(Func, &Parms);
}


// Function B_GameState.B_GameState_C.UpdateTournamentPlayerScoreMulti
// (Net, NetReliable, NetMulticast, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FString                           PlayerId                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, HasGetValueTypeHash)
// int32                                   NewScore                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AB_GameState_C::UpdateTournamentPlayerScoreMulti(const class FString& PlayerId, int32 NewScore)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_GameState_C", "UpdateTournamentPlayerScoreMulti");

	Params::B_GameState_C_UpdateTournamentPlayerScoreMulti Parms{};

	Parms.PlayerId = std::move(PlayerId);
	Parms.NewScore = NewScore;

	UObject::ProcessEvent(Func, &Parms);
}


// Function B_GameState.B_GameState_C.SkillsUpdated
// (BlueprintCallable, BlueprintEvent)

void AB_GameState_C::SkillsUpdated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_GameState_C", "SkillsUpdated");

	UObject::ProcessEvent(Func, nullptr);
}


// Function B_GameState.B_GameState_C.ExecuteUbergraph_B_GameState
// (Final, UbergraphFunction, HasDefaults)
// Parameters:
// int32                                   EntryPoint                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AB_GameState_C::ExecuteUbergraph_B_GameState(int32 EntryPoint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_GameState_C", "ExecuteUbergraph_B_GameState");

	Params::B_GameState_C_ExecuteUbergraph_B_GameState Parms{};

	Parms.EntryPoint = EntryPoint;

	UObject::ProcessEvent(Func, &Parms);
}


// Function B_GameState.B_GameState_C.IsIdleKickEnabled
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// bool                                    bIsEnabled                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AB_GameState_C::IsIdleKickEnabled(bool* bIsEnabled) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_GameState_C", "IsIdleKickEnabled");

	Params::B_GameState_C_IsIdleKickEnabled Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (bIsEnabled != nullptr)
		*bIsEnabled = Parms.bIsEnabled;
}

}

