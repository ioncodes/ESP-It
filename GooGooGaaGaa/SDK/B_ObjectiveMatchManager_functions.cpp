#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: B_ObjectiveMatchManager

#include "Basic.hpp"

#include "B_ObjectiveMatchManager_classes.hpp"
#include "B_ObjectiveMatchManager_parameters.hpp"


namespace SDK
{

// Function B_ObjectiveMatchManager.B_ObjectiveMatchManager_C.AddPlayerWithId
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FString                           PlayerId                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, HasGetValueTypeHash)
// class UB_ObjectiveMatchPlayerState_C*   ObjectiveMatchPlayerState                              (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UB_ObjectiveMatchManager_C::AddPlayerWithId(const class FString& PlayerId, class UB_ObjectiveMatchPlayerState_C** ObjectiveMatchPlayerState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_ObjectiveMatchManager_C", "AddPlayerWithId");

	Params::B_ObjectiveMatchManager_C_AddPlayerWithId Parms{};

	Parms.PlayerId = std::move(PlayerId);

	UObject::ProcessEvent(Func, &Parms);

	if (ObjectiveMatchPlayerState != nullptr)
		*ObjectiveMatchPlayerState = Parms.ObjectiveMatchPlayerState;
}


// Function B_ObjectiveMatchManager.B_ObjectiveMatchManager_C.AddRoundState
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UB_ObjectiveRoundState_C*         RoundState                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UB_ObjectiveMatchManager_C::AddRoundState(class UB_ObjectiveRoundState_C* RoundState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_ObjectiveMatchManager_C", "AddRoundState");

	Params::B_ObjectiveMatchManager_C_AddRoundState Parms{};

	Parms.RoundState = RoundState;

	UObject::ProcessEvent(Func, &Parms);
}


// Function B_ObjectiveMatchManager.B_ObjectiveMatchManager_C.AddTeamWin
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// E_ObjectiveTeam                         Team                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UB_ObjectiveMatchManager_C::AddTeamWin(E_ObjectiveTeam Team)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_ObjectiveMatchManager_C", "AddTeamWin");

	Params::B_ObjectiveMatchManager_C_AddTeamWin Parms{};

	Parms.Team = Team;

	UObject::ProcessEvent(Func, &Parms);
}


// Function B_ObjectiveMatchManager.B_ObjectiveMatchManager_C.CanTeamSurrender
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// ETeamID                                 TeamToSurrender                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class AB_GameState_C*                   GameState                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool                                    CanSurrender                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UB_ObjectiveMatchManager_C::CanTeamSurrender(ETeamID TeamToSurrender, class AB_GameState_C* GameState, bool* CanSurrender)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_ObjectiveMatchManager_C", "CanTeamSurrender");

	Params::B_ObjectiveMatchManager_C_CanTeamSurrender Parms{};

	Parms.TeamToSurrender = TeamToSurrender;
	Parms.GameState = GameState;

	UObject::ProcessEvent(Func, &Parms);

	if (CanSurrender != nullptr)
		*CanSurrender = Parms.CanSurrender;
}


// Function B_ObjectiveMatchManager.B_ObjectiveMatchManager_C.GetIntactTeam
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class AB_GameState_C*                   GameState                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// E_ObjectiveTeam                         Team                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UB_ObjectiveMatchManager_C::GetIntactTeam(class AB_GameState_C* GameState, E_ObjectiveTeam* Team)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_ObjectiveMatchManager_C", "GetIntactTeam");

	Params::B_ObjectiveMatchManager_C_GetIntactTeam Parms{};

	Parms.GameState = GameState;

	UObject::ProcessEvent(Func, &Parms);

	if (Team != nullptr)
		*Team = Parms.Team;
}


// Function B_ObjectiveMatchManager.B_ObjectiveMatchManager_C.GetObjectiveMatchPlayerState
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class APlayerState*                     PlayerState                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class UB_ObjectiveMatchPlayerState_C*   ObjectiveMatchPlayerState                              (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UB_ObjectiveMatchManager_C::GetObjectiveMatchPlayerState(class APlayerState* PlayerState, class UB_ObjectiveMatchPlayerState_C** ObjectiveMatchPlayerState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_ObjectiveMatchManager_C", "GetObjectiveMatchPlayerState");

	Params::B_ObjectiveMatchManager_C_GetObjectiveMatchPlayerState Parms{};

	Parms.PlayerState = PlayerState;

	UObject::ProcessEvent(Func, &Parms);

	if (ObjectiveMatchPlayerState != nullptr)
		*ObjectiveMatchPlayerState = Parms.ObjectiveMatchPlayerState;
}


// Function B_ObjectiveMatchManager.B_ObjectiveMatchManager_C.GetRoundStatesSortedByTeam
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// TArray<class UB_ObjectiveRoundState_C*> RoundStatesSortedByTeam                                (Parm, OutParm)

void UB_ObjectiveMatchManager_C::GetRoundStatesSortedByTeam(TArray<class UB_ObjectiveRoundState_C*>* RoundStatesSortedByTeam)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_ObjectiveMatchManager_C", "GetRoundStatesSortedByTeam");

	Params::B_ObjectiveMatchManager_C_GetRoundStatesSortedByTeam Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (RoundStatesSortedByTeam != nullptr)
		*RoundStatesSortedByTeam = std::move(Parms.RoundStatesSortedByTeam);
}


// Function B_ObjectiveMatchManager.B_ObjectiveMatchManager_C.GetWinnerForRound
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    FirstRound                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// E_ObjectiveTeam                         WinnerTeam                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UB_ObjectiveMatchManager_C::GetWinnerForRound(bool FirstRound, E_ObjectiveTeam* WinnerTeam)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_ObjectiveMatchManager_C", "GetWinnerForRound");

	Params::B_ObjectiveMatchManager_C_GetWinnerForRound Parms{};

	Parms.FirstRound = FirstRound;

	UObject::ProcessEvent(Func, &Parms);

	if (WinnerTeam != nullptr)
		*WinnerTeam = Parms.WinnerTeam;
}


// Function B_ObjectiveMatchManager.B_ObjectiveMatchManager_C.GetWinnerTeam
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class AB_GameState_C*                   GameState                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// E_ObjectiveTeam                         WinnerTeam                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   ReasonIndex                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UB_ObjectiveMatchManager_C::GetWinnerTeam(class AB_GameState_C* GameState, E_ObjectiveTeam* WinnerTeam, int32* ReasonIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_ObjectiveMatchManager_C", "GetWinnerTeam");

	Params::B_ObjectiveMatchManager_C_GetWinnerTeam Parms{};

	Parms.GameState = GameState;

	UObject::ProcessEvent(Func, &Parms);

	if (WinnerTeam != nullptr)
		*WinnerTeam = Parms.WinnerTeam;

	if (ReasonIndex != nullptr)
		*ReasonIndex = Parms.ReasonIndex;
}


// Function B_ObjectiveMatchManager.B_ObjectiveMatchManager_C.IsMatchDead
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class AB_GameState_C*                   GameState                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool                                    IsMatchDead_0                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UB_ObjectiveMatchManager_C::IsMatchDead(class AB_GameState_C* GameState, bool* IsMatchDead_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_ObjectiveMatchManager_C", "IsMatchDead");

	Params::B_ObjectiveMatchManager_C_IsMatchDead Parms{};

	Parms.GameState = GameState;

	UObject::ProcessEvent(Func, &Parms);

	if (IsMatchDead_0 != nullptr)
		*IsMatchDead_0 = Parms.IsMatchDead_0;
}


// Function B_ObjectiveMatchManager.B_ObjectiveMatchManager_C.IsMatchIntact
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class AB_GameState_C*                   GameState                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool                                    EnoughPlayerConnected                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UB_ObjectiveMatchManager_C::IsMatchIntact(class AB_GameState_C* GameState, bool* EnoughPlayerConnected)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_ObjectiveMatchManager_C", "IsMatchIntact");

	Params::B_ObjectiveMatchManager_C_IsMatchIntact Parms{};

	Parms.GameState = GameState;

	UObject::ProcessEvent(Func, &Parms);

	if (EnoughPlayerConnected != nullptr)
		*EnoughPlayerConnected = Parms.EnoughPlayerConnected;
}


// Function B_ObjectiveMatchManager.B_ObjectiveMatchManager_C.IsPlayerInMatch
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class APlayerState*                     PlayerState                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool                                    IsInMatch                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UB_ObjectiveMatchManager_C::IsPlayerInMatch(class APlayerState* PlayerState, bool* IsInMatch)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_ObjectiveMatchManager_C", "IsPlayerInMatch");

	Params::B_ObjectiveMatchManager_C_IsPlayerInMatch Parms{};

	Parms.PlayerState = PlayerState;

	UObject::ProcessEvent(Func, &Parms);

	if (IsInMatch != nullptr)
		*IsInMatch = Parms.IsInMatch;
}


// Function B_ObjectiveMatchManager.B_ObjectiveMatchManager_C.PrintPlayerIds
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void UB_ObjectiveMatchManager_C::PrintPlayerIds()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_ObjectiveMatchManager_C", "PrintPlayerIds");

	UObject::ProcessEvent(Func, nullptr);
}


// Function B_ObjectiveMatchManager.B_ObjectiveMatchManager_C.RandomizeTeamAStartsAsWitch
// (Public, BlueprintCallable, BlueprintEvent)

void UB_ObjectiveMatchManager_C::RandomizeTeamAStartsAsWitch()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_ObjectiveMatchManager_C", "RandomizeTeamAStartsAsWitch");

	UObject::ProcessEvent(Func, nullptr);
}


// Function B_ObjectiveMatchManager.B_ObjectiveMatchManager_C.RemovePlayer
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class APlayerState*                     PlayerStateToRemove                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UB_ObjectiveMatchManager_C::RemovePlayer(class APlayerState* PlayerStateToRemove)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_ObjectiveMatchManager_C", "RemovePlayer");

	Params::B_ObjectiveMatchManager_C_RemovePlayer Parms{};

	Parms.PlayerStateToRemove = PlayerStateToRemove;

	UObject::ProcessEvent(Func, &Parms);
}


// Function B_ObjectiveMatchManager.B_ObjectiveMatchManager_C.RemovePlayerWhenMatchNotStarted
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class APlayerState*                     PlayerState                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UB_ObjectiveMatchManager_C::RemovePlayerWhenMatchNotStarted(class APlayerState* PlayerState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_ObjectiveMatchManager_C", "RemovePlayerWhenMatchNotStarted");

	Params::B_ObjectiveMatchManager_C_RemovePlayerWhenMatchNotStarted Parms{};

	Parms.PlayerState = PlayerState;

	UObject::ProcessEvent(Func, &Parms);
}


// Function B_ObjectiveMatchManager.B_ObjectiveMatchManager_C.TearDown
// (Public, BlueprintCallable, BlueprintEvent)

void UB_ObjectiveMatchManager_C::TearDown()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_ObjectiveMatchManager_C", "TearDown");

	UObject::ProcessEvent(Func, nullptr);
}

}

