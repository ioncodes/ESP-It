#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: LowEntryExtendedStandardLibrary

#include "Basic.hpp"

#include "Engine_classes.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "LowEntryExtendedStandardLibrary_structs.hpp"


namespace SDK
{

// Class LowEntryExtendedStandardLibrary.LowEntryBitDataEntry
// 0x00D8 (0x0100 - 0x0028)
class ULowEntryBitDataEntry final : public UObject
{
public:
	uint8                                         Type;                                              // 0x0028(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         ByteValue;                                         // 0x0029(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B97[0x2];                                     // 0x002A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         IntegerValue;                                      // 0x002C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         LongValue;                                         // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULowEntryLong*                          LongBytesValue;                                    // 0x0038(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FloatValue;                                        // 0x0040(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B98[0x4];                                     // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        DoubleValue;                                       // 0x0048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULowEntryDouble*                        DoubleBytesValue;                                  // 0x0050(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          BooleanValue;                                      // 0x0058(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B99[0x7];                                     // 0x0059(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 StringUtf8Value;                                   // 0x0060(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<uint8>                                 ByteArrayValue;                                    // 0x0070(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 IntegerArrayValue;                                 // 0x0080(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int64>                                 LongArrayValue;                                    // 0x0090(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class ULowEntryLong*>                  LongBytesArrayValue;                               // 0x00A0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<float>                                 FloatArrayValue;                                   // 0x00B0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<double>                                DoubleArrayValue;                                  // 0x00C0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class ULowEntryDouble*>                DoubleBytesArrayValue;                             // 0x00D0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<bool>                                  BooleanArrayValue;                                 // 0x00E0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FString>                         StringUtf8ArrayValue;                              // 0x00F0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LowEntryBitDataEntry">();
	}
	static class ULowEntryBitDataEntry* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULowEntryBitDataEntry>();
	}
};
static_assert(alignof(ULowEntryBitDataEntry) == 0x000008, "Wrong alignment on ULowEntryBitDataEntry");
static_assert(sizeof(ULowEntryBitDataEntry) == 0x000100, "Wrong size on ULowEntryBitDataEntry");
static_assert(offsetof(ULowEntryBitDataEntry, Type) == 0x000028, "Member 'ULowEntryBitDataEntry::Type' has a wrong offset!");
static_assert(offsetof(ULowEntryBitDataEntry, ByteValue) == 0x000029, "Member 'ULowEntryBitDataEntry::ByteValue' has a wrong offset!");
static_assert(offsetof(ULowEntryBitDataEntry, IntegerValue) == 0x00002C, "Member 'ULowEntryBitDataEntry::IntegerValue' has a wrong offset!");
static_assert(offsetof(ULowEntryBitDataEntry, LongValue) == 0x000030, "Member 'ULowEntryBitDataEntry::LongValue' has a wrong offset!");
static_assert(offsetof(ULowEntryBitDataEntry, LongBytesValue) == 0x000038, "Member 'ULowEntryBitDataEntry::LongBytesValue' has a wrong offset!");
static_assert(offsetof(ULowEntryBitDataEntry, FloatValue) == 0x000040, "Member 'ULowEntryBitDataEntry::FloatValue' has a wrong offset!");
static_assert(offsetof(ULowEntryBitDataEntry, DoubleValue) == 0x000048, "Member 'ULowEntryBitDataEntry::DoubleValue' has a wrong offset!");
static_assert(offsetof(ULowEntryBitDataEntry, DoubleBytesValue) == 0x000050, "Member 'ULowEntryBitDataEntry::DoubleBytesValue' has a wrong offset!");
static_assert(offsetof(ULowEntryBitDataEntry, BooleanValue) == 0x000058, "Member 'ULowEntryBitDataEntry::BooleanValue' has a wrong offset!");
static_assert(offsetof(ULowEntryBitDataEntry, StringUtf8Value) == 0x000060, "Member 'ULowEntryBitDataEntry::StringUtf8Value' has a wrong offset!");
static_assert(offsetof(ULowEntryBitDataEntry, ByteArrayValue) == 0x000070, "Member 'ULowEntryBitDataEntry::ByteArrayValue' has a wrong offset!");
static_assert(offsetof(ULowEntryBitDataEntry, IntegerArrayValue) == 0x000080, "Member 'ULowEntryBitDataEntry::IntegerArrayValue' has a wrong offset!");
static_assert(offsetof(ULowEntryBitDataEntry, LongArrayValue) == 0x000090, "Member 'ULowEntryBitDataEntry::LongArrayValue' has a wrong offset!");
static_assert(offsetof(ULowEntryBitDataEntry, LongBytesArrayValue) == 0x0000A0, "Member 'ULowEntryBitDataEntry::LongBytesArrayValue' has a wrong offset!");
static_assert(offsetof(ULowEntryBitDataEntry, FloatArrayValue) == 0x0000B0, "Member 'ULowEntryBitDataEntry::FloatArrayValue' has a wrong offset!");
static_assert(offsetof(ULowEntryBitDataEntry, DoubleArrayValue) == 0x0000C0, "Member 'ULowEntryBitDataEntry::DoubleArrayValue' has a wrong offset!");
static_assert(offsetof(ULowEntryBitDataEntry, DoubleBytesArrayValue) == 0x0000D0, "Member 'ULowEntryBitDataEntry::DoubleBytesArrayValue' has a wrong offset!");
static_assert(offsetof(ULowEntryBitDataEntry, BooleanArrayValue) == 0x0000E0, "Member 'ULowEntryBitDataEntry::BooleanArrayValue' has a wrong offset!");
static_assert(offsetof(ULowEntryBitDataEntry, StringUtf8ArrayValue) == 0x0000F0, "Member 'ULowEntryBitDataEntry::StringUtf8ArrayValue' has a wrong offset!");

// Class LowEntryExtendedStandardLibrary.LowEntryBitDataReader
// 0x0020 (0x0048 - 0x0028)
class ULowEntryBitDataReader final : public UObject
{
public:
	TArray<uint8>                                 Bytes;                                             // 0x0028(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         Position;                                          // 0x0038(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         CurrentByte;                                       // 0x003C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B9A[0x3];                                     // 0x003D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CurrentBytePosition;                               // 0x0040(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B9B[0x4];                                     // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Empty();
	bool GetBit();
	TArray<bool> GetBitArray();
	bool GetBoolean();
	TArray<bool> GetBooleanArray();
	uint8 GetByte();
	TArray<uint8> GetByteArray();
	TArray<uint8> GetByteArrayLeastSignificantBits(const int32 BitCount);
	TArray<uint8> GetByteArrayMostSignificantBits(const int32 BitCount);
	uint8 GetByteLeastSignificantBits(const int32 BitCount);
	uint8 GetByteMostSignificantBits(const int32 BitCount);
	class ULowEntryBitDataReader* GetClone();
	double GetDouble();
	TArray<double> GetDoubleArray();
	class ULowEntryDouble* GetDoubleBytes();
	TArray<class ULowEntryDouble*> GetDoubleBytesArray();
	float GetFloat();
	TArray<float> GetFloatArray();
	int32 GetInteger();
	TArray<int32> GetIntegerArray();
	TArray<int32> GetIntegerArrayLeastSignificantBits(const int32 BitCount);
	TArray<int32> GetIntegerArrayMostSignificantBits(const int32 BitCount);
	int32 GetIntegerLeastSignificantBits(const int32 BitCount);
	int32 GetIntegerMostSignificantBits(int32 BitCount);
	int64 GetLong();
	TArray<int64> GetLongArray();
	class ULowEntryLong* GetLongBytes();
	TArray<class ULowEntryLong*> GetLongBytesArray();
	int32 GetPosition();
	int32 GetPositiveInteger1();
	TArray<int32> GetPositiveInteger1Array();
	int32 GetPositiveInteger2();
	TArray<int32> GetPositiveInteger2Array();
	int32 GetPositiveInteger3();
	TArray<int32> GetPositiveInteger3Array();
	class FString GetStringUtf8();
	TArray<class FString> GetStringUtf8Array();
	int32 Remaining();
	void Reset();
	void SetPosition(const int32 Position_);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LowEntryBitDataReader">();
	}
	static class ULowEntryBitDataReader* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULowEntryBitDataReader>();
	}
};
static_assert(alignof(ULowEntryBitDataReader) == 0x000008, "Wrong alignment on ULowEntryBitDataReader");
static_assert(sizeof(ULowEntryBitDataReader) == 0x000048, "Wrong size on ULowEntryBitDataReader");
static_assert(offsetof(ULowEntryBitDataReader, Bytes) == 0x000028, "Member 'ULowEntryBitDataReader::Bytes' has a wrong offset!");
static_assert(offsetof(ULowEntryBitDataReader, Position) == 0x000038, "Member 'ULowEntryBitDataReader::Position' has a wrong offset!");
static_assert(offsetof(ULowEntryBitDataReader, CurrentByte) == 0x00003C, "Member 'ULowEntryBitDataReader::CurrentByte' has a wrong offset!");
static_assert(offsetof(ULowEntryBitDataReader, CurrentBytePosition) == 0x000040, "Member 'ULowEntryBitDataReader::CurrentBytePosition' has a wrong offset!");

// Class LowEntryExtendedStandardLibrary.LowEntryBitDataWriter
// 0x0018 (0x0040 - 0x0028)
class ULowEntryBitDataWriter final : public UObject
{
public:
	TArray<uint8>                                 Bytes;                                             // 0x0028(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         CurrentByte;                                       // 0x0038(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1BA2[0x3];                                     // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CurrentBytePosition;                               // 0x003C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void AddBit(const bool Value);
	void AddBitArray(const TArray<bool>& Value);
	void AddBoolean(const bool Value);
	void AddBooleanArray(const TArray<bool>& Value);
	void AddByte(const uint8 Value);
	void AddByteArray(const TArray<uint8>& Value);
	void AddByteArrayLeastSignificantBits(const TArray<uint8>& Value, const int32 BitCount);
	void AddByteArrayMostSignificantBits(const TArray<uint8>& Value, const int32 BitCount);
	void AddByteLeastSignificantBits(const uint8 Value, const int32 BitCount);
	void AddByteMostSignificantBits(const uint8 Value, const int32 BitCount);
	void AddDouble(const double Value);
	void AddDoubleArray(const TArray<double>& Value);
	void AddDoubleBytes(class ULowEntryDouble* Value);
	void AddDoubleBytesArray(const TArray<class ULowEntryDouble*>& Value);
	void AddFloat(const float Value);
	void AddFloatArray(const TArray<float>& Value);
	void AddInteger(const int32 Value);
	void AddIntegerArray(const TArray<int32>& Value);
	void AddIntegerArrayLeastSignificantBits(const TArray<int32>& Value, const int32 BitCount);
	void AddIntegerArrayMostSignificantBits(const TArray<int32>& Value, const int32 BitCount);
	void AddIntegerLeastSignificantBits(const int32 Value, const int32 BitCount);
	void AddIntegerMostSignificantBits(const int32 Value, int32 BitCount);
	void AddLong(const int64 Value);
	void AddLongArray(const TArray<int64>& Value);
	void AddLongBytes(class ULowEntryLong* Value);
	void AddLongBytesArray(const TArray<class ULowEntryLong*>& Value);
	void AddPositiveInteger1(const int32 Value);
	void AddPositiveInteger1Array(const TArray<int32>& Value);
	void AddPositiveInteger2(const int32 Value);
	void AddPositiveInteger2Array(const TArray<int32>& Value);
	void AddPositiveInteger3(const int32 Value);
	void AddPositiveInteger3Array(const TArray<int32>& Value);
	void AddStringUtf8(const class FString& Value);
	void AddStringUtf8Array(const TArray<class FString>& Value);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LowEntryBitDataWriter">();
	}
	static class ULowEntryBitDataWriter* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULowEntryBitDataWriter>();
	}
};
static_assert(alignof(ULowEntryBitDataWriter) == 0x000008, "Wrong alignment on ULowEntryBitDataWriter");
static_assert(sizeof(ULowEntryBitDataWriter) == 0x000040, "Wrong size on ULowEntryBitDataWriter");
static_assert(offsetof(ULowEntryBitDataWriter, Bytes) == 0x000028, "Member 'ULowEntryBitDataWriter::Bytes' has a wrong offset!");
static_assert(offsetof(ULowEntryBitDataWriter, CurrentByte) == 0x000038, "Member 'ULowEntryBitDataWriter::CurrentByte' has a wrong offset!");
static_assert(offsetof(ULowEntryBitDataWriter, CurrentBytePosition) == 0x00003C, "Member 'ULowEntryBitDataWriter::CurrentBytePosition' has a wrong offset!");

// Class LowEntryExtendedStandardLibrary.LowEntryByteArray
// 0x0010 (0x0038 - 0x0028)
class ULowEntryByteArray final : public UObject
{
public:
	TArray<uint8>                                 ByteArray;                                         // 0x0028(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LowEntryByteArray">();
	}
	static class ULowEntryByteArray* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULowEntryByteArray>();
	}
};
static_assert(alignof(ULowEntryByteArray) == 0x000008, "Wrong alignment on ULowEntryByteArray");
static_assert(sizeof(ULowEntryByteArray) == 0x000038, "Wrong size on ULowEntryByteArray");
static_assert(offsetof(ULowEntryByteArray, ByteArray) == 0x000028, "Member 'ULowEntryByteArray::ByteArray' has a wrong offset!");

// Class LowEntryExtendedStandardLibrary.LowEntryByteDataEntry
// 0x00D8 (0x0100 - 0x0028)
class ULowEntryByteDataEntry final : public UObject
{
public:
	uint8                                         Type;                                              // 0x0028(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         ByteValue;                                         // 0x0029(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1BA9[0x2];                                     // 0x002A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         IntegerValue;                                      // 0x002C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         LongValue;                                         // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULowEntryLong*                          LongBytesValue;                                    // 0x0038(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FloatValue;                                        // 0x0040(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1BAA[0x4];                                     // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        DoubleValue;                                       // 0x0048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULowEntryDouble*                        DoubleBytesValue;                                  // 0x0050(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          BooleanValue;                                      // 0x0058(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1BAB[0x7];                                     // 0x0059(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 StringUtf8Value;                                   // 0x0060(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<uint8>                                 ByteArrayValue;                                    // 0x0070(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 IntegerArrayValue;                                 // 0x0080(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int64>                                 LongArrayValue;                                    // 0x0090(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class ULowEntryLong*>                  LongBytesArrayValue;                               // 0x00A0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<float>                                 FloatArrayValue;                                   // 0x00B0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<double>                                DoubleArrayValue;                                  // 0x00C0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class ULowEntryDouble*>                DoubleBytesArrayValue;                             // 0x00D0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<bool>                                  BooleanArrayValue;                                 // 0x00E0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FString>                         StringUtf8ArrayValue;                              // 0x00F0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LowEntryByteDataEntry">();
	}
	static class ULowEntryByteDataEntry* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULowEntryByteDataEntry>();
	}
};
static_assert(alignof(ULowEntryByteDataEntry) == 0x000008, "Wrong alignment on ULowEntryByteDataEntry");
static_assert(sizeof(ULowEntryByteDataEntry) == 0x000100, "Wrong size on ULowEntryByteDataEntry");
static_assert(offsetof(ULowEntryByteDataEntry, Type) == 0x000028, "Member 'ULowEntryByteDataEntry::Type' has a wrong offset!");
static_assert(offsetof(ULowEntryByteDataEntry, ByteValue) == 0x000029, "Member 'ULowEntryByteDataEntry::ByteValue' has a wrong offset!");
static_assert(offsetof(ULowEntryByteDataEntry, IntegerValue) == 0x00002C, "Member 'ULowEntryByteDataEntry::IntegerValue' has a wrong offset!");
static_assert(offsetof(ULowEntryByteDataEntry, LongValue) == 0x000030, "Member 'ULowEntryByteDataEntry::LongValue' has a wrong offset!");
static_assert(offsetof(ULowEntryByteDataEntry, LongBytesValue) == 0x000038, "Member 'ULowEntryByteDataEntry::LongBytesValue' has a wrong offset!");
static_assert(offsetof(ULowEntryByteDataEntry, FloatValue) == 0x000040, "Member 'ULowEntryByteDataEntry::FloatValue' has a wrong offset!");
static_assert(offsetof(ULowEntryByteDataEntry, DoubleValue) == 0x000048, "Member 'ULowEntryByteDataEntry::DoubleValue' has a wrong offset!");
static_assert(offsetof(ULowEntryByteDataEntry, DoubleBytesValue) == 0x000050, "Member 'ULowEntryByteDataEntry::DoubleBytesValue' has a wrong offset!");
static_assert(offsetof(ULowEntryByteDataEntry, BooleanValue) == 0x000058, "Member 'ULowEntryByteDataEntry::BooleanValue' has a wrong offset!");
static_assert(offsetof(ULowEntryByteDataEntry, StringUtf8Value) == 0x000060, "Member 'ULowEntryByteDataEntry::StringUtf8Value' has a wrong offset!");
static_assert(offsetof(ULowEntryByteDataEntry, ByteArrayValue) == 0x000070, "Member 'ULowEntryByteDataEntry::ByteArrayValue' has a wrong offset!");
static_assert(offsetof(ULowEntryByteDataEntry, IntegerArrayValue) == 0x000080, "Member 'ULowEntryByteDataEntry::IntegerArrayValue' has a wrong offset!");
static_assert(offsetof(ULowEntryByteDataEntry, LongArrayValue) == 0x000090, "Member 'ULowEntryByteDataEntry::LongArrayValue' has a wrong offset!");
static_assert(offsetof(ULowEntryByteDataEntry, LongBytesArrayValue) == 0x0000A0, "Member 'ULowEntryByteDataEntry::LongBytesArrayValue' has a wrong offset!");
static_assert(offsetof(ULowEntryByteDataEntry, FloatArrayValue) == 0x0000B0, "Member 'ULowEntryByteDataEntry::FloatArrayValue' has a wrong offset!");
static_assert(offsetof(ULowEntryByteDataEntry, DoubleArrayValue) == 0x0000C0, "Member 'ULowEntryByteDataEntry::DoubleArrayValue' has a wrong offset!");
static_assert(offsetof(ULowEntryByteDataEntry, DoubleBytesArrayValue) == 0x0000D0, "Member 'ULowEntryByteDataEntry::DoubleBytesArrayValue' has a wrong offset!");
static_assert(offsetof(ULowEntryByteDataEntry, BooleanArrayValue) == 0x0000E0, "Member 'ULowEntryByteDataEntry::BooleanArrayValue' has a wrong offset!");
static_assert(offsetof(ULowEntryByteDataEntry, StringUtf8ArrayValue) == 0x0000F0, "Member 'ULowEntryByteDataEntry::StringUtf8ArrayValue' has a wrong offset!");

// Class LowEntryExtendedStandardLibrary.LowEntryByteDataReader
// 0x0018 (0x0040 - 0x0028)
class ULowEntryByteDataReader final : public UObject
{
public:
	TArray<uint8>                                 Bytes;                                             // 0x0028(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         Position;                                          // 0x0038(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1BAC[0x4];                                     // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Empty();
	bool GetBoolean();
	TArray<bool> GetBooleanArray();
	uint8 GetByte();
	TArray<uint8> GetByteArray();
	class ULowEntryByteDataReader* GetClone();
	double GetDouble();
	TArray<double> GetDoubleArray();
	class ULowEntryDouble* GetDoubleBytes();
	TArray<class ULowEntryDouble*> GetDoubleBytesArray();
	float GetFloat();
	TArray<float> GetFloatArray();
	int32 GetInteger();
	TArray<int32> GetIntegerArray();
	int64 GetLong();
	TArray<int64> GetLongArray();
	class ULowEntryLong* GetLongBytes();
	TArray<class ULowEntryLong*> GetLongBytesArray();
	int32 GetPosition();
	int32 GetPositiveInteger1();
	TArray<int32> GetPositiveInteger1Array();
	int32 GetPositiveInteger2();
	TArray<int32> GetPositiveInteger2Array();
	int32 GetPositiveInteger3();
	TArray<int32> GetPositiveInteger3Array();
	class FString GetStringUtf8();
	TArray<class FString> GetStringUtf8Array();
	int32 Remaining();
	void Reset();
	void SetPosition(const int32 Position_);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LowEntryByteDataReader">();
	}
	static class ULowEntryByteDataReader* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULowEntryByteDataReader>();
	}
};
static_assert(alignof(ULowEntryByteDataReader) == 0x000008, "Wrong alignment on ULowEntryByteDataReader");
static_assert(sizeof(ULowEntryByteDataReader) == 0x000040, "Wrong size on ULowEntryByteDataReader");
static_assert(offsetof(ULowEntryByteDataReader, Bytes) == 0x000028, "Member 'ULowEntryByteDataReader::Bytes' has a wrong offset!");
static_assert(offsetof(ULowEntryByteDataReader, Position) == 0x000038, "Member 'ULowEntryByteDataReader::Position' has a wrong offset!");

// Class LowEntryExtendedStandardLibrary.LowEntryByteDataWriter
// 0x0010 (0x0038 - 0x0028)
class ULowEntryByteDataWriter final : public UObject
{
public:
	TArray<uint8>                                 Bytes;                                             // 0x0028(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void AddBoolean(const bool Value);
	void AddBooleanArray(const TArray<bool>& Value);
	void AddByte(const uint8 Value);
	void AddByteArray(const TArray<uint8>& Value);
	void AddDouble(const double Value);
	void AddDoubleArray(const TArray<double>& Value);
	void AddDoubleBytes(class ULowEntryDouble* Value);
	void AddDoubleBytesArray(const TArray<class ULowEntryDouble*>& Value);
	void AddFloat(const float Value);
	void AddFloatArray(const TArray<float>& Value);
	void AddInteger(const int32 Value);
	void AddIntegerArray(const TArray<int32>& Value);
	void AddLong(const int64 Value);
	void AddLongArray(const TArray<int64>& Value);
	void AddLongBytes(class ULowEntryLong* Value);
	void AddLongBytesArray(const TArray<class ULowEntryLong*>& Value);
	void AddPositiveInteger1(const int32 Value);
	void AddPositiveInteger1Array(const TArray<int32>& Value);
	void AddPositiveInteger2(const int32 Value);
	void AddPositiveInteger2Array(const TArray<int32>& Value);
	void AddPositiveInteger3(const int32 Value);
	void AddPositiveInteger3Array(const TArray<int32>& Value);
	void AddStringUtf8(const class FString& Value);
	void AddStringUtf8Array(const TArray<class FString>& Value);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LowEntryByteDataWriter">();
	}
	static class ULowEntryByteDataWriter* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULowEntryByteDataWriter>();
	}
};
static_assert(alignof(ULowEntryByteDataWriter) == 0x000008, "Wrong alignment on ULowEntryByteDataWriter");
static_assert(sizeof(ULowEntryByteDataWriter) == 0x000038, "Wrong size on ULowEntryByteDataWriter");
static_assert(offsetof(ULowEntryByteDataWriter, Bytes) == 0x000028, "Member 'ULowEntryByteDataWriter::Bytes' has a wrong offset!");

// Class LowEntryExtendedStandardLibrary.LowEntryDouble
// 0x0010 (0x0038 - 0x0028)
class ULowEntryDouble final : public UObject
{
public:
	TArray<uint8>                                 Bytes;                                             // 0x0028(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)

public:
	class ULowEntryLong* CastToLongBytes();
	class FString CastToString(const int32 MinFractionalDigits);
	class ULowEntryDouble* CreateClone();
	void DoubleBytes_Add(class ULowEntryDouble* Value);
	bool DoubleBytes_Equals(class ULowEntryDouble* Value);
	bool DoubleBytes_GreaterThan(class ULowEntryDouble* Value);
	bool DoubleBytes_LessThan(class ULowEntryDouble* Value);
	void DoubleBytes_Subtract(class ULowEntryDouble* Value);
	void Float_Add(const double Value);
	bool Float_Equals(const double Value);
	bool Float_GreaterThan(const double Value);
	bool Float_LessThan(const double Value);
	void Float_Subtract(const double Value);
	TArray<uint8> GetBytes();
	double GetDouble();
	bool Integer_GreaterThan(const int32 Value);
	bool Integer_LessThan(const int32 Value);
	bool LongBytes_GreaterThan(class ULowEntryLong* Value);
	bool LongBytes_LessThan(class ULowEntryLong* Value);
	void SetBytes(const TArray<uint8>& ByteArray, int32 Param_Index, int32 Length);
	void SetDouble(const double Value);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LowEntryDouble">();
	}
	static class ULowEntryDouble* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULowEntryDouble>();
	}
};
static_assert(alignof(ULowEntryDouble) == 0x000008, "Wrong alignment on ULowEntryDouble");
static_assert(sizeof(ULowEntryDouble) == 0x000038, "Wrong size on ULowEntryDouble");
static_assert(offsetof(ULowEntryDouble, Bytes) == 0x000028, "Member 'ULowEntryDouble::Bytes' has a wrong offset!");

// Class LowEntryExtendedStandardLibrary.LowEntryExecutionQueue
// 0x0008 (0x0030 - 0x0028)
class ULowEntryExecutionQueue final : public UObject
{
public:
	int32                                         Count;                                             // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Next;                                              // 0x002C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1BB8[0x3];                                     // 0x002D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LowEntryExecutionQueue">();
	}
	static class ULowEntryExecutionQueue* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULowEntryExecutionQueue>();
	}
};
static_assert(alignof(ULowEntryExecutionQueue) == 0x000008, "Wrong alignment on ULowEntryExecutionQueue");
static_assert(sizeof(ULowEntryExecutionQueue) == 0x000030, "Wrong size on ULowEntryExecutionQueue");
static_assert(offsetof(ULowEntryExecutionQueue, Count) == 0x000028, "Member 'ULowEntryExecutionQueue::Count' has a wrong offset!");
static_assert(offsetof(ULowEntryExecutionQueue, Next) == 0x00002C, "Member 'ULowEntryExecutionQueue::Next' has a wrong offset!");

// Class LowEntryExtendedStandardLibrary.LowEntryExtendedStandardLibrary
// 0x0000 (0x0028 - 0x0028)
class ULowEntryExtendedStandardLibrary final : public UBlueprintFunctionLibrary
{
public:
	static bool AndroidPlatform();
	static bool AreAndroidHeadphonesPluggedIn();
	static bool AreBytesEqual(const TArray<uint8>& A, const TArray<uint8>& B, int32 IndexA, int32 LengthA, int32 IndexB, int32 LengthB);
	static class FString Base64ToBase64Url(const class FString& Base64);
	static TArray<uint8> Base64ToBytes(const class FString& Base64);
	static class FString Base64UrlToBase64(const class FString& Base64Url);
	static TArray<uint8> Base64UrlToBytes(const class FString& Base64Url);
	static TArray<uint8> BCrypt(const TArray<uint8>& ByteArray, const TArray<uint8>& Salt, int32 Strength, int32 Param_Index, int32 Length);
	static TArray<uint8> BinaryToBytes(const class FString& Binary);
	static class ULowEntryBitDataEntry* BitDataEntry_CreateFromBit(const bool Value);
	static class ULowEntryBitDataEntry* BitDataEntry_CreateFromBitArray(const TArray<bool>& Value);
	static class ULowEntryBitDataEntry* BitDataEntry_CreateFromBoolean(const bool Value);
	static class ULowEntryBitDataEntry* BitDataEntry_CreateFromBooleanArray(const TArray<bool>& Value);
	static class ULowEntryBitDataEntry* BitDataEntry_CreateFromByte(const uint8 Value);
	static class ULowEntryBitDataEntry* BitDataEntry_CreateFromByteArray(const TArray<uint8>& Value);
	static class ULowEntryBitDataEntry* BitDataEntry_CreateFromByteArrayLeastSignificantBits(const TArray<uint8>& Value, const int32 BitCount);
	static class ULowEntryBitDataEntry* BitDataEntry_CreateFromByteArrayMostSignificantBits(const TArray<uint8>& Value, const int32 BitCount);
	static class ULowEntryBitDataEntry* BitDataEntry_CreateFromByteLeastSignificantBits(const uint8 Value, const int32 BitCount);
	static class ULowEntryBitDataEntry* BitDataEntry_CreateFromByteMostSignificantBits(const uint8 Value, const int32 BitCount);
	static class ULowEntryBitDataEntry* BitDataEntry_CreateFromDouble(const double Value);
	static class ULowEntryBitDataEntry* BitDataEntry_CreateFromDoubleArray(const TArray<double>& Value);
	static class ULowEntryBitDataEntry* BitDataEntry_CreateFromDoubleBytes(class ULowEntryDouble* Value);
	static class ULowEntryBitDataEntry* BitDataEntry_CreateFromDoubleBytesArray(const TArray<class ULowEntryDouble*>& Value);
	static class ULowEntryBitDataEntry* BitDataEntry_CreateFromFloat(const float Value);
	static class ULowEntryBitDataEntry* BitDataEntry_CreateFromFloatArray(const TArray<float>& Value);
	static class ULowEntryBitDataEntry* BitDataEntry_CreateFromInteger(const int32 Value);
	static class ULowEntryBitDataEntry* BitDataEntry_CreateFromIntegerArray(const TArray<int32>& Value);
	static class ULowEntryBitDataEntry* BitDataEntry_CreateFromIntegerArrayLeastSignificantBits(const TArray<int32>& Value, const int32 BitCount);
	static class ULowEntryBitDataEntry* BitDataEntry_CreateFromIntegerArrayMostSignificantBits(const TArray<int32>& Value, const int32 BitCount);
	static class ULowEntryBitDataEntry* BitDataEntry_CreateFromIntegerLeastSignificantBits(const int32 Value, const int32 BitCount);
	static class ULowEntryBitDataEntry* BitDataEntry_CreateFromIntegerMostSignificantBits(const int32 Value, const int32 BitCount);
	static class ULowEntryBitDataEntry* BitDataEntry_CreateFromLong(const int64 Value);
	static class ULowEntryBitDataEntry* BitDataEntry_CreateFromLongArray(const TArray<int64>& Value);
	static class ULowEntryBitDataEntry* BitDataEntry_CreateFromLongBytes(class ULowEntryLong* Value);
	static class ULowEntryBitDataEntry* BitDataEntry_CreateFromLongBytesArray(const TArray<class ULowEntryLong*>& Value);
	static class ULowEntryBitDataEntry* BitDataEntry_CreateFromPositiveInteger1(const int32 Value);
	static class ULowEntryBitDataEntry* BitDataEntry_CreateFromPositiveInteger1Array(const TArray<int32>& Value);
	static class ULowEntryBitDataEntry* BitDataEntry_CreateFromPositiveInteger2(const int32 Value);
	static class ULowEntryBitDataEntry* BitDataEntry_CreateFromPositiveInteger2Array(const TArray<int32>& Value);
	static class ULowEntryBitDataEntry* BitDataEntry_CreateFromPositiveInteger3(const int32 Value);
	static class ULowEntryBitDataEntry* BitDataEntry_CreateFromPositiveInteger3Array(const TArray<int32>& Value);
	static class ULowEntryBitDataEntry* BitDataEntry_CreateFromStringUtf8(const class FString& Value);
	static class ULowEntryBitDataEntry* BitDataEntry_CreateFromStringUtf8Array(const TArray<class FString>& Value);
	static class ULowEntryBitDataReader* BitDataReader_Create(const TArray<uint8>& Bytes, int32 Param_Index, int32 Length);
	static class ULowEntryBitDataWriter* BitDataWriter_CreateFromEntryArray(const TArray<class ULowEntryBitDataEntry*>& Array);
	static class ULowEntryBitDataWriter* BitDataWriter_CreateFromEntryArrayPure(const TArray<class ULowEntryBitDataEntry*>& Array);
	static TArray<uint8> BitDataWriter_GetBytes(class ULowEntryBitDataWriter* BitDataWriter);
	static void BitsToByte(const bool Bit1, const bool Bit2, const bool Bit3, const bool Bit4, const bool Bit5, const bool Bit6, const bool Bit7, const bool Bit8, uint8* Byte);
	static TArray<uint8> BitStringToBytes(const class FString& Bits);
	static uint8 BooleanToByte(const bool Value);
	static TArray<uint8> BooleanToBytes(const bool Value);
	static class ULowEntryByteDataEntry* ByteDataEntry_CreateFromBoolean(const bool Value);
	static class ULowEntryByteDataEntry* ByteDataEntry_CreateFromBooleanArray(const TArray<bool>& Value);
	static class ULowEntryByteDataEntry* ByteDataEntry_CreateFromByte(const uint8 Value);
	static class ULowEntryByteDataEntry* ByteDataEntry_CreateFromByteArray(const TArray<uint8>& Value);
	static class ULowEntryByteDataEntry* ByteDataEntry_CreateFromDouble(const double Value);
	static class ULowEntryByteDataEntry* ByteDataEntry_CreateFromDoubleArray(const TArray<double>& Value);
	static class ULowEntryByteDataEntry* ByteDataEntry_CreateFromDoubleBytes(class ULowEntryDouble* Value);
	static class ULowEntryByteDataEntry* ByteDataEntry_CreateFromDoubleBytesArray(const TArray<class ULowEntryDouble*>& Value);
	static class ULowEntryByteDataEntry* ByteDataEntry_CreateFromFloat(const float Value);
	static class ULowEntryByteDataEntry* ByteDataEntry_CreateFromFloatArray(const TArray<float>& Value);
	static class ULowEntryByteDataEntry* ByteDataEntry_CreateFromInteger(const int32 Value);
	static class ULowEntryByteDataEntry* ByteDataEntry_CreateFromIntegerArray(const TArray<int32>& Value);
	static class ULowEntryByteDataEntry* ByteDataEntry_CreateFromLong(const int64 Value);
	static class ULowEntryByteDataEntry* ByteDataEntry_CreateFromLongArray(const TArray<int64>& Value);
	static class ULowEntryByteDataEntry* ByteDataEntry_CreateFromLongBytes(class ULowEntryLong* Value);
	static class ULowEntryByteDataEntry* ByteDataEntry_CreateFromLongBytesArray(const TArray<class ULowEntryLong*>& Value);
	static class ULowEntryByteDataEntry* ByteDataEntry_CreateFromPositiveInteger1(const int32 Value);
	static class ULowEntryByteDataEntry* ByteDataEntry_CreateFromPositiveInteger1Array(const TArray<int32>& Value);
	static class ULowEntryByteDataEntry* ByteDataEntry_CreateFromPositiveInteger2(const int32 Value);
	static class ULowEntryByteDataEntry* ByteDataEntry_CreateFromPositiveInteger2Array(const TArray<int32>& Value);
	static class ULowEntryByteDataEntry* ByteDataEntry_CreateFromPositiveInteger3(const int32 Value);
	static class ULowEntryByteDataEntry* ByteDataEntry_CreateFromPositiveInteger3Array(const TArray<int32>& Value);
	static class ULowEntryByteDataEntry* ByteDataEntry_CreateFromStringUtf8(const class FString& Value);
	static class ULowEntryByteDataEntry* ByteDataEntry_CreateFromStringUtf8Array(const TArray<class FString>& Value);
	static class ULowEntryByteDataReader* ByteDataReader_Create(const TArray<uint8>& Bytes, int32 Param_Index, int32 Length);
	static class ULowEntryByteDataWriter* ByteDataWriter_CreateFromEntryArray(const TArray<class ULowEntryByteDataEntry*>& Array);
	static class ULowEntryByteDataWriter* ByteDataWriter_CreateFromEntryArrayPure(const TArray<class ULowEntryByteDataEntry*>& Array);
	static TArray<uint8> ByteDataWriter_GetBytes(class ULowEntryByteDataWriter* ByteDataWriter);
	static TArray<uint8> BytesSubArray(const TArray<uint8>& ByteArray, int32 Param_Index, int32 Length);
	static class FString BytesToBase64(const TArray<uint8>& ByteArray, int32 Param_Index, int32 Length);
	static class FString BytesToBase64Url(const TArray<uint8>& ByteArray, int32 Param_Index, int32 Length);
	static class FString BytesToBinary(const TArray<uint8>& ByteArray, const bool AddSpaces, int32 Param_Index, int32 Length);
	static class FString BytesToBitString(const TArray<uint8>& ByteArray, const bool AddSpaces, int32 Param_Index, int32 Length);
	static bool BytesToBoolean(const TArray<uint8>& ByteArray, int32 Param_Index, int32 Length);
	static uint8 BytesToByte(const TArray<uint8>& ByteArray, int32 Param_Index, int32 Length);
	static double BytesToDouble(const TArray<uint8>& ByteArray, int32 Param_Index, int32 Length);
	static class ULowEntryDouble* BytesToDoubleBytes(const TArray<uint8>& ByteArray, int32 Param_Index, int32 Length);
	static class UTexture2D* BytesToExistingImage(bool* ReusedGivenTexture2D, class UTexture2D* Texture2D, const TArray<uint8>& ByteArray, const ELowEntryImageFormat ImageFormat, int32 Param_Index, int32 Length);
	static float BytesToFloat(const TArray<uint8>& ByteArray, int32 Param_Index, int32 Length);
	static class FString BytesToHex(const TArray<uint8>& ByteArray, const bool AddSpaces, int32 Param_Index, int32 Length);
	static class UTexture2D* BytesToImage(const TArray<uint8>& ByteArray, const ELowEntryImageFormat ImageFormat, int32 Param_Index, int32 Length);
	static int32 BytesToInteger(const TArray<uint8>& ByteArray, int32 Param_Index, int32 Length);
	static int64 BytesToLong(const TArray<uint8>& ByteArray, int32 Param_Index, int32 Length);
	static class ULowEntryLong* BytesToLongBytes(const TArray<uint8>& ByteArray, int32 Param_Index, int32 Length);
	static void BytesToPixels(const TArray<uint8>& ByteArray, const ELowEntryImageFormat ImageFormat, int32* Width, int32* Height, TArray<struct FColor>* Pixels, int32 Param_Index, int32 Length);
	static class FString BytesToStringUtf8(const TArray<uint8>& ByteArray, int32 Param_Index, int32 Length);
	static void ByteToBits(const uint8 Byte, bool* Bit1, bool* Bit2, bool* Bit3, bool* Bit4, bool* Bit5, bool* Bit6, bool* Bit7, bool* Bit8);
	static bool ByteToBoolean(const uint8 Byte);
	static TArray<uint8> ByteToBytes(const uint8 Value);
	static class FString CarriageReturnCharacter();
	static void CaseSwitchByte(const int32 OnlyCheckFirstX, const uint8 Value, const uint8 _1__, const uint8 _2__, const uint8 _3__, const uint8 _4__, const uint8 _5__, const uint8 _6__, const uint8 _7__, const uint8 _8__, const uint8 _9__, const uint8 _10__, ELowEntryExtendedStandardLibrary1to10other* Branch);
	static void CaseSwitchInteger(const int32 OnlyCheckFirstX, const int32 Value, const int32 _1__, const int32 _2__, const int32 _3__, const int32 _4__, const int32 _5__, const int32 _6__, const int32 _7__, const int32 _8__, const int32 _9__, const int32 _10__, ELowEntryExtendedStandardLibrary1to10other* Branch);
	static void CaseSwitchObject(const int32 OnlyCheckFirstX, const class UObject* Value, const class UObject* _1__, const class UObject* _2__, const class UObject* _3__, const class UObject* _4__, const class UObject* _5__, const class UObject* _6__, const class UObject* _7__, const class UObject* _8__, const class UObject* _9__, const class UObject* _10__, ELowEntryExtendedStandardLibrary1to10other* Branch);
	static double CeilDecimals(double Number, int32 Decimals);
	static void ChangeMap(class UObject* WorldContextObject, const class FString& Map, const class FString& Args, class APlayerController* SpecificPlayer);
	static void ClearAllUserFocus();
	static void ClearKeyboardFocus();
	static void ClearUserFocus(const int32 UserIndex);
	static class FString ClipboardGet();
	static void ClipboardSet(const class FString& Value);
	static void ConvertLocalDateToUtcDate(const struct FDateTime& Local, struct FDateTime* Utc);
	static void ConvertUtcDateToLocalDate(const struct FDateTime& Utc, struct FDateTime* Local);
	static void Crash();
	static void CreateObject(TSubclassOf<class UObject> Param_Class, class UObject** Object);
	static class FString CreateString(const int32 Length, const class FString& Filler);
	static void DateTime_FromUnixTimestamp(class ULowEntryLong* Timestamp, struct FDateTime* DateTime);
	static void DateTime_ToIso8601(const struct FDateTime& DateTime, class FString* String);
	static void DateTime_ToString(const struct FDateTime& DateTime, class FString* String, const class FString& Format);
	static void DateTime_ToUnixTimestamp(const struct FDateTime& DateTime, class ULowEntryLong** Timestamp);
	static bool DebugBuild();
	static void DelayFrames(class UObject* WorldContextObject, int32 Frames, const struct FLatentActionInfo& LatentInfo);
	static bool DesktopPlatform();
	static bool DevelopmentBuild();
	static struct FVector2D Divide_Vector2DVector2D(const struct FVector2D& A, const struct FVector2D& B);
	static class ULowEntryDouble* Double_Create(const TArray<uint8>& ByteArray, int32 Param_Index, int32 Length);
	static class ULowEntryDouble* Double_CreateZero();
	static TArray<uint8> DoubleToBytes(const double Value);
	static class ULowEntryByteArray* EncapsulateByteArray(const TArray<uint8>& ByteArray);
	static void ExecToBoolean(const ELowEntryExtendedStandardLibraryTrueOrFalse Branch, bool* Value);
	static void ExecToByte(const ELowEntryExtendedStandardLibrary0to9 Branch, uint8* Value);
	static void ExecToInteger(const ELowEntryExtendedStandardLibrary0to9 Branch, int32* Value);
	static TArray<uint8> FloatToBytes(const float Value);
	static double FloorDecimals(double Number, int32 Decimals);
	static void GenerateRandomBytes(const int32 Length, TArray<uint8>* ByteArray);
	static void GenerateRandomBytesRandomLength(int32 MinLength, int32 MaxLength, TArray<uint8>* ByteArray);
	static struct FVector2D GetAbsoluteSize(const struct FGeometry& Geometry);
	static struct FVector2D GetAbsoluteToLocalScale(const struct FGeometry& Geometry);
	static int32 GetAndroidBuildVersion();
	static class FString GetAndroidDefaultLocale();
	static class FString GetAndroidDeviceMake();
	static class FString GetAndroidDeviceModel();
	static class FString GetAndroidGlVersion();
	static class FString GetAndroidGpuFamily();
	static int32 GetAndroidNumberOfCores();
	static class FString GetAndroidOsLanguage();
	static class FString GetAndroidVersion();
	static void GetAndroidVolume(int32* Volume);
	static void GetBatteryCharge(int32* Percentage, bool* Success);
	static void GetBatteryState(ELowEntryBatteryState* State, bool* Success);
	static void GetBatteryTemperature(double* Celsius, bool* Success);
	static uint8 GetByteWithBitSet(const uint8 Byte, const int32 Bit, const bool Value);
	static void GetClassWithName(const class FString& ClassName, class UClass** Class_, bool* Success);
	static void GetCurrentVolume(int32* Volume, bool* Success);
	static void GetCurrentVolumePercentage(double* Percentage, bool* Success);
	static void GetGenericTeamId(class AActor* Target, uint8* TeamID);
	static class FName GetKeyboardFocusedWidgetType();
	static struct FVector2D GetLocalToAbsoluteScale(const struct FGeometry& Geometry);
	static void GetMaximumVolume(int32* Volume, bool* Success);
	static void GetMousePosition(bool* Success, int32* X, int32* Y);
	static void GetMousePositionInPercentages(bool* Success, double* X, double* Y);
	static void GetPrimaryMonitorResolution(int32* Width, int32* Height);
	static void GetPrimaryMonitorWorkArea(int32* X, int32* Y, int32* Width, int32* Height);
	static class FString GetProjectName();
	static class FString GetProjectVersion();
	static void GetSplitScreenType(ELowEntrySplitScreenType* Type);
	static class FName GetUserFocusedWidgetType(const int32 UserIndex);
	static void GetWindowBorderSize(bool* Success, struct FMargin* Margin);
	static void GetWindowBounds(bool* Success, int32* X, int32* Y, int32* Width, int32* Height);
	static void GetWindowMode(bool* Success, bool* Fullscreen, bool* IsFullscreenWindowed);
	static void GetWindowPositiomInPercentagesCentered(bool* Success, double* X, double* Y);
	static void GetWindowPosition(bool* Success, int32* X, int32* Y);
	static void GetWindowPositionInPercentagesCentered(bool* Success, double* X, double* Y);
	static void GetWindowSize(bool* Success, int32* Width, int32* Height);
	static struct FColor GrayscalePixel(const struct FColor& Pixel);
	static TArray<struct FColor> GrayscalePixels(const TArray<struct FColor>& Pixel);
	static bool GreaterByteFloat(const uint8 A, const double B);
	static bool GreaterByteInteger(const uint8 A, const int32 B);
	static bool GreaterEqualByteFloat(const uint8 A, const double B);
	static bool GreaterEqualByteInteger(const uint8 A, const int32 B);
	static bool GreaterEqualFloatByte(const double A, const uint8 B);
	static bool GreaterEqualFloatInteger(const double A, const int32 B);
	static bool GreaterEqualIntegerByte(const int32 A, const uint8 B);
	static bool GreaterEqualIntegerFloat(const int32 A, const double B);
	static bool GreaterEqualStringString(const class FString& A, const class FString& B);
	static bool GreaterFloatByte(const double A, const uint8 B);
	static bool GreaterFloatInteger(const double A, const int32 B);
	static bool GreaterIntegerByte(const int32 A, const uint8 B);
	static bool GreaterIntegerFloat(const int32 A, const double B);
	static bool GreaterStringString(const class FString& A, const class FString& B);
	static class FString Hashcash(const class FString& Resource, const int32 Bits);
	static TArray<class FString> HashcashArray(const TArray<class FString>& Resources, const int32 Bits);
	static TArray<class FString> HashcashArrayCustomCreationDate(const TArray<class FString>& Resources, const struct FDateTime& UtcDate, const int32 Bits);
	static class FString HashcashCustomCreationDate(const class FString& Resource, const struct FDateTime& UtcDate, const int32 Bits);
	static class ULowEntryParsedHashcash* HashcashParse(const class FString& Hash);
	static TArray<class ULowEntryParsedHashcash*> HashcashParseArray(const TArray<class FString>& Hashes);
	static TArray<uint8> HexToBytes(const class FString& Hex);
	static TArray<uint8> HMAC(const TArray<uint8>& ByteArray, const TArray<uint8>& Key, ELowEntryHmacAlgorithm Algorithm, int32 Param_Index, int32 Length);
	static void HostGame(class UObject* WorldContextObject, const class FString& Map, const class FString& Args, class APlayerController* SpecificPlayer);
	static bool Html5Platform();
	static TArray<uint8> IntegerToBytes(const int32 Value);
	static bool IosPlatform();
	static bool IsBitSet(const uint8 B, const int32 Bit);
	static void IsWorldRenderingEnabled(bool* Success, bool* Enabled);
	static void JoinGame(class UObject* WorldContextObject, const class FString& ServerAddress, const class FString& Args, class APlayerController* SpecificPlayer);
	static void LatentAction_Create_Boolean(class ULowEntryLatentActionBoolean** LatentAction);
	static void LatentAction_Create_Float(class ULowEntryLatentActionFloat** LatentAction);
	static void LatentAction_Create_Integer(class ULowEntryLatentActionInteger** LatentAction);
	static void LatentAction_Create_None(class ULowEntryLatentActionNone** LatentAction);
	static void LatentAction_Create_Object(class ULowEntryLatentActionObject** LatentAction);
	static void LatentAction_Create_String(class ULowEntryLatentActionString** LatentAction);
	static bool LessByteFloat(const uint8 A, const double B);
	static bool LessByteInteger(const uint8 A, const int32 B);
	static bool LessEqualByteFloat(const uint8 A, const double B);
	static bool LessEqualByteInteger(const uint8 A, const int32 B);
	static bool LessEqualFloatByte(const double A, const uint8 B);
	static bool LessEqualFloatInteger(const double A, const int32 B);
	static bool LessEqualIntegerByte(const int32 A, const uint8 B);
	static bool LessEqualIntegerFloat(const int32 A, const double B);
	static bool LessEqualStringString(const class FString& A, const class FString& B);
	static bool LessFloatByte(const double A, const uint8 B);
	static bool LessFloatInteger(const double A, const int32 B);
	static bool LessIntegerByte(const int32 A, const uint8 B);
	static bool LessIntegerFloat(const int32 A, const double B);
	static bool LessStringString(const class FString& A, const class FString& B);
	static bool LinuxPlatform();
	static void LoadVideo(class UMediaSoundComponent* MediaSoundComponent, const class FString& URL, bool* Success, class UMediaPlayer** MediaPlayer, class UMediaTexture** MediaTexture, const bool PlayOnOpen, const bool Loop);
	static class ULowEntryLong* Long_Create(const TArray<uint8>& ByteArray, int32 Param_Index, int32 Length);
	static class ULowEntryLong* Long_CreateZero();
	static TArray<uint8> LongToBytes(const int64 Value);
	static bool MacPlatform();
	static void MaxOfDateTimeArray(const TArray<struct FDateTime>& DateTimeArray, int32* IndexOfMaxValue, struct FDateTime* MaxValue);
	static void MaxOfStringArray(const TArray<class FString>& StringArray, int32* IndexOfMaxValue, class FString* MaxValue);
	static void MaxOfTimespanArray(const TArray<struct FTimespan>& TimespanArray, int32* IndexOfMaxValue, struct FTimespan* MaxValue);
	static class FString MaxString(const class FString& A, const class FString& B);
	static TArray<uint8> Md5(const TArray<uint8>& ByteArray, int32 Param_Index, int32 Length);
	static TArray<uint8> MergeBytes(const TArray<uint8>& A, const TArray<uint8>& B);
	static TArray<uint8> MergeEncapsulatedByteArrays(const TArray<class ULowEntryByteArray*>& ByteArrays);
	static void MinOfDateTimeArray(const TArray<struct FDateTime>& DateTimeArray, int32* IndexOfMinValue, struct FDateTime* MinValue);
	static void MinOfStringArray(const TArray<class FString>& StringArray, int32* IndexOfMinValue, class FString* MinValue);
	static void MinOfTimespanArray(const TArray<struct FTimespan>& TimespanArray, int32* IndexOfMinValue, struct FTimespan* MinValue);
	static class FString MinString(const class FString& A, const class FString& B);
	static class FString NewlineCharacter();
	static void NextQueueExecution(class ULowEntryExecutionQueue* Queue);
	static bool ParsedHashcashIsValid(class ULowEntryParsedHashcash* Target);
	static class ULowEntryDouble* ParseStringIntoDoubleBytes(const class FString& String);
	static int64 ParseStringIntoLong(const class FString& String);
	static class ULowEntryLong* ParseStringIntoLongBytes(const class FString& String);
	static TArray<uint8> Pearson(const TArray<uint8>& ByteArray, const int32 HashLength, int32 Param_Index, int32 Length);
	static void PixelsToBytes(const int32 Width, const int32 Height, const TArray<struct FColor>& Pixels, const ELowEntryImageFormat ImageFormat, TArray<uint8>* ByteArray, const int32 CompressionQuality);
	static class UTexture2D* PixelsToExistingTexture2D(bool* ReusedGivenTexture2D, class UTexture2D* Texture2D, const int32 Width, const int32 Height, const TArray<struct FColor>& Pixels);
	static class UTexture2D* PixelsToTexture2D(const int32 Width, const int32 Height, const TArray<struct FColor>& Pixels);
	static void PlayerControllerGetLocalPlayer(class APlayerController* PlayerController, bool* Success, class ULocalPlayer** LocalPlayer);
	static bool Ps4Platform();
	static void QueueExecutions(class UObject* WorldContextObject, class ULowEntryExecutionQueue** Queue, const struct FLatentActionInfo& LatentInfo);
	static void RandomDelay(class UObject* WorldContextObject, double MinDuration, double MaxDuration, const struct FLatentActionInfo& LatentInfo);
	static void RandomDelayFrames(class UObject* WorldContextObject, int32 MinFrames, int32 MaxFrames, const struct FLatentActionInfo& LatentInfo);
	static int32 RegexCount(const class FString& String, const class FString& Pattern);
	static TArray<struct FLowEntryRegexMatch> RegexGetMatches(const class FString& String, const class FString& Pattern);
	static bool RegexMatch(const class FString& String, const class FString& Pattern);
	static class FString RegexReplace(const class FString& String, const class FString& Pattern, const class FString& Replacement);
	static class FString RemoveCharactersExcept(const class FString& String, const bool KeepLowercaseAZ, const bool KeepUppercaseAZ, const bool KeepNumbers, const class FString& OtherCharactersToKeep);
	static class FString ReplaceCharactersExcept(const class FString& String, const class FString& ReplacementCharacter, const bool KeepLowercaseAZ, const bool KeepUppercaseAZ, const bool KeepNumbers, const class FString& OtherCharactersToKeep);
	static void RetriggerableDelayFrames(class UObject* WorldContextObject, int32 Frames, const struct FLatentActionInfo& LatentInfo);
	static void RetriggerableRandomDelay(class UObject* WorldContextObject, double MinDuration, double MaxDuration, const struct FLatentActionInfo& LatentInfo);
	static void RetriggerableRandomDelayFrames(class UObject* WorldContextObject, int32 MinFrames, int32 MaxFrames, const struct FLatentActionInfo& LatentInfo);
	static double RoundDecimals(double Number, int32 Decimals);
	static void SceneCapture2D_GetFov(class ASceneCapture2D* SceneCapture2D, double* FOV);
	static void SceneCapture2D_SetFov(class ASceneCapture2D* SceneCapture2D, const double FOV);
	static void SceneCapture2DToBytes(class ASceneCapture2D* SceneCapture2D, const ELowEntryImageFormat ImageFormat, TArray<uint8>* ByteArray, const int32 CompressionQuality);
	static void SceneCapture2DToPixels(class ASceneCapture2D* SceneCapture2D, int32* Width, int32* Height, TArray<struct FColor>* Pixels);
	static void SceneCaptureComponent2D_GetFov(class USceneCaptureComponent2D* SceneCaptureComponent2D, double* FOV);
	static void SceneCaptureComponent2D_SetFov(class USceneCaptureComponent2D* SceneCaptureComponent2D, const double FOV);
	static void SceneCaptureComponent2DToBytes(class USceneCaptureComponent2D* SceneCaptureComponent2D, const ELowEntryImageFormat ImageFormat, TArray<uint8>* ByteArray, const int32 CompressionQuality);
	static void SceneCaptureComponent2DToPixels(class USceneCaptureComponent2D* SceneCaptureComponent2D, int32* Width, int32* Height, TArray<struct FColor>* Pixels);
	static void ServerChangeMap(class UObject* WorldContextObject, const class FString& Map, const class FString& Args, class APlayerController* SpecificPlayer);
	static void SetGenericTeamId(class AActor* Target, const uint8 TeamID);
	static void SetMouseLockedToViewport(const bool Locked);
	static void SetMousePosition(const int32 X, const int32 Y);
	static void SetMousePositionInPercentages(const double X, const double Y);
	static void SetSplitScreenEnabled(const bool Enabled);
	static void SetSplitScreenType_ThreePlayers(const ELowEntrySplitScreenTypeThreePlayers Type);
	static void SetSplitScreenType_TwoPlayers(const ELowEntrySplitScreenTypeTwoPlayers Type);
	static void SetWindowMode(const bool Fullscreen, const bool IsFullscreenWindowed);
	static void SetWindowPositiomInPercentagesCentered(const double X, const double Y);
	static void SetWindowPosition(const int32 X, const int32 Y);
	static void SetWindowPositionInPercentagesCentered(const double X, const double Y);
	static void SetWindowSize(const int32 Width, const int32 Height);
	static void SetWorldRenderingEnabled(const bool Enabled);
	static TArray<uint8> Sha1(const TArray<uint8>& ByteArray, int32 Param_Index, int32 Length);
	static TArray<uint8> Sha256(const TArray<uint8>& ByteArray, int32 Param_Index, int32 Length);
	static TArray<uint8> Sha512(const TArray<uint8>& ByteArray, int32 Param_Index, int32 Length);
	static bool ShippingBuild();
	static void SimpleKismetSystemLibraryPrintString(const class FString& InString);
	static TArray<uint8> SortByteArray(const TArray<uint8>& ByteArray, const bool Reversed);
	static void SortByteArrayDirectly(TArray<uint8>& ByteArray, const bool Reversed);
	static TArray<struct FDateTime> SortDateTimeArray(const TArray<struct FDateTime>& DateTimeArray, const bool Reversed);
	static void SortDateTimeArrayDirectly(TArray<struct FDateTime>& DateTimeArray, const bool Reversed);
	static TArray<double> SortDoubleArray(const TArray<double>& DoubleArray, const bool Reversed);
	static void SortDoubleArrayDirectly(TArray<double>& DoubleArray, const bool Reversed);
	static TArray<float> SortFloatArray(const TArray<float>& FloatArray, const bool Reversed);
	static void SortFloatArrayDirectly(TArray<float>& FloatArray, const bool Reversed);
	static TArray<int32> SortIntegerArray(const TArray<int32>& IntegerArray, const bool Reversed);
	static void SortIntegerArrayDirectly(TArray<int32>& IntegerArray, const bool Reversed);
	static TArray<class UObject*> SortObjectArray(const TArray<class UObject*>& ObjectArray, TDelegate<void(class UObject* ObjectA, class UObject* ObjectB, bool* Result)> Comparator, const bool Reversed);
	static void SortObjectArrayDirectly(TArray<class UObject*>& ObjectArray, TDelegate<void(class UObject* ObjectA, class UObject* ObjectB, bool* Result)> Comparator, const bool Reversed);
	static TArray<class FString> SortStringArray(const TArray<class FString>& StringArray, const bool Reversed);
	static void SortStringArrayDirectly(TArray<class FString>& StringArray, const bool Reversed);
	static TArray<struct FTimespan> SortTimespanArray(const TArray<struct FTimespan>& TimespanArray, const bool Reversed);
	static void SortTimespanArrayDirectly(TArray<struct FTimespan>& TimespanArray, const bool Reversed);
	static double SoundClass_GetPitch(class USoundClass* SoundClass);
	static double SoundClass_GetVolume(class USoundClass* SoundClass);
	static void SoundClass_SetPitch(class USoundClass* SoundClass, const double Pitch);
	static void SoundClass_SetVolume(class USoundClass* SoundClass, const double Volume);
	static void SplitBytes(const TArray<uint8>& ByteArray, const int32 LengthA, TArray<uint8>* A, TArray<uint8>* B);
	static TArray<uint8> StringToBytesUtf8(const class FString& String);
	static bool SwitchPlatform();
	static class FString TabCharacter();
	static bool TestBuild();
	static void Texture2DToBytes(class UTexture2D* Texture2D, const ELowEntryImageFormat ImageFormat, TArray<uint8>* ByteArray, const int32 CompressionQuality);
	static void Texture2DToPixels(class UTexture2D* Texture2D, int32* Width, int32* Height, TArray<struct FColor>* Pixels);
	static void TextureRenderTarget2DToBytes(class UTextureRenderTarget2D* TextureRenderTarget2D, const ELowEntryImageFormat ImageFormat, TArray<uint8>* ByteArray, const int32 CompressionQuality);
	static void TextureRenderTarget2DToPixels(class UTextureRenderTarget2D* TextureRenderTarget2D, int32* Width, int32* Height, TArray<struct FColor>* Pixels);
	static void TextureUpdateResource(class UTexture* Texture);
	static void TickFrames(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, const int32 Ticks, const int32 FramesInterval, int32* Tick);
	static void TickSeconds(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, const int32 Ticks, const double SecondsInterval, int32* Tick);
	static bool Windows32Platform();
	static bool Windows64Platform();
	static class FString WindowsNewlineCharacter();
	static bool WindowsPlatform();
	static bool WindowsRtArmPlatform();
	static bool WindowsRtPlatform();
	static bool WithEditor();
	static bool XboxOnePlatform();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LowEntryExtendedStandardLibrary">();
	}
	static class ULowEntryExtendedStandardLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULowEntryExtendedStandardLibrary>();
	}
};
static_assert(alignof(ULowEntryExtendedStandardLibrary) == 0x000008, "Wrong alignment on ULowEntryExtendedStandardLibrary");
static_assert(sizeof(ULowEntryExtendedStandardLibrary) == 0x000028, "Wrong size on ULowEntryExtendedStandardLibrary");

// Class LowEntryExtendedStandardLibrary.LowEntryLatentActionBoolean
// 0x0008 (0x0030 - 0x0028)
class ULowEntryLatentActionBoolean final : public UObject
{
public:
	bool                                          Finished;                                          // 0x0028(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Result;                                            // 0x0029(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C60[0x2];                                     // 0x002A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         KeepAliveCount;                                    // 0x002C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void Done(bool Result_);
	void GetResult(bool* Result_);
	bool IsDone();
	void WaitTillDone(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, bool* Result_);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LowEntryLatentActionBoolean">();
	}
	static class ULowEntryLatentActionBoolean* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULowEntryLatentActionBoolean>();
	}
};
static_assert(alignof(ULowEntryLatentActionBoolean) == 0x000008, "Wrong alignment on ULowEntryLatentActionBoolean");
static_assert(sizeof(ULowEntryLatentActionBoolean) == 0x000030, "Wrong size on ULowEntryLatentActionBoolean");
static_assert(offsetof(ULowEntryLatentActionBoolean, Finished) == 0x000028, "Member 'ULowEntryLatentActionBoolean::Finished' has a wrong offset!");
static_assert(offsetof(ULowEntryLatentActionBoolean, Result) == 0x000029, "Member 'ULowEntryLatentActionBoolean::Result' has a wrong offset!");
static_assert(offsetof(ULowEntryLatentActionBoolean, KeepAliveCount) == 0x00002C, "Member 'ULowEntryLatentActionBoolean::KeepAliveCount' has a wrong offset!");

// Class LowEntryExtendedStandardLibrary.LowEntryLatentActionFloat
// 0x0018 (0x0040 - 0x0028)
class ULowEntryLatentActionFloat final : public UObject
{
public:
	bool                                          Finished;                                          // 0x0028(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C62[0x7];                                     // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        Result;                                            // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         KeepAliveCount;                                    // 0x0038(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C63[0x4];                                     // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Done(double Result_);
	void GetResult(double* Result_);
	bool IsDone();
	void WaitTillDone(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, double* Result_);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LowEntryLatentActionFloat">();
	}
	static class ULowEntryLatentActionFloat* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULowEntryLatentActionFloat>();
	}
};
static_assert(alignof(ULowEntryLatentActionFloat) == 0x000008, "Wrong alignment on ULowEntryLatentActionFloat");
static_assert(sizeof(ULowEntryLatentActionFloat) == 0x000040, "Wrong size on ULowEntryLatentActionFloat");
static_assert(offsetof(ULowEntryLatentActionFloat, Finished) == 0x000028, "Member 'ULowEntryLatentActionFloat::Finished' has a wrong offset!");
static_assert(offsetof(ULowEntryLatentActionFloat, Result) == 0x000030, "Member 'ULowEntryLatentActionFloat::Result' has a wrong offset!");
static_assert(offsetof(ULowEntryLatentActionFloat, KeepAliveCount) == 0x000038, "Member 'ULowEntryLatentActionFloat::KeepAliveCount' has a wrong offset!");

// Class LowEntryExtendedStandardLibrary.LowEntryLatentActionInteger
// 0x0010 (0x0038 - 0x0028)
class ULowEntryLatentActionInteger final : public UObject
{
public:
	bool                                          Finished;                                          // 0x0028(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C64[0x3];                                     // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Result;                                            // 0x002C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         KeepAliveCount;                                    // 0x0030(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C65[0x4];                                     // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Done(int32 Result_);
	void GetResult(int32* Result_);
	bool IsDone();
	void WaitTillDone(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, int32* Result_);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LowEntryLatentActionInteger">();
	}
	static class ULowEntryLatentActionInteger* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULowEntryLatentActionInteger>();
	}
};
static_assert(alignof(ULowEntryLatentActionInteger) == 0x000008, "Wrong alignment on ULowEntryLatentActionInteger");
static_assert(sizeof(ULowEntryLatentActionInteger) == 0x000038, "Wrong size on ULowEntryLatentActionInteger");
static_assert(offsetof(ULowEntryLatentActionInteger, Finished) == 0x000028, "Member 'ULowEntryLatentActionInteger::Finished' has a wrong offset!");
static_assert(offsetof(ULowEntryLatentActionInteger, Result) == 0x00002C, "Member 'ULowEntryLatentActionInteger::Result' has a wrong offset!");
static_assert(offsetof(ULowEntryLatentActionInteger, KeepAliveCount) == 0x000030, "Member 'ULowEntryLatentActionInteger::KeepAliveCount' has a wrong offset!");

// Class LowEntryExtendedStandardLibrary.LowEntryLatentActionNone
// 0x0008 (0x0030 - 0x0028)
class ULowEntryLatentActionNone final : public UObject
{
public:
	bool                                          Finished;                                          // 0x0028(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C67[0x3];                                     // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         KeepAliveCount;                                    // 0x002C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void Done();
	bool IsDone();
	void WaitTillDone(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LowEntryLatentActionNone">();
	}
	static class ULowEntryLatentActionNone* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULowEntryLatentActionNone>();
	}
};
static_assert(alignof(ULowEntryLatentActionNone) == 0x000008, "Wrong alignment on ULowEntryLatentActionNone");
static_assert(sizeof(ULowEntryLatentActionNone) == 0x000030, "Wrong size on ULowEntryLatentActionNone");
static_assert(offsetof(ULowEntryLatentActionNone, Finished) == 0x000028, "Member 'ULowEntryLatentActionNone::Finished' has a wrong offset!");
static_assert(offsetof(ULowEntryLatentActionNone, KeepAliveCount) == 0x00002C, "Member 'ULowEntryLatentActionNone::KeepAliveCount' has a wrong offset!");

// Class LowEntryExtendedStandardLibrary.LowEntryLatentActionObject
// 0x0018 (0x0040 - 0x0028)
class ULowEntryLatentActionObject final : public UObject
{
public:
	bool                                          Finished;                                          // 0x0028(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C68[0x7];                                     // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                Result;                                            // 0x0030(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         KeepAliveCount;                                    // 0x0038(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C69[0x4];                                     // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Done(class UObject* Result_);
	void GetResult(class UObject** Result_);
	bool IsDone();
	void WaitTillDone(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, class UObject** Result_);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LowEntryLatentActionObject">();
	}
	static class ULowEntryLatentActionObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULowEntryLatentActionObject>();
	}
};
static_assert(alignof(ULowEntryLatentActionObject) == 0x000008, "Wrong alignment on ULowEntryLatentActionObject");
static_assert(sizeof(ULowEntryLatentActionObject) == 0x000040, "Wrong size on ULowEntryLatentActionObject");
static_assert(offsetof(ULowEntryLatentActionObject, Finished) == 0x000028, "Member 'ULowEntryLatentActionObject::Finished' has a wrong offset!");
static_assert(offsetof(ULowEntryLatentActionObject, Result) == 0x000030, "Member 'ULowEntryLatentActionObject::Result' has a wrong offset!");
static_assert(offsetof(ULowEntryLatentActionObject, KeepAliveCount) == 0x000038, "Member 'ULowEntryLatentActionObject::KeepAliveCount' has a wrong offset!");

// Class LowEntryExtendedStandardLibrary.LowEntryLatentActionString
// 0x0020 (0x0048 - 0x0028)
class ULowEntryLatentActionString final : public UObject
{
public:
	bool                                          Finished;                                          // 0x0028(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C6A[0x7];                                     // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Result;                                            // 0x0030(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         KeepAliveCount;                                    // 0x0040(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C6B[0x4];                                     // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Done(const class FString& Result_);
	void GetResult(class FString* Result_);
	bool IsDone();
	void WaitTillDone(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, class FString* Result_);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LowEntryLatentActionString">();
	}
	static class ULowEntryLatentActionString* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULowEntryLatentActionString>();
	}
};
static_assert(alignof(ULowEntryLatentActionString) == 0x000008, "Wrong alignment on ULowEntryLatentActionString");
static_assert(sizeof(ULowEntryLatentActionString) == 0x000048, "Wrong size on ULowEntryLatentActionString");
static_assert(offsetof(ULowEntryLatentActionString, Finished) == 0x000028, "Member 'ULowEntryLatentActionString::Finished' has a wrong offset!");
static_assert(offsetof(ULowEntryLatentActionString, Result) == 0x000030, "Member 'ULowEntryLatentActionString::Result' has a wrong offset!");
static_assert(offsetof(ULowEntryLatentActionString, KeepAliveCount) == 0x000040, "Member 'ULowEntryLatentActionString::KeepAliveCount' has a wrong offset!");

// Class LowEntryExtendedStandardLibrary.LowEntryLong
// 0x0010 (0x0038 - 0x0028)
class ULowEntryLong final : public UObject
{
public:
	TArray<uint8>                                 Bytes;                                             // 0x0028(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)

public:
	class ULowEntryDouble* CastToDoubleBytes();
	class FString CastToString();
	class ULowEntryLong* CreateClone();
	bool DoubleBytes_GreaterThan(class ULowEntryDouble* Value);
	bool DoubleBytes_LessThan(class ULowEntryDouble* Value);
	bool Float_GreaterThan(const double Value);
	bool Float_LessThan(const double Value);
	TArray<uint8> GetBytes();
	int64 GetLong();
	void Integer_Add(const int32 Value);
	bool Integer_Equals(const int32 Value);
	bool Integer_GreaterThan(const int32 Value);
	bool Integer_LessThan(const int32 Value);
	void Integer_Subtract(const int32 Value);
	void LongBytes_Add(class ULowEntryLong* Value);
	bool LongBytes_Equals(class ULowEntryLong* Value);
	bool LongBytes_GreaterThan(class ULowEntryLong* Value);
	bool LongBytes_LessThan(class ULowEntryLong* Value);
	void LongBytes_Subtract(class ULowEntryLong* Value);
	void SetBytes(const TArray<uint8>& ByteArray, int32 Param_Index, int32 Length);
	void SetLong(const int64 Value);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LowEntryLong">();
	}
	static class ULowEntryLong* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULowEntryLong>();
	}
};
static_assert(alignof(ULowEntryLong) == 0x000008, "Wrong alignment on ULowEntryLong");
static_assert(sizeof(ULowEntryLong) == 0x000038, "Wrong size on ULowEntryLong");
static_assert(offsetof(ULowEntryLong, Bytes) == 0x000028, "Member 'ULowEntryLong::Bytes' has a wrong offset!");

// Class LowEntryExtendedStandardLibrary.LowEntryParsedHashcash
// 0x0028 (0x0050 - 0x0028)
class ULowEntryParsedHashcash final : public UObject
{
public:
	bool                                          Valid;                                             // 0x0028(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C76[0x7];                                     // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Resource;                                          // 0x0030(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              Date;                                              // 0x0040(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Bits;                                              // 0x0048(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C77[0x4];                                     // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	int32 GetBits();
	struct FDateTime GetDate();
	class FString GetResource();
	class FString ToString();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LowEntryParsedHashcash">();
	}
	static class ULowEntryParsedHashcash* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULowEntryParsedHashcash>();
	}
};
static_assert(alignof(ULowEntryParsedHashcash) == 0x000008, "Wrong alignment on ULowEntryParsedHashcash");
static_assert(sizeof(ULowEntryParsedHashcash) == 0x000050, "Wrong size on ULowEntryParsedHashcash");
static_assert(offsetof(ULowEntryParsedHashcash, Valid) == 0x000028, "Member 'ULowEntryParsedHashcash::Valid' has a wrong offset!");
static_assert(offsetof(ULowEntryParsedHashcash, Resource) == 0x000030, "Member 'ULowEntryParsedHashcash::Resource' has a wrong offset!");
static_assert(offsetof(ULowEntryParsedHashcash, Date) == 0x000040, "Member 'ULowEntryParsedHashcash::Date' has a wrong offset!");
static_assert(offsetof(ULowEntryParsedHashcash, Bits) == 0x000048, "Member 'ULowEntryParsedHashcash::Bits' has a wrong offset!");

}

